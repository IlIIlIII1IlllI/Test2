PROJECT STRUCTURE:
==================
./
    .gitignore
    index.html
    laser-export.js
    LICENSE
    package-lock.json
    package.json
    PBN_Istzustand_vs_Original.md
    README.md
    report.20260112.225834.29868.0.001.json
    report.20260112.225841.45404.0.001.json
    report.20260112.225848.19388.0.001.json
    report.20260117.142506.10308.0.001.json
    runtime-manual-recolor.js
    runtime-protection.js
    runtime-recolor.js
    runtime-target-size.js
    Start-PaintByNumbers.bat
    Start-PaintByNumbers.ps1
    .github/
        workflows/
            main.yml
    scripts/
        main.js
        lib/
            jquery-1.11.0.min.js
            materialize.min.js
            require.js
            saveSvgAsPng.js
    src/
        colorreductionmanagement.ts
        common.ts
        facetBorderSegmenter.ts
        facetBorderTracer.ts
        facetCreator.ts
        facetLabelPlacer.ts
        facetmanagement.ts
        facetReducer.ts
        gui.ts
        guiprocessmanager.ts
        main.ts
        random.ts
        settings.ts
        tsconfig.json
        tslint.json
        lib/
            clipboard.ts
            clustering.ts
            colorconversion.ts
            datastructs.ts
            fill.ts
            polylabel.ts
            strokeFont.ts
            svgLaserPrep.ts
            svgTextToSingleLine.ts
        structs/
            boundingbox.ts
            point.ts
            typedarrays.ts
    src-cli/
        main.js.map
        main.ts
        settings.json
        tsconfig.json
        tslint.json
    styles/
        main.css
        lib/
            materialize.min.css


FILE CONTENTS:
==================


--- START FILE: .\.gitignore ---
node_modules
*.js
*.map
--- END FILE: .\.gitignore ---


--- START FILE: .\index.html ---
<!DOCTYPE html>
<html>

<head>
    <title>Paint by number generator</title>
    <link rel="stylesheet" href="styles/lib/materialize.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <link rel='stylesheet' href='styles/main.css' />
</head>

<body>
    <div class="container">
        <div class="row">
            <h2> Paint by number generator </h2>
            <span>Paste from clipboard (ctrl+v) to change the image (or browse for a file <input id="file" type="file"
                    accept="image/x-png,image/gif,image/jpeg"></input>). Large images are very slow to process
                though.</span>
            <br />
            <span>Example images:
                <a id="lnkTrivial" href="#">trivial</a> -
                <a id="lnkSmall" href="#">small</a> -
                <a id="lnkMedium" href="#">medium</a>
            </span>
        </div>
        <div class="row">
            <div class="col s12">
                <ul class="tabs">
                    <li class="tab col s2">
                        <a href="#input-pane">Input</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#options-pane">Options</a>
                    </li>
                </ul>
            </div>
            <div id="input-pane" class="col s12">
                <canvas id="canvas"></canvas>
                <img id="imgTrivial" crossorigin="anonymous" src="https://i.imgur.com/o5CqO57.png"
                    style="display:none" />
                <img id="imgSmall" crossorigin="anonymous" src="https://i.imgur.com/YgYLDGP.png" style="display:none" />

                <img id="imgMedium" crossorigin="anonymous" src="https://i.imgur.com/nLeNgYbr.jpg"
                    style="display:none" />
            </div>
            <!-- I suck at materializecss design, in case you haven't noticed yet -->
            <div id="options-pane" class="col s12">
                <ul class="collection">
                    <li class="collection-item">
                        <div class="row">
                            <div class="col s3" style="margin-top: 34px;">
                                <label>
                                    <input id="chkResizeImage" type="checkbox" checked="checked" />
                                    <span>Resize image larger than
                                        <i class="material-icons tooltipped"
                                            data-tooltip="If checked and the input image is larger than the given dimensions then it will be resized to fit but will maintain its ratio.">info</i>
                                    </span>
                                </label>
                            </div>
                            <div class="col s2">
                                <label for="txtResizeWidth">width</label>
                                <input id="txtResizeWidth" type="number" value="1024" min="1" class="validate">
                            </div>
                            <div class="col s2">
                                <label for="txtResizeHeight">height</label>
                                <input id="txtResizeHeight" type="number" value="1024" min="1" class="validate">
                            </div>
                        </div>
                    </li>
                    <li class="collection-item">
                        <div class="row">
                            <div class="input-field col s2">
                                <input id="txtNrOfClusters" type="number" value="16" min="1" class="validate">
                                <label for="txtNrOfClusters">Number of colors
                                    <i class="material-icons tooltipped"
                                        data-tooltip="The number of colors to quantize the image to">info</i>
                                </label>
                            </div>

                            <div class="input-field col s2">
                                <input id="txtClusterPrecision" type="number" value="1" min="1" step="0.05"
                                    class="validate">
                                <label for="txtClusterPrecision">Cluster precision
                                    <i class="material-icons tooltipped"
                                        data-tooltip="The threshold delta distance of the k-means clustering to reach before stopping. Having a bigger value will speed up the clustering but may yield suboptimal clusters.">info</i>
                                </label>
                            </div>
                            
                            <div class="input-field col s2">
                                <input id="txtRandomSeed" type="number" value="0" min="0" step="1"
                                    class="validate">
                                <label for="txtRandomSeed">Random seed
                                    <i class="material-icons tooltipped"
                                        data-tooltip="The seed to use for the random number generator to choose the initial centroids for k-means clusering. Using the same seed ensures you will get the same result every time.">info</i>
                                </label>
                            </div>
                        </div>
                    </li>
                    <li class="collection-item">
                        <div class="row">

                            <div class="col s3">
                                <label>Clustering color space
                                    <i class="material-icons tooltipped"
                                        data-tooltip="The color space to apply clustering in">info</i>
                                </label>
                            </div>
                            <div class="col s2">
                                <label>
                                    <input id="optColorSpaceRGB" name="colorspace" type="radio" checked />
                                    <span>RGB</span>
                                </label>
                            </div>
                            <div class="col s2">
                                <label>
                                    <input id="optColorSpaceHSL" name="colorspace" type="radio" />
                                    <span>HSL</span>
                                </label>
                            </div>
                            <div class="col s2">
                                <label>
                                    <input id="optColorSpaceLAB" name="colorspace" type="radio" />
                                    <span>Lab</span>
                                </label>
                            </div>

                            <div class="col s12">
                                <label for="txtKMeansColorRestrictions">Restrict clustering colors
                                    <i class="material-icons tooltipped"
                                        data-tooltip="Specify which colors should be used, one per line in 'r,g,b' format. Use // as comment. If no colors are specified no restrictions are applied. Useful if you only have a few colors of paint on hand.">info</i>
                                </label>
                                <textarea id="txtKMeansColorRestrictions" class="materialize-textarea validate">
//0,0,0
//255,255,255
</textarea>
                            </div>
                        </div>
                    </li>
                    <li class="collection-item">
                        <div class="row">
                            <div class="input-field col s4">
                                <input id="txtNarrowPixelStripCleanupRuns" type="number" value="3" min="0"
                                    class="validate">
                                <label for="txtNarrowPixelStripCleanupRuns">Number of runs for narrow pixel cleanup
                                    <i class="material-icons tooltipped"
                                        data-tooltip="Narrow pixel cleanup removes strips of single pixel rows, which would make some facets have some borders segments that are way too narrow to be useful. The small facet removal can introduce new narrow pixel strips, so this is repeated in a few iterative runs.">info</i>
                                </label>
                            </div>
                            <div class="input-field col s4">
                                <input id="txtRemoveFacetsSmallerThan" type="number" value="20" min="1"
                                    class="validate">
                                <label for="txtRemoveFacetsSmallerThan">Remove small facets smaller than (pixels)
                                    <i class="material-icons tooltipped"
                                        data-tooltip="Removes any facets that are smaller than the given amount of pixels. Lowering the value will create more detailed results but might be much harder to actually paint due to their size.">info</i>
                                </label>
                            </div>
                            <div class="input-field col s4">
                                <input id="txtMaximumNumberOfFacets" type="number" value="100000" min="1"
                                    class="validate">
                                <label for="txtMaximumNumberOfFacets">Maximum number of facets
                                    <i class="material-icons tooltipped"
                                        data-tooltip="If there are more facets than the given maximum number, keep removing the smallest facets until the limit is reached">info</i>
                                </label>
                            </div>
                        </div>
                        <div class="row">
                            <div class="input-field col s6">
                                <div class="row">
                                    <div class="col s4">
                                        <label>Small facet removal order
                                            <i class="material-icons tooltipped"
                                                data-tooltip="Largest to smallest will prevent boundaries from warping the shapes because the smaller facets act as border anchorpoints but can be considerably slower">info</i>
                                        </label>
                                    </div>
                                    <div class="col s4">
                                        <label>
                                            <input id="optFacetRemovalLargestToSmallest" name="smallfacetremovalorder"
                                                type="radio" checked />
                                            <span>Largest to smallest</span>
                                        </label>
                                    </div>
                                    <div class="col s4">
                                        <label>
                                            <input id="optFacetRemovalSmallestToLargest" name="smallfacetremovalorder"
                                                type="radio" />
                                            <span>Smallest to largest</span>
                                        </label>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </li>
                    <li class="collection-item">
                        <div class="row">
                            <div class="input-field col s5">
                                <input id="txtNrOfTimesToHalveBorderSegments" type="number" value="2" min="0"
                                    class="validate">
                                <label for="txtNrOfTimesToHalveBorderSegments">Amount of times to halve border segment
                                    complexity)
                                    <i class="material-icons tooltipped"
                                        data-tooltip="Reducing the amount of points in a border segment (using haar wavelet reduction) will smooth out the quadratic curve more but at a loss of detail. <br/>A segment (shared border with a facet) will always retain its start and end point.">info</i>
                                </label>
                            </div>
                        </div>
                    </li>
                </ul>

            </div>

            <div class="col s12">
                <a class="waves-effect waves-light btn" id="btnProcess">Process image</a>
            </div>
        </div>

        <div class="row">

            <div class="col s2">
                <div class="status kMeans">
                    K-means clustering
                    <div class="progress">
                        <div id="statusKMeans" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="col s2">
                <div class="status facetBuilding">
                    Facet building
                    <div class="progress">
                        <div id="statusFacetBuilding" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="col s2">
                <div class="status facetReduction">
                    Small facet pruning
                    <div class="progress">
                        <div id="statusFacetReduction" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="col s2">
                <div class="status facetBorderPath">
                    Border detection
                    <div class="progress">
                        <div id="statusFacetBorderPath" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="col s2">
                <div class="status facetBorderSegmentation">
                    Border segmentation
                    <div class="progress">
                        <div id="statusFacetBorderSegmentation" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="col s2">
                <div class="status facetLabelPlacement">
                    Label placement
                    <div class="progress">
                        <div id="statusFacetLabelPlacement" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col s2">
                <div class="status SVGGenerate">
                    SVG generation
                    <div class="progress">
                        <div id="statusSVGGenerate" class="determinate" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col s12">
                <ul id="tabsOutput" class="tabs">
                    <li class="tab col s2">
                        <a href="#kmeans-pane">Quantized image</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#reduction-pane">Facet reduction</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#borderpath-pane">Border tracing</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#bordersegmentation-pane">Border segmentation</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#labelplacement-pane">Label placement</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#output-pane">Output</a>
                    </li>
                    <li class="tab col s2">
                        <a href="#log-pane">Log</a>
                    </li>
                </ul>
            </div>
            <div id="kmeans-pane" class="col s12">
                <canvas id="cKMeans"></canvas>
            </div>
            <div id="reduction-pane" class="col s12">
                <canvas id="cReduction"></canvas>
            </div>
            <div id="borderpath-pane" class="col s12">
                <canvas id="cBorderPath"></canvas>
            </div>
            <div id="bordersegmentation-pane" class="col s12">
                <canvas id="cBorderSegmentation"></canvas>
            </div>
            <div id="labelplacement-pane" class="col s12">
                <canvas id="cLabelPlacement"></canvas>
            </div>

            <div id="output-pane" class="col s12">
                <div class="row">
                    <div class="col s2">
                        <label>SVG Render options</label>
                    </div>
                    <div class="col s2">
                        <label>
                            <input id="chkShowLabels" type="checkbox" checked="checked" />
                            <span>Show labels</span>
                        </label>
                    </div>
                    <div class="col s2">
                        <label>
                            <input id="chkFillFacets" type="checkbox" checked="checked" />
                            <span>Fill facets</span>
                        </label>
                    </div>
                    <div class="col s2">

                        <label>
                            <input id="chkShowBorders" type="checkbox" checked="checked" />
                            <span>Show borders</span>
                        </label>
                    </div>
                </div>
                <div class="row">
                    <div class="col s3">
                        <div class="input-field">
                            <input placeholder="SVG Size multiplier" id="txtSizeMultiplier" type="number" value="3"
                                min="1" class="validate">
                            <label for="txtSizeMultiplier">SVG size multiplier
                                <i class="material-icons tooltipped"
                                    data-tooltip="Increases the SVG size compared to the original image, useful when the labels don't fit inside the tiny segments">info</i>
                            </label>
                        </div>
                    </div>
                    <div class="col s3">
                        <div class="input-field">
                            <input placeholder="Label font size" id="txtLabelFontSize" type="number" value="50" min="1"
                                max="100">
                            <label for="txtLabelFontSize">Label font size
                                <i class="material-icons tooltipped"
                                    data-tooltip="Font size of the color number labels in each facet, in percentage relative to the largest circle found inside a facet.">info</i>
                            </label>
                        </div>
                    </div>
                    <div class="col s3">
                        <div class="input-field">
                            <input placeholder="Label font size" id="txtLabelFontColor" type="text" value="#000">
                            <label for="txtLabelFontColor">Label font color
                                <i class="material-icons tooltipped"
                                    data-tooltip="Font color of the color number labels in each facet">info</i>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div id="palette" class="palette">

                    </div>
                </div>
                <div class="row">
                    <div class="col s12">
                        <div id="svgContainer">

                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="col s3">
                        <a class="waves-effect waves-light btn" id="btnDownloadSVG">Download SVG</a>
                    </div>
                    <div class="col s3">
                        <a class="waves-effect waves-light btn" id="btnDownloadPNG">Download PNG</a>
                    </div>
                    <div class="col s3">
                        <a class="waves-effect waves-light btn" id="btnDownloadPalettePNG">Download palette</a>
                    </div>
                </div>
            </div>

            <div id="log-pane" class="col s12">
                <div class="row">
                    <div class="col s12">
                        <div id="log"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="scripts/lib/saveSvgAsPng.js"></script>
    <script src="scripts/lib/require.js"></script>
    <script src="scripts/lib/jquery-1.11.0.min.js"></script>
    <script src="scripts/lib/materialize.min.js"></script>
    <script src='scripts/main.js'></script>
    <script>
        requirejs(['main'], function (MyApp) {

        });
    </script>
<script src="laser-export.js"></script>
<script src="runtime-target-size.js"></script>
<script src="runtime-recolor.js"></script>
<script src="runtime-protection.js"></script>
<script src="runtime-manual-recolor.js"></script>
</body>

</html>

--- END FILE: .\index.html ---


--- START FILE: .\laser-export.js ---
/*
 * PaintByNumbersGenerator â€“ Laser export runtime patch (v9.4 - Travel Optimizer)
 *
 * FIXES & FEATURES:
 * - True Deduplication: Every border edge is hashed. Duplicates are deleted.
 * - Path Stitching: Connects touching edges into long continuous paths (fewer Laser ON/OFFs).
 * - Travel Optimization: Sorts paths using "Nearest Neighbor" to minimize rapid moves.
 * - Stable Loading: Output is chunked to prevent LaserGRBL XML parsing errors.
 */

(function () {
  "use strict";

  var DEFAULT_STROKE_WIDTH = 0.35;
  var FORCE_STROKE_COLOR = "#000";
  var BATCH_SIZE = 50; // Smaller chunks for safety with complex stitched paths

  // V8 Simplex Digits
  var DIGITS = {
    "0": { w: 7, s: [[[2,9], [1,8], [1,2], [2,1], [5,1], [6,2], [6,8], [5,9], [2,9]]] },
    "1": { w: 5, s: [[[2,2], [3.5,1], [3.5,9]], [[2,9], [5,9]]] },
    "2": { w: 7, s: [[[1,3], [2,1], [5,1], [6,2], [6,4], [1,9], [7,9]]] },
    "3": { w: 7, s: [[[1,2], [2,1], [5,1], [6,2], [6,4], [4,5], [6,6], [6,8], [5,9], [2,9], [1,8]]] },
    "4": { w: 7, s: [[[5,9], [5,1], [1,6], [7,6]]] }, 
    "5": { w: 7, s: [[[6,1], [1.5,1], [1.5,4], [2,3.5], [5,3.5], [6,4.5], [6,8], [5,9], [2,9], [1,8]]] },
    "6": { w: 7, s: [[[5,1], [2,1], [1,2], [1,8], [2,9], [5,9], [6,8], [6,6], [5,5], [1.5,5]]] },
    "7": { w: 7, s: [[[1,1], [6,1], [3,9]]] },
    "8": { w: 7, s: [[[2,1], [5,1], [6,2], [6,4], [5,5], [2,5], [1,6], [1,8], [2,9], [5,9], [6,8], [6,6], [5,5], [2,4], [1,2], [2,1]]] },
    "9": { w: 7, s: [[[5.5,5], [2,5], [1,4], [1,2], [2,1], [5,1], [6,2], [6,8], [5,9], [2,9]]] },
    " ": { w: 4, s: [] }
  };

  // --- Helpers ---
  function downloadTextFile(filename, text) {
    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
    var blob = new Blob([preface, text], { type: "image/svg+xml;charset=utf-8" });
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.style.display = 'none';
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function () { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
  }

  function getCurrentSvgMarkup() {
    var svg = document.querySelector("#svgContainer svg");
    if (!svg) return null;
    if (window.__pbnGetTargetSizeMm) {
        const size = window.__pbnGetTargetSizeMm();
        if(size && size.w && size.h) {
            svg.setAttribute('width', size.w + 'mm');
            svg.setAttribute('height', size.h + 'mm');
        }
    }
    if(!svg.getAttribute("xmlns")) svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    return svg.outerHTML;
  }

  function parseNumberAttr(el, name, fallback) {
    var v = el.getAttribute(name);
    if (v == null) return fallback;
    var n = parseFloat(v);
    return isFinite(n) ? n : fallback;
  }

  function getStrokeWidthFromUI() {
    var el = document.getElementById('txtSingleLineStrokeWidth');
    return el ? (parseFloat(el.value) || DEFAULT_STROKE_WIDTH) : DEFAULT_STROKE_WIDTH;
  }

  function strokeTextToPath(text, letterSpacing) {
    var height = 10;
    var x = 0;
    var parts = [];
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      var g = DIGITS[ch];
      if (!g) continue;
      for (var si = 0; si < g.s.length; si++) {
        var stroke = g.s[si];
        if (!stroke || stroke.length < 2) continue;
        parts.push(["M", x + stroke[0][0], stroke[0][1]]);
        for (var pi = 1; pi < stroke.length; pi++) {
          parts.push(["L", x + stroke[pi][0], stroke[pi][1]]);
        }
      }
      x += g.w + letterSpacing;
    }
    var width = Math.max(0, x - letterSpacing);
    return { segs: parts, width: width, height: height };
  }

  // --- Math ---
  function matMul(a, b) {
    return [
      a[0]*b[0] + a[2]*b[1], a[1]*b[0] + a[3]*b[1],
      a[0]*b[2] + a[2]*b[3], a[1]*b[2] + a[3]*b[3],
      a[0]*b[4] + a[2]*b[5] + a[4], a[1]*b[4] + a[3]*b[5] + a[5]
    ];
  }
  
  function matApply(m, x, y) {
    if (!m) return [x, y];
    return [m[0]*x + m[2]*y + m[4], m[1]*x + m[3]*y + m[5]];
  }

  function matTranslate(tx, ty) { return [1,0,0,1,tx,ty]; }
  function matScale(sx, sy) { return [sx,0,0,sy,0,0]; }

  function parseTransformList(t) {
    var m = [1,0,0,1,0,0];
    if (!t) return m;
    var re = /(translate|scale)\s*\(([^)]*)\)/ig;
    var match;
    while ((match = re.exec(t)) !== null) {
      var fn = match[1].toLowerCase();
      var args = match[2].trim().split(/[\s,]+/).filter(Boolean).map(parseFloat);
      if (fn === "translate") {
        m = matMul(m, matTranslate(args[0]||0, args[1]||0));
      } else if (fn === "scale") {
        m = matMul(m, matScale(args[0]||1, args[1]||args[0]||1));
      }
    }
    return m;
  }

  function cumulativeTransformMatrix(el, stopAt) {
    var mats = [];
    var cur = el;
    while (cur && cur !== stopAt && cur) {
      if (cur.getAttribute) {
        var t = cur.getAttribute('transform');
        if (t) mats.push(parseTransformList(t));
      }
      cur = cur.parentNode;
    }
    var M = [1,0,0,1,0,0];
    for (var i = mats.length - 1; i >= 0; i--) {
      M = matMul(M, mats[i]);
    }
    return M;
  }

  // --- Optimization Engine v9.4 ---

  function flattenNestedSvg(doc) {
    var root = doc.documentElement;
    var allSvgs = Array.prototype.slice.call(root.getElementsByTagName("svg"));
    if (allSvgs.length <= 1) return;

    for (var i = allSvgs.length - 1; i >= 1; i--) {
      var svg = allSvgs[i];
      if (!svg || !svg.parentNode) continue;
      if (svg === root) continue;

      var x = parseNumberAttr(svg, "x", 0);
      var y = parseNumberAttr(svg, "y", 0);
      var w = parseNumberAttr(svg, "width", 0);
      var h = parseNumberAttr(svg, "height", 0);
      var vbAttr = svg.getAttribute("viewBox");
      var vb = vbAttr ? vbAttr.trim().split(/[\s,]+/).map(parseFloat) : [];
      
      var vbMinX = (vb.length === 4) ? vb[0] : 0;
      var vbMinY = (vb.length === 4) ? vb[1] : 0;
      var vbW = (vb.length === 4) ? vb[2] : (w || 0);
      var vbH = (vb.length === 4) ? vb[3] : (h || 0);
      if (!w) w = vbW;
      if (!h) h = vbH;

      var scaleX = (vbW) ? (w / vbW) : 1;
      var scaleY = (vbH) ? (h / vbH) : 1;
      var s = Math.min(scaleX, scaleY); 
      var dx = (w - vbW * s) / 2;
      var dy = (h - vbH * s) / 2;

      var existing = (svg.getAttribute("transform") || "").trim();
      var tMap = "translate(" + x + "," + y + ") translate(" + dx + "," + dy + ") scale(" + s + ") translate(" + (-vbMinX) + "," + (-vbMinY) + ")";
      if (existing) tMap = existing + " " + tMap;

      var g = doc.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("transform", tMap);

      while (svg.firstChild) g.appendChild(svg.firstChild);
      svg.parentNode.replaceChild(g, svg);
    }
  }

  function convertTextNodesToLabelPaths(doc, strokeWidth) {
    var svgEl = doc.documentElement;
    var texts = Array.prototype.slice.call(svgEl.getElementsByTagName("text"));
    for (var ti = 0; ti < texts.length; ti++) {
      var t = texts[ti];
      var label = (t.textContent || "").trim();
      if (!label || !/^\d+$/.test(label)) continue;

      var x = parseNumberAttr(t, "x", 0);
      var y = parseNumberAttr(t, "y", 0);
      var fontSize = parseNumberAttr(t, "font-size", 12);
      
      var letterSpacing = (label.length > 1) ? 1.0 : 1.5; 
      var p = strokeTextToPath(label, letterSpacing);
      var scale = fontSize / p.height;

      var scaledW = p.width * scale;
      var xOffset = (-scaledW/2); 
      var yOffset = (-p.height * scale * 0.5);

      var dparts = [];
      for (var si = 0; si < p.segs.length; si++) {
        var seg = p.segs[si];
        var cmd = seg[0];
        var px = (seg[1] * scale) + x + xOffset;
        var py = (seg[2] * scale) + y + yOffset;
        dparts.push(cmd + " " + px.toFixed(3) + " " + py.toFixed(3));
      }

      var path = doc.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", dparts.join(" "));
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", FORCE_STROKE_COLOR);
      path.setAttribute("stroke-width", String(strokeWidth));
      path.setAttribute("data-label", "true"); 
      
      t.parentNode.replaceChild(path, t);
    }
  }

  function bakePathData(d, matrix) {
      if (!d) return null;
      var tokens = d.replace(/,/g, ' ').trim().split(/\s+/);
      var idx = 0;
      var out = [];
      // Calculate BBox for sorting
      var cx=0, cy=0; // needed for implicit relative moves if any
      var points = [];

      function applyM(x, y) { return matApply(matrix, x, y); }

      while (idx < tokens.length) {
          var cmd = tokens[idx++];
          if (cmd.toUpperCase() === 'M' || cmd.toUpperCase() === 'L') {
              var nx = parseFloat(tokens[idx++]);
              var ny = parseFloat(tokens[idx++]);
              var pt = applyM(nx, ny);
              out.push(cmd.toUpperCase() + ' ' + pt[0].toFixed(3) + ' ' + pt[1].toFixed(3));
              points.push(pt);
          } else if (cmd.toUpperCase() === 'Q') {
              var c1x = parseFloat(tokens[idx++]);
              var c1y = parseFloat(tokens[idx++]);
              var nx = parseFloat(tokens[idx++]);
              var ny = parseFloat(tokens[idx++]);
              var cp = applyM(c1x, c1y);
              var pt = applyM(nx, ny);
              out.push('Q ' + cp[0].toFixed(3) + ' ' + cp[1].toFixed(3) + ' ' + pt[0].toFixed(3) + ' ' + pt[1].toFixed(3));
              points.push(pt);
          } else if (cmd.toUpperCase() === 'Z') {
              out.push('Z');
          }
      }
      
      // Calculate Centroid of this label for TSP sorting
      var midX = 0, midY = 0;
      if (points.length > 0) {
          points.forEach(p => { midX += p[0]; midY += p[1]; });
          midX /= points.length;
          midY /= points.length;
      }

      return { d: out.join(' '), center: {x: midX, y: midY} };
  }

  function getSegmentHash(p1, p2, cp) {
     var x1 = p1[0].toFixed(2), y1 = p1[1].toFixed(2);
     var x2 = p2[0].toFixed(2), y2 = p2[1].toFixed(2);
     var s1 = x1 + ',' + y1;
     var s2 = x2 + ',' + y2;
     var sc = cp ? '|' + cp[0].toFixed(2) + ',' + cp[1].toFixed(2) : '';
     // Canonical form: smaller coord string first
     return (s1 < s2) ? (s1 + '-' + s2 + sc) : (s2 + '-' + s1 + sc);
  }

  function parseAndDecomposeBorders(d, matrix) {
      var tokens = d.replace(/,/g, ' ').trim().split(/\s+/);
      var idx = 0;
      var cx = 0, cy = 0;
      var sx = 0, sy = 0;
      var edges = [];

      function applyM(x, y) { return matApply(matrix, x, y); }

      while (idx < tokens.length) {
          var cmd = tokens[idx++];
          if (cmd.toUpperCase() === 'M') {
              var pt = applyM(parseFloat(tokens[idx++]), parseFloat(tokens[idx++]));
              cx = pt[0]; cy = pt[1];
              sx = cx; sy = cy;
          } else if (cmd.toUpperCase() === 'L') {
              var pt = applyM(parseFloat(tokens[idx++]), parseFloat(tokens[idx++]));
              edges.push({ type:'L', p1:[cx,cy], p2:[pt[0],pt[1]] });
              cx = pt[0]; cy = pt[1];
          } else if (cmd.toUpperCase() === 'Q') {
              var cp = applyM(parseFloat(tokens[idx++]), parseFloat(tokens[idx++]));
              var pt = applyM(parseFloat(tokens[idx++]), parseFloat(tokens[idx++]));
              edges.push({ type:'Q', p1:[cx,cy], p2:[pt[0],pt[1]], c:[cp[0],cp[1]] });
              cx = pt[0]; cy = pt[1];
          } else if (cmd.toUpperCase() === 'Z') {
              if (Math.abs(cx-sx)>0.01 || Math.abs(cy-sy)>0.01) {
                  edges.push({ type:'L', p1:[cx,cy], p2:[sx,sy] });
              }
              cx = sx; cy = sy;
          }
      }
      return edges;
  }

  // --- Advanced Optimizers ---

  /**
   * Stitches loose segments into long continuous chains.
   */
  function stitchEdges(edges) {
      // 1. Build Adjacency Map
      // Key: "x.xx,y.yy" -> Array of Edges attached to this point
      var adj = {};
      
      function k(pt) { return pt[0].toFixed(2) + ',' + pt[1].toFixed(2); }
      
      function addToAdj(key, edge) {
          if (!adj[key]) adj[key] = [];
          adj[key].push(edge);
      }

      edges.forEach(e => {
          e.visited = false;
          // Store original reference and direction implied by connection
          addToAdj(k(e.p1), e);
          addToAdj(k(e.p2), e);
      });

      var chains = [];

      // 2. Iterate all edges to build chains
      for (var i = 0; i < edges.length; i++) {
          var startEdge = edges[i];
          if (startEdge.visited) continue;

          // Start a new chain
          var chain = [];
          var current = startEdge;
          var headPoint = current.p1; 
          var tailPoint = current.p2;
          
          current.visited = true;
          // Ensure first segment orientation is P1->P2 in logical chain (we assume forward)
          // Store segment and a flag if it needs flipping
          chain.push({ edge: current, reverse: false });

          // Grow Tail (Forward)
          var growing = true;
          while (growing) {
              var candidates = adj[k(tailPoint)];
              var foundNext = false;
              if (candidates) {
                  for (var c = 0; c < candidates.length; c++) {
                      var cand = candidates[c];
                      if (!cand.visited) {
                          cand.visited = true;
                          
                          // Determine direction. 
                          // Does cand start or end at tailPoint?
                          var distToP1 = Math.abs(cand.p1[0] - tailPoint[0]) + Math.abs(cand.p1[1] - tailPoint[1]);
                          var isNaturalDir = (distToP1 < 0.1); 
                          
                          chain.push({ edge: cand, reverse: !isNaturalDir });
                          tailPoint = isNaturalDir ? cand.p2 : cand.p1;
                          
                          foundNext = true;
                          break; 
                      }
                  }
              }
              if (!foundNext) growing = false;
          }

          // Grow Head (Backward)
          // We look for segments connected to headPoint (original p1)
          growing = true;
          while (growing) {
              var candidates = adj[k(headPoint)];
              var foundPrev = false;
              if (candidates) {
                  for (var c = 0; c < candidates.length; c++) {
                      var cand = candidates[c];
                      if (!cand.visited) {
                          cand.visited = true;
                          
                          // We are extending BACKWARDS from headPoint.
                          // So if cand ends at headPoint (cand.p2 == headPoint), it is natural direction A->B->Head.
                          // If cand starts at headPoint, it is reverse direction Head->B->A (conceptually).
                          
                          var distToP2 = Math.abs(cand.p2[0] - headPoint[0]) + Math.abs(cand.p2[1] - headPoint[1]);
                          var isNaturalDir = (distToP2 < 0.1);

                          // Prepend
                          chain.unshift({ edge: cand, reverse: !isNaturalDir });
                          
                          // Update new Head
                          headPoint = isNaturalDir ? cand.p1 : cand.p2;
                          
                          foundPrev = true;
                          break;
                      }
                  }
              }
              if (!foundPrev) growing = false;
          }

          chains.push({
             segments: chain,
             startPt: headPoint,
             endPt: tailPoint
          });
      }
      return chains;
  }

  /**
   * Sorts chains (polylines) using Greedy Nearest Neighbor (Travel Optimization)
   */
  function sortChains(chains) {
      if (chains.length === 0) return [];
      
      var sorted = [];
      var currentPos = [0, 0]; // Laser starts at origin
      var unvisited = new Set(chains);
      
      // Safety brake for huge files
      var count = 0;
      var limit = chains.length + 1;

      while (unvisited.size > 0 && count < limit) {
          count++;
          
          var nearest = null;
          var minDist = Infinity;
          var reversed = false;
          
          // Find closest start or end of any remaining chain
          // (Since we are in browser JS, naive O(N) scan per step is slow for 50k items.
          // BUT: 50k edges usually reduce to < 2k chains. O(N^2) for N=2000 is 4M ops, which is fine (~50ms).)
          
          for (var chain of unvisited) {
              // Dist to Start
              var dStart = Math.abs(chain.startPt[0] - currentPos[0]) + Math.abs(chain.startPt[1] - currentPos[1]);
              
              if (dStart < minDist) {
                  minDist = dStart;
                  nearest = chain;
                  reversed = false; // We play it start->end
              }
              
              // Optimization: Also check end point? If we play it reversed?
              // Yes, LaserGRBL supports this better if paths are contiguous.
              var dEnd = Math.abs(chain.endPt[0] - currentPos[0]) + Math.abs(chain.endPt[1] - currentPos[1]);
              if (dEnd < minDist) {
                  minDist = dEnd;
                  nearest = chain;
                  reversed = true; // We play it end->start
              }
          }
          
          if (nearest) {
              unvisited.delete(nearest);
              // Store reversal decision in the chain object for the renderer
              nearest.renderReverse = reversed; 
              
              sorted.push(nearest);
              currentPos = reversed ? nearest.startPt : nearest.endPt;
          } else {
              break; 
          }
      }
      return sorted;
  }
  
  function sortLabels(labels) {
      // Same logic for labels (Point-based TSP)
      if (labels.length === 0) return [];
      
      var sorted = [];
      var currentPos = [0, 0];
      var unvisited = new Set(labels);
      
      var count = 0;
      while (unvisited.size > 0 && count++ < labels.length + 1) {
          var nearest = null;
          var minDist = Infinity;
          
          for (var l of unvisited) {
              var d = Math.abs(l.center.x - currentPos[0]) + Math.abs(l.center.y - currentPos[1]);
              if (d < minDist) {
                  minDist = d;
                  nearest = l;
              }
          }
          
          if(nearest) {
              unvisited.delete(nearest);
              sorted.push(nearest);
              currentPos = [nearest.center.x, nearest.center.y];
          } else break;
      }
      return sorted;
  }

  function optimizeGeometry(svgString) {
      console.log("Parsing SVG...");
      var parser = new DOMParser();
      var doc = parser.parseFromString(svgString, 'image/svg+xml');
      
      flattenNestedSvg(doc);
      convertTextNodesToLabelPaths(doc, getStrokeWidthFromUI());
      
      var labels = [];
      var borderEdges = [];
      var uniqueEdgeHashes = new Set();
      var dedupCount = 0;

      var elements = Array.from(doc.querySelectorAll('path, rect, circle, polygon, polyline'));

      elements.forEach(function(el) {
          var isLabel = el.getAttribute('data-label') === 'true';
          
          var hasFill = (el.getAttribute('fill') && el.getAttribute('fill') !== 'none');
          var hasStroke = (el.getAttribute('stroke') && el.getAttribute('stroke') !== 'none');
          
          var M = cumulativeTransformMatrix(el, doc.documentElement);
          var d = el.getAttribute('d');
          
          if (el.tagName === 'rect' && !d) {
             var x=parseFloat(el.getAttribute('x')||0), y=parseFloat(el.getAttribute('y')||0), w=parseFloat(el.getAttribute('width')||0), h=parseFloat(el.getAttribute('height')||0);
             d = `M ${x} ${y} L ${x+w} ${y} L ${x+w} ${y+h} L ${x} ${y+h} Z`;
          }

          if (!d) return;

          if (isLabel) {
             var baked = bakePathData(d, M);
             if (baked) labels.push(baked);
          } 
          else if (hasFill || hasStroke) {
             var segs = parseAndDecomposeBorders(d, M);
             segs.forEach(function(s) {
                 var h = getSegmentHash(s.p1, s.p2, s.c);
                 if (!uniqueEdgeHashes.has(h)) {
                     uniqueEdgeHashes.add(h);
                     borderEdges.push(s);
                 } else {
                     dedupCount++;
                 }
             });
          }
      });
      
      console.log("Edges: " + borderEdges.length + " (Removed duplicates: " + dedupCount + ")");
      
      // Stitch
      console.log("Stitching chains...");
      var rawChains = stitchEdges(borderEdges);
      console.log("Created " + rawChains.length + " continuous paths.");
      
      // Sort Borders
      console.log("Optimizing Border Travel (TSP)...");
      var sortedChains = sortChains(rawChains);
      
      // Sort Labels
      console.log("Optimizing Label Travel (TSP)...");
      var sortedLabels = sortLabels(labels);

      // Reconstruct
      console.log("Generating Output...");
      var newSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      var root = doc.documentElement;
      
      var rootW = root.getAttribute("width") || "100%";
      var rootH = root.getAttribute("height") || "100%";
      var rootVB = root.getAttribute("viewBox");
      
      if(!rootVB || rootVB === 'null') {
          var vW = parseFloat(rootW) || 1000;
          var vH = parseFloat(rootH) || 1000;
          rootVB = `0 0 ${vW} ${vH}`;
      }

      newSvg.setAttribute("width", rootW);
      newSvg.setAttribute("height", rootH);
      newSvg.setAttribute("viewBox", rootVB);
      newSvg.setAttribute("xmlns", "http://www.w3.org/2000/svg");

      var gBorders = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gBorders.setAttribute("id", "laser-borders");
      gBorders.setAttribute("stroke", FORCE_STROKE_COLOR);
      gBorders.setAttribute("fill", "none");
      gBorders.setAttribute("stroke-width", "0.2");
      
      // Convert sorted chains to path data
      // Use Chunking for Safety
      var currentD = "";
      var counter = 0;
      var flushLimit = BATCH_SIZE;
      
      function flush(group, dVal) {
          if (!dVal) return;
          var p = document.createElementNS("http://www.w3.org/2000/svg", "path");
          p.setAttribute("d", dVal);
          group.appendChild(p);
      }
      
      sortedChains.forEach(chain => {
          // chain.segments is array of {edge, reverse}
          // if chain.renderReverse is true, we iterate backwards and flip reverse flags
          
          var segsToRender = chain.segments;
          if (chain.renderReverse) {
              segsToRender = [];
              for(var i = chain.segments.length-1; i>=0; i--) {
                  var item = chain.segments[i];
                  segsToRender.push({ edge: item.edge, reverse: !item.reverse });
              }
          }
          
          // Render this continuous line
          // Determine Start point of first segment
          var start = segsToRender[0].reverse ? segsToRender[0].edge.p2 : segsToRender[0].edge.p1;
          
          currentD += `M ${start[0].toFixed(3)} ${start[1].toFixed(3)} `;
          
          segsToRender.forEach(item => {
              var s = item.edge;
              var target = item.reverse ? s.p1 : s.p2; // if reversed, target is p1
              
              if(s.type === 'L') {
                   currentD += `L ${target[0].toFixed(3)} ${target[1].toFixed(3)} `;
              } else {
                   // Quad control point is absolute, doesn't change
                   currentD += `Q ${s.c[0].toFixed(3)} ${s.c[1].toFixed(3)} ${target[0].toFixed(3)} ${target[1].toFixed(3)} `;
              }
          });
          
          if (++counter >= flushLimit) {
              flush(gBorders, currentD);
              currentD = "";
              counter = 0;
          }
      });
      flush(gBorders, currentD);
      newSvg.appendChild(gBorders);

      var gLabels = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gLabels.setAttribute("id", "laser-labels");
      gLabels.setAttribute("stroke", FORCE_STROKE_COLOR);
      gLabels.setAttribute("fill", "none");
      gLabels.setAttribute("stroke-width", String(getStrokeWidthFromUI()));
      
      currentD = "";
      counter = 0;
      
      sortedLabels.forEach(lp => {
          currentD += lp.d + " ";
          if (++counter >= flushLimit) {
              flush(gLabels, currentD);
              currentD = "";
              counter = 0;
          }
      });
      flush(gLabels, currentD);
      newSvg.appendChild(gLabels);
      
      console.log("Done.");
      return new XMLSerializer().serializeToString(newSvg);
  }


  // --- UI Injection ---
  function ensureButtons() {
    var oldBtn = document.getElementById('btnDownloadSVG');
    if (!oldBtn) return;
    if (oldBtn.getAttribute('data-pbn-patched') === 'true') return;

    var newPreviewBtn = oldBtn.cloneNode(true);
    oldBtn.parentNode.replaceChild(newPreviewBtn, oldBtn);
    
    newPreviewBtn.id = 'btnDownloadSVG'; 
    newPreviewBtn.textContent = 'Download SVG (Preview)';
    newPreviewBtn.setAttribute('data-pbn-patched', 'true');

    newPreviewBtn.addEventListener('click', function(ev) {
        ev.preventDefault();
        try {
            var svg = getCurrentSvgMarkup();
            if (svg) downloadTextFile('preview.svg', svg);
        } catch(e) { console.error(e); }
    });

    var laserBtnId = 'btnDownloadSVGLaser';
    var oldLaserBtn = document.getElementById(laserBtnId);
    if (oldLaserBtn) oldLaserBtn.parentNode.removeChild(oldLaserBtn); 

    var laserBtn = document.createElement('a');
    laserBtn.id = laserBtnId;
    laserBtn.className = newPreviewBtn.className;
    laserBtn.style.marginLeft = '8px';
    laserBtn.textContent = 'Download Laser SVG (Optimized)';
    
    newPreviewBtn.parentNode.insertBefore(laserBtn, newPreviewBtn.nextSibling);

    laserBtn.addEventListener('click', function (ev) {
      ev.preventDefault();
      try {
        var svg = getCurrentSvgMarkup();
        if (!svg) { alert("No image available."); return; }
        
        // Timeout to let UI breathe
        laserBtn.textContent = "Optimizing...";
        setTimeout(function() {
            var laserSvg = optimizeGeometry(svg);
            downloadTextFile('laser_optimized.svg', laserSvg);
            laserBtn.textContent = 'Download Laser SVG (Optimized)';
        }, 50);
        
      } catch(e) {
          console.error(e);
          alert("Error: " + e.message);
      }
    });
  }

  function ensureStrokeWidthInput() {
    if (document.getElementById('txtSingleLineStrokeWidth')) return;
    var anchor = document.getElementById('btnDownloadSVGLaser');
    if (!anchor) return;

    var wrapper = document.createElement('span');
    wrapper.style.marginLeft = '12px';
    wrapper.style.display = 'inline-flex';
    wrapper.style.alignItems = 'center';
    wrapper.style.gap = '6px';
    wrapper.innerHTML = `<span style="font-size:12px;">Label Stroke:</span>`;
    
    var input = document.createElement('input');
    input.id = 'txtSingleLineStrokeWidth';
    input.type = 'number';
    input.min = '0.1';
    input.step = '0.05';
    input.value = String(DEFAULT_STROKE_WIDTH);
    input.style.width = '60px';
    input.style.height = '30px';
    input.style.margin = '0';
    wrapper.appendChild(input);
    anchor.parentNode.insertBefore(wrapper, anchor.nextSibling);
  }

  // --- INIT ---
  var _initDone = false;
  function init() {
     if(_initDone) return;
     setTimeout(function(){
         ensureButtons();
         ensureStrokeWidthInput();
         _initDone = true;
     }, 1000);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  
  var obs = new MutationObserver(function(mutations) {
      var needsRebind = false;
      for(var i=0; i<mutations.length; i++) {
          if(mutations[i].target.id === 'output-pane' || mutations[i].target.id === 'options-pane') {
              needsRebind = true;
              break;
          }
      }
      if(needsRebind) {
          setTimeout(function() {
             ensureButtons();
             ensureStrokeWidthInput();
          }, 200);
      }
  });
  
  setTimeout(function() {
      var target = document.getElementById('options-pane') || document.body;
      obs.observe(target, { childList: true, subtree: true });
  }, 1500);

})();
--- END FILE: .\laser-export.js ---


--- START FILE: .\LICENSE ---
MIT License

Copyright (c) 2018 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--- END FILE: .\LICENSE ---


--- START FILE: .\package-lock.json ---
{
  "name": "paint-by-numbers-generator",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@socket.io/component-emitter": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@socket.io/component-emitter/-/component-emitter-3.1.2.tgz",
      "integrity": "sha512-9BCxFwvbGg/RsZK9tjXd8s4UcwR0MWeFQ1XEKIQVVvAGJyINdrqKMcTRyLoK8Rse1GjzLV9cwjWV1olXRWEXVA==",
      "dev": true
    },
    "@types/cors": {
      "version": "2.8.19",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.19.tgz",
      "integrity": "sha512-mFNylyeyqN93lfe/9CSxOGREz8cpzAhH+E93xJ4xWQf62V8sQ/24reV2nyzUWM6H6Xji+GGHpkbLe7pVoUEskg==",
      "dev": true,
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/jquery": {
      "version": "3.5.33",
      "resolved": "https://registry.npmjs.org/@types/jquery/-/jquery-3.5.33.tgz",
      "integrity": "sha512-SeyVJXlCZpEki5F0ghuYe+L+PprQta6nRZqhONt9F13dWBtR/ftoaIbdRQ7cis7womE+X2LKhsDdDtkkDhJS6g==",
      "requires": {
        "@types/sizzle": "*"
      }
    },
    "@types/materialize-css": {
      "version": "1.0.14",
      "resolved": "https://registry.npmjs.org/@types/materialize-css/-/materialize-css-1.0.14.tgz",
      "integrity": "sha512-Jt8ReN/R7zrz1TBby0KvyJzAIB9353c1jaFjZt8fIaY/xsalED/8OsFuog1PJ79OuXleRWyJ+MZ8dmjbArXepg==",
      "requires": {
        "@types/jquery": "*",
        "cash-dom": "*"
      }
    },
    "@types/minimist": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/@types/minimist/-/minimist-1.2.5.tgz",
      "integrity": "sha512-hov8bUuiLiyFPGyFPE1lwWhmzYbirOXQNNo40+y3zow8aFVTeyn3VWL0VFFfdNddA8S4Vf0Tc062rzyNr7Paag=="
    },
    "@types/node": {
      "version": "12.20.55",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-12.20.55.tgz",
      "integrity": "sha512-J8xLz7q2OFulZ2cyGTLE1TbbZcjpno7FaN6zdJNrgAdrJ+DZzh/uFR6YrTb4C+nXakvud8Q4+rbhoIWlYQbUFQ==",
      "dev": true
    },
    "@types/sizzle": {
      "version": "2.3.10",
      "resolved": "https://registry.npmjs.org/@types/sizzle/-/sizzle-2.3.10.tgz",
      "integrity": "sha512-TC0dmN0K8YcWEAEfiPi5gJP14eJe30TTGjkvek3iM/1NdHHsdCA/Td6GvNndMOo/iSnIsZ4HuuhrYPDAmbxzww=="
    },
    "abab": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/abab/-/abab-1.0.4.tgz",
      "integrity": "sha512-I+Wi+qiE2kUXyrRhNsWv6XsjUTBJjSoVSctKNBfLG5zG/Xe7Rjbxf13+vqYHNTwHaFU+FtSlVxOCTiMEVtPv0A=="
    },
    "abbrev": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q=="
    },
    "accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "dev": true,
      "requires": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      }
    },
    "acorn": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-2.7.0.tgz",
      "integrity": "sha512-pXK8ez/pVjqFdAgBkF1YPVRacuLQ9EXBKaKWaeh58WNfMkCmZhOZzu+NtKSPD5PHmCCHheQ5cD29qM1K4QTxIg=="
    },
    "acorn-globals": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/acorn-globals/-/acorn-globals-1.0.9.tgz",
      "integrity": "sha512-j3/4pkfih8W4NK22gxVSXcEonTpAHOHh0hu5BoZrKcOsW/4oBPxTi4Yk3SAj+FhC1f3+bRTkXdm4019gw1vg9g==",
      "requires": {
        "acorn": "^2.1.0"
      }
    },
    "ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "requires": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      }
    },
    "ansi-regex": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
      "integrity": "sha512-TIGnTpdo+E3+pCyAluZvtED5p5wCqLdezCyhPZzKPcxvFplEt4i+W7OONCKgeZFT3+y5NZZfOOS/Bdcanm1MYA=="
    },
    "ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "requires": {
        "color-convert": "^2.0.1"
      }
    },
    "anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "requires": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      }
    },
    "aproba": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/aproba/-/aproba-1.2.0.tgz",
      "integrity": "sha512-Y9J6ZjXtoYh8RnXVCMOU/ttDmk1aBjunq9vO0ta5x85WDQiQfUF9sIPBITdbiiIVcBo03Hi3jMxigBtsddlXRw=="
    },
    "are-we-there-yet": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-1.1.7.tgz",
      "integrity": "sha512-nxwy40TuMiUGqMyRHgCSWZ9FM4VAoRP4xUYSTv5ImRog+h9yISPbVH7H8fASCIzYn9wlEv4zvFL7uKDMCFQm3g==",
      "requires": {
        "delegates": "^1.0.0",
        "readable-stream": "^2.0.6"
      }
    },
    "array-equal": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/array-equal/-/array-equal-1.0.2.tgz",
      "integrity": "sha512-gUHx76KtnhEgB3HOuFYiCm3FIdEs6ocM2asHvNTkfu/Y09qQVrrVVaOKENmS2KkSaGoxgXNqC+ZVtR/n0MOkSA=="
    },
    "asn1": {
      "version": "0.2.6",
      "resolved": "https://registry.npmjs.org/asn1/-/asn1-0.2.6.tgz",
      "integrity": "sha512-ix/FxPn0MDjeyJ7i/yoHGFt/EX6LyNbxSEhPPXODPL+KB0VPk86UYfL0lMdy+KCnv+fmvIzySwaK5COwqVbWTQ==",
      "requires": {
        "safer-buffer": "~2.1.0"
      }
    },
    "assert-plus": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/assert-plus/-/assert-plus-1.0.0.tgz",
      "integrity": "sha512-NfJ4UzBCcQGLDlQq7nHxH+tv3kyZ0hHQqF5BO6J7tNJeP5do1llPr8dZ8zHonfhAu0PHAdMkSo+8o0wxg9lZWw=="
    },
    "async": {
      "version": "2.6.4",
      "resolved": "https://registry.npmjs.org/async/-/async-2.6.4.tgz",
      "integrity": "sha512-mzo5dfJYwAn29PeiJ0zvwTo04zj8HDJj0Mn8TD7sno7q12prdbnasKJHhkm2c1LgrhlJ0teaea8860oxi51mGA==",
      "dev": true,
      "requires": {
        "lodash": "^4.17.14"
      }
    },
    "async-each-series": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/async-each-series/-/async-each-series-0.1.1.tgz",
      "integrity": "sha512-p4jj6Fws4Iy2m0iCmI2am2ZNZCgbdgE+P8F/8csmn2vx7ixXrO2zGcuNsD46X5uZSVecmkEy/M06X2vG8KD6dQ==",
      "dev": true
    },
    "asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "atob": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/atob/-/atob-2.1.2.tgz",
      "integrity": "sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg=="
    },
    "aws-sign2": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/aws-sign2/-/aws-sign2-0.7.0.tgz",
      "integrity": "sha512-08kcGqnYf/YmjoRhfxyu+CLxBjUtHLXLXX/vUfx9l2LYzG3c1m61nrpyFUZI6zeS+Li/wWMMidD9KgrqtGq3mA=="
    },
    "aws4": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/aws4/-/aws4-1.13.2.tgz",
      "integrity": "sha512-lHe62zvbTB5eEABUVi/AwVh0ZKY9rMMDhmm+eeyuuUQbQ3+J+fONVQOZyj+DdrvD4BY33uYniyRJ4UJIaSKAfw=="
    },
    "axios": {
      "version": "0.21.4",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.21.4.tgz",
      "integrity": "sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==",
      "dev": true,
      "requires": {
        "follow-redirects": "^1.14.0"
      }
    },
    "balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw=="
    },
    "base64id": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/base64id/-/base64id-2.0.0.tgz",
      "integrity": "sha512-lGe34o6EHj9y3Kts9R4ZYs/Gr+6N7MCaMlIFA3F1R2O5/m7K06AxfSeO5530PEERE6/WyEg3lsuyw4GHlPZHog==",
      "dev": true
    },
    "batch": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/batch/-/batch-0.6.1.tgz",
      "integrity": "sha512-x+VAiMRL6UPkx+kudNvxTl6hB2XNNCG2r+7wixVfIYwu/2HKRXimwQyaumLjMveWvT2Hkd/cAJw+QBMfJ/EKVw==",
      "dev": true
    },
    "bcrypt-pbkdf": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.2.tgz",
      "integrity": "sha512-qeFIXtP4MSoi6NLqO12WfqARWWuCKi2Rn/9hJLEmtB5yTNr9DqFWkJRCf2qShWzPeAMRnOgCrq0sg/KLv5ES9w==",
      "requires": {
        "tweetnacl": "^0.14.3"
      }
    },
    "binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true
    },
    "brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "requires": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "requires": {
        "fill-range": "^7.1.1"
      }
    },
    "browser-sync-client": {
      "version": "2.29.3",
      "resolved": "https://registry.npmjs.org/browser-sync-client/-/browser-sync-client-2.29.3.tgz",
      "integrity": "sha512-4tK5JKCl7v/3aLbmCBMzpufiYLsB1+UI+7tUXCCp5qF0AllHy/jAqYu6k7hUF3hYtlClKpxExWaR+rH+ny07wQ==",
      "dev": true,
      "requires": {
        "etag": "1.8.1",
        "fresh": "0.5.2",
        "mitt": "^1.1.3"
      }
    },
    "browser-sync-ui": {
      "version": "2.29.3",
      "resolved": "https://registry.npmjs.org/browser-sync-ui/-/browser-sync-ui-2.29.3.tgz",
      "integrity": "sha512-kBYOIQjU/D/3kYtUIJtj82e797Egk1FB2broqItkr3i4eF1qiHbFCG6srksu9gWhfmuM/TNG76jMfzAdxEPakg==",
      "dev": true,
      "requires": {
        "async-each-series": "0.1.1",
        "chalk": "4.1.2",
        "connect-history-api-fallback": "^1",
        "immutable": "^3",
        "server-destroy": "1.0.1",
        "socket.io-client": "^4.4.1",
        "stream-throttle": "^0.1.3"
      }
    },
    "bs-recipes": {
      "version": "1.3.4",
      "resolved": "https://registry.npmjs.org/bs-recipes/-/bs-recipes-1.3.4.tgz",
      "integrity": "sha512-BXvDkqhDNxXEjeGM8LFkSbR+jzmP/CYpCiVKYn+soB1dDldeU15EBNDkwVXndKuX35wnNUaPd0qSoQEAkmQtMw==",
      "dev": true
    },
    "btoa": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/btoa/-/btoa-1.2.1.tgz",
      "integrity": "sha512-SB4/MIGlsiVkMcHmT+pSmIPoNDoHg+7cMzmt3Uxt628MTz2487DKSqK/fuhFBrkuqrYv5UCEnACpF4dTFNKc/g=="
    },
    "bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "dev": true
    },
    "camelcase": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-2.1.1.tgz",
      "integrity": "sha512-DLIsRzJVBQu72meAKPkWQOLcujdXT32hwdfnkI1frSiSRMK1MofjKHf+MEx0SB6fjEFXL8fBDv1dKymBlOp4Qw==",
      "dev": true
    },
    "canvas": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/canvas/-/canvas-2.5.0.tgz",
      "integrity": "sha512-wwRz2cLMgb9d+rnotOJCoc04Bzj3aJMpWc6JxAD6lP7bYz0ldcn0sKddoZ0vhD5T8HBxrK+XmRDJb68/2VqARw==",
      "requires": {
        "nan": "^2.13.2",
        "node-pre-gyp": "^0.11.0",
        "simple-get": "^3.0.3"
      }
    },
    "canvg": {
      "version": "1.5.3",
      "resolved": "https://registry.npmjs.org/canvg/-/canvg-1.5.3.tgz",
      "integrity": "sha512-7Gn2IuQzvUQWPIuZuFHrzsTM0gkPz2RRT9OcbdmA03jeKk8kltrD8gqUzNX15ghY/4PV5bbe5lmD6yDLDY6Ybg==",
      "requires": {
        "jsdom": "^8.1.0",
        "rgbcolor": "^1.0.1",
        "stackblur-canvas": "^1.4.1",
        "xmldom": "^0.1.22"
      }
    },
    "caseless": {
      "version": "0.12.0",
      "resolved": "https://registry.npmjs.org/caseless/-/caseless-0.12.0.tgz",
      "integrity": "sha512-4tYFyifaFfGacoiObjJegolkwSU4xQNGbVgUiNYVUxbQ2x2lUsFvY4hVgVzGiIe6WLOPqycWXA40l+PWsxthUw=="
    },
    "cash-dom": {
      "version": "8.1.5",
      "resolved": "https://registry.npmjs.org/cash-dom/-/cash-dom-8.1.5.tgz",
      "integrity": "sha512-/BS05CfzyHR5xT2ksKj1sDLPaOv5rSmIwoGxNgdKwUtnIuiJ5neMxVEmZxvfyJiSjGbOMD0Lwe+9v+fszDqHew=="
    },
    "chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      }
    },
    "chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "requires": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "fsevents": "~2.3.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      }
    },
    "chownr": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-1.1.4.tgz",
      "integrity": "sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg=="
    },
    "cliui": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
      "integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
      "dev": true,
      "requires": {
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.0",
        "wrap-ansi": "^7.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
          "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.3",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
          "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.1"
          }
        },
        "strip-ansi": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
          "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.1"
          }
        }
      }
    },
    "code-point-at": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz",
      "integrity": "sha512-RpAVKQA5T63xEj6/giIbUEtZwJ4UFIc3ZtvEkiaUERylqe8xb5IvqcgOurZLahv93CLKfxcw5YI+DZcUBRyLXA=="
    },
    "color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "requires": {
        "color-name": "~1.1.4"
      }
    },
    "color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true
    },
    "combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "requires": {
        "delayed-stream": "~1.0.0"
      }
    },
    "commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "dev": true
    },
    "concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg=="
    },
    "connect": {
      "version": "3.6.6",
      "resolved": "https://registry.npmjs.org/connect/-/connect-3.6.6.tgz",
      "integrity": "sha512-OO7axMmPpu/2XuX1+2Yrg0ddju31B6xLZMWkJ5rYBu4YRmRVlOjvlY6kw2FJKiAzyxGwnrDUAG4s1Pf0sbBMCQ==",
      "dev": true,
      "requires": {
        "debug": "2.6.9",
        "finalhandler": "1.1.0",
        "parseurl": "~1.3.2",
        "utils-merge": "1.0.1"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
          "dev": true
        }
      }
    },
    "connect-history-api-fallback": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/connect-history-api-fallback/-/connect-history-api-fallback-1.6.0.tgz",
      "integrity": "sha512-e54B99q/OUoH64zYYRf3HBP5z24G38h5D3qXu23JGRoigpX5Ss4r9ZnDk3g0Z8uQC2x2lPaJ+UlWBc1ZWBWdLg==",
      "dev": true
    },
    "connect-logger": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/connect-logger/-/connect-logger-0.0.1.tgz",
      "integrity": "sha512-kC5FPWpcfgpW5HtICnXbdOAFa4uNilU4ZPmsH6RlXaDVfXLupyUjgI1otpj3kOcsoPpDxknxmcoM0wk0ApsjYQ==",
      "dev": true,
      "requires": {
        "moment": "*"
      }
    },
    "console-control-strings": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/console-control-strings/-/console-control-strings-1.1.0.tgz",
      "integrity": "sha512-ty/fTekppD2fIwRvnZAVdeOiGd1c7YXEixbgJTNzqcxJWKQnjJ/V1bNEEE6hygpM3WjwHFUVK6HTjWSzV4a8sQ=="
    },
    "cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "dev": true
    },
    "core-util-is": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ=="
    },
    "cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "dev": true,
      "requires": {
        "object-assign": "^4",
        "vary": "^1"
      }
    },
    "cssom": {
      "version": "0.3.8",
      "resolved": "https://registry.npmjs.org/cssom/-/cssom-0.3.8.tgz",
      "integrity": "sha512-b0tGHbfegbhPJpxpiBPU2sCkigAqtM9O121le6bbOlgyV+NyGyCmVfJ6QW9eRjz8CpNfWEOYBIMIGRYkLwsIYg=="
    },
    "cssstyle": {
      "version": "0.2.37",
      "resolved": "https://registry.npmjs.org/cssstyle/-/cssstyle-0.2.37.tgz",
      "integrity": "sha512-FUpKc+1FNBsHUr9IsfSGCovr8VuGOiiuzlgCyppKBjJi2jYTOFLN3oiiNRMIvYqbFzF38mqKj4BgcevzU5/kIA==",
      "requires": {
        "cssom": "0.3.x"
      }
    },
    "dashdash": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/dashdash/-/dashdash-1.14.1.tgz",
      "integrity": "sha512-jRFi8UDGo6j+odZiEpjazZaWqEal3w/basFjQHQEwVtZJGDpxbH1MeYluwCS8Xq5wmLJooDlMgvVarmWfGM44g==",
      "requires": {
        "assert-plus": "^1.0.0"
      }
    },
    "debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "requires": {
        "ms": "^2.1.1"
      }
    },
    "decamelize": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz",
      "integrity": "sha512-z2S+W9X73hAUUki+N+9Za2lBlun89zigOyGrsax+KUQ6wKW4ZoWpEYBkGhQjwAjjDCkWxhY0VKEhk8wzY7F5cA==",
      "dev": true
    },
    "decompress-response": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/decompress-response/-/decompress-response-4.2.1.tgz",
      "integrity": "sha512-jOSne2qbyE+/r8G1VU+G/82LBs2Fs4LAsTiLSHOCOMZQl2OKZ6i8i4IyHemTe+/yIXOtTcRQMzPcgyhoFlqPkw==",
      "requires": {
        "mimic-response": "^2.0.0"
      }
    },
    "deep-extend": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/deep-extend/-/deep-extend-0.6.0.tgz",
      "integrity": "sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA=="
    },
    "deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ=="
    },
    "delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ=="
    },
    "delegates": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delegates/-/delegates-1.0.0.tgz",
      "integrity": "sha512-bd2L678uiWATM6m5Z1VzNCErI3jiGzt6HGY8OVICs40JQq/HALfbyNJmp0UDakEY4pMMaN0Ly5om/B1VI/+xfQ=="
    },
    "depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "dev": true
    },
    "destroy": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.0.4.tgz",
      "integrity": "sha512-3NdhDuEXnfun/z7x9GOElY49LoqVHoGScmOKwmxhsS8N5Y+Z8KyPPDnaSzqWgYt/ji4mqwfTS34Htrk0zPIXVg==",
      "dev": true
    },
    "detect-libc": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-1.0.3.tgz",
      "integrity": "sha512-pGjwhsmsp4kL2RTz08wcOlGN83otlqHeD/Z5T8GXZB+/YcpQ/dgo+lbU8ZsGxV0HIvqqxo9l7mqYwyYMD9bKDg=="
    },
    "dev-ip": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dev-ip/-/dev-ip-1.0.1.tgz",
      "integrity": "sha512-LmVkry/oDShEgSZPNgqCIp2/TlqtExeGmymru3uCELnfyjY11IzpAproLYs+1X88fXO6DBoYP3ul2Xo2yz2j6A==",
      "dev": true
    },
    "easy-extender": {
      "version": "2.3.4",
      "resolved": "https://registry.npmjs.org/easy-extender/-/easy-extender-2.3.4.tgz",
      "integrity": "sha512-8cAwm6md1YTiPpOvDULYJL4ZS6WfM5/cTeVVh4JsvyYZAoqlRVUpHL9Gr5Fy7HA6xcSZicUia3DeAgO3Us8E+Q==",
      "dev": true,
      "requires": {
        "lodash": "^4.17.10"
      }
    },
    "eazy-logger": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/eazy-logger/-/eazy-logger-4.1.0.tgz",
      "integrity": "sha512-+mn7lRm+Zf1UT/YaH8WXtpU6PIV2iOjzP6jgKoiaq/VNrjYKp+OHZGe2znaLgDeFkw8cL9ffuaUm+nNnzcYyGw==",
      "dev": true,
      "requires": {
        "chalk": "4.1.2"
      }
    },
    "ecc-jsbn": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
      "integrity": "sha512-eh9O+hwRHNbG4BLTjEl3nw044CkGm5X6LoaCf7LPp7UU8Qrt47JYNi6nPX8xjW97TKGKm1ouctg0QSpZe9qrnw==",
      "requires": {
        "jsbn": "~0.1.0",
        "safer-buffer": "^2.1.0"
      }
    },
    "ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "dev": true
    },
    "emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true
    },
    "encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "dev": true
    },
    "engine.io": {
      "version": "6.6.5",
      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.6.5.tgz",
      "integrity": "sha512-2RZdgEbXmp5+dVbRm0P7HQUImZpICccJy7rN7Tv+SFa55pH+lxnuw6/K1ZxxBfHoYpSkHLAO92oa8O4SwFXA2A==",
      "dev": true,
      "requires": {
        "@types/cors": "^2.8.12",
        "@types/node": ">=10.0.0",
        "accepts": "~1.3.4",
        "base64id": "2.0.0",
        "cookie": "~0.7.2",
        "cors": "~2.8.5",
        "debug": "~4.4.1",
        "engine.io-parser": "~5.2.1",
        "ws": "~8.18.3"
      },
      "dependencies": {
        "debug": {
          "version": "4.4.3",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
          "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
          "dev": true,
          "requires": {
            "ms": "^2.1.3"
          }
        }
      }
    },
    "engine.io-client": {
      "version": "6.6.4",
      "resolved": "https://registry.npmjs.org/engine.io-client/-/engine.io-client-6.6.4.tgz",
      "integrity": "sha512-+kjUJnZGwzewFDw951CDWcwj35vMNf2fcj7xQWOctq1F2i1jkDdVvdFG9kM/BEChymCH36KgjnW0NsL58JYRxw==",
      "dev": true,
      "requires": {
        "@socket.io/component-emitter": "~3.1.0",
        "debug": "~4.4.1",
        "engine.io-parser": "~5.2.1",
        "ws": "~8.18.3",
        "xmlhttprequest-ssl": "~2.1.1"
      },
      "dependencies": {
        "debug": {
          "version": "4.4.3",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
          "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
          "dev": true,
          "requires": {
            "ms": "^2.1.3"
          }
        }
      }
    },
    "engine.io-parser": {
      "version": "5.2.3",
      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.2.3.tgz",
      "integrity": "sha512-HqD3yTBfnBxIrbnM1DoD6Pcq8NECnh8d4As1Qgh0z5Gg3jRRIqijury0CL3ghu/edArpUYiYqQiDUQBIs4np3Q==",
      "dev": true
    },
    "escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true
    },
    "escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "dev": true
    },
    "escodegen": {
      "version": "1.14.3",
      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.14.3.tgz",
      "integrity": "sha512-qFcX0XJkdg+PB3xjZZG/wKSuT1PnQWx57+TVSjIMmILd2yC/6ByYElPwJnslDsuWuSAp4AwJGumarAAmJch5Kw==",
      "requires": {
        "esprima": "^4.0.1",
        "estraverse": "^4.2.0",
        "esutils": "^2.0.2",
        "optionator": "^0.8.1",
        "source-map": "~0.6.1"
      }
    },
    "esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A=="
    },
    "estraverse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw=="
    },
    "esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g=="
    },
    "etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "dev": true
    },
    "eventemitter3": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==",
      "dev": true
    },
    "extend": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g=="
    },
    "extsprintf": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/extsprintf/-/extsprintf-1.3.0.tgz",
      "integrity": "sha512-11Ndz7Nv+mvAC1j0ktTa7fAb0vLyGGX+rMHNBYQviQDGU0Hw7lhctJANqbPhu9nV9/izT/IntTgZ7Im/9LJs9g=="
    },
    "fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q=="
    },
    "fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw=="
    },
    "fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw=="
    },
    "fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "requires": {
        "to-regex-range": "^5.0.1"
      }
    },
    "finalhandler": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.0.tgz",
      "integrity": "sha512-ejnvM9ZXYzp6PUPUyQBMBf0Co5VX2gr5H2VQe2Ui2jWXNlxv+PYZo8wpAymJNJdLsG1R4p+M4aynF8KuoUEwRw==",
      "dev": true,
      "requires": {
        "debug": "2.6.9",
        "encodeurl": "~1.0.1",
        "escape-html": "~1.0.3",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.2",
        "statuses": "~1.3.1",
        "unpipe": "~1.0.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
          "dev": true
        }
      }
    },
    "follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "dev": true
    },
    "forever-agent": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/forever-agent/-/forever-agent-0.6.1.tgz",
      "integrity": "sha512-j0KLYPhm6zeac4lz3oJ3o65qvgQCcPubiyotZrXqEaG4hNagNYO8qdlUrX5vwqv9ohqeT/Z3j6+yW067yWWdUw=="
    },
    "form-data": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-2.3.3.tgz",
      "integrity": "sha512-1lLKB2Mu3aGP1Q/2eCOx0fNbRMe7XdwktwOruhfqqd0rIJWwN4Dh+E3hrPSlDCXnSR7UtZ1N38rVXm+6+MEhJQ==",
      "requires": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.6",
        "mime-types": "^2.1.12"
      }
    },
    "fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "dev": true
    },
    "fs-extra": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-3.0.1.tgz",
      "integrity": "sha512-V3Z3WZWVUYd8hoCL5xfXJCaHWYzmtwW5XWYSlLgERi8PWd8bx1kUHUk8L1BT57e49oKnDDD180mjfrHc1yA9rg==",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.2",
        "jsonfile": "^3.0.0",
        "universalify": "^0.1.0"
      }
    },
    "fs-minipass": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-1.2.7.tgz",
      "integrity": "sha512-GWSSJGFy4e9GUeCcbIkED+bgAoFyj7XF1mV8rma3QW4NIqX9Kyx79N/PF61H5udOV3aY1IaMLs6pGbH71nlCTA==",
      "requires": {
        "minipass": "^2.6.0"
      }
    },
    "fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw=="
    },
    "fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "optional": true
    },
    "gauge": {
      "version": "2.7.4",
      "resolved": "https://registry.npmjs.org/gauge/-/gauge-2.7.4.tgz",
      "integrity": "sha512-14x4kjc6lkD3ltw589k0NrPD6cCNTD6CWoVUNpB85+DrtONoZn+Rug6xZU5RvSC4+TZPxA5AnBibQYAvZn41Hg==",
      "requires": {
        "aproba": "^1.0.3",
        "console-control-strings": "^1.0.0",
        "has-unicode": "^2.0.0",
        "object-assign": "^4.1.0",
        "signal-exit": "^3.0.0",
        "string-width": "^1.0.1",
        "strip-ansi": "^3.0.1",
        "wide-align": "^1.1.0"
      }
    },
    "get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "dev": true
    },
    "getpass": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/getpass/-/getpass-0.1.7.tgz",
      "integrity": "sha512-0fzj9JxOLfJ+XGLhR8ze3unN0KZCgZwiSSDz168VERjK8Wl8kVSdcu2kspd4s4wtAa1y/qrVRiAA0WclVsu0ng==",
      "requires": {
        "assert-plus": "^1.0.0"
      }
    },
    "glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "requires": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      }
    },
    "glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "requires": {
        "is-glob": "^4.0.1"
      }
    },
    "graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "dev": true
    },
    "har-schema": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/har-schema/-/har-schema-2.0.0.tgz",
      "integrity": "sha512-Oqluz6zhGX8cyRaTQlFMPw80bSJVG2x/cFb8ZPhUILGgHka9SsokCCOQgpveePerqidZOrT14ipqfJb7ILcW5Q=="
    },
    "har-validator": {
      "version": "5.1.5",
      "resolved": "https://registry.npmjs.org/har-validator/-/har-validator-5.1.5.tgz",
      "integrity": "sha512-nmT2T0lljbxdQZfspsno9hgrG3Uir6Ks5afism62poxqBM6sDnMEuPmzTq8XN0OEwqKLLdh1jQI3qyE66Nzb3w==",
      "requires": {
        "ajv": "^6.12.3",
        "har-schema": "^2.0.0"
      }
    },
    "has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true
    },
    "has-unicode": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/has-unicode/-/has-unicode-2.0.1.tgz",
      "integrity": "sha512-8Rf9Y83NBReMnx0gFzA8JImQACstCYWUplepDa9xprwwtmgEZUF0h/i5xSA625zB/I37EtrswSST6OXxwaaIJQ=="
    },
    "http-errors": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
      "integrity": "sha512-4FbRdAX+bSdmo4AUFuS0WNiPz8NgFt+r8ThgNWmlrjQjt1Q7ZR9+zTlce2859x4KSXrwIsaeTqDoKQmtP8pLmQ==",
      "dev": true,
      "requires": {
        "depd": "~2.0.0",
        "inherits": "~2.0.4",
        "setprototypeof": "~1.2.0",
        "statuses": "~2.0.2",
        "toidentifier": "~1.0.1"
      },
      "dependencies": {
        "statuses": {
          "version": "2.0.2",
          "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
          "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
          "dev": true
        }
      }
    },
    "http-proxy": {
      "version": "1.18.1",
      "resolved": "https://registry.npmjs.org/http-proxy/-/http-proxy-1.18.1.tgz",
      "integrity": "sha512-7mz/721AbnJwIVbnaSv1Cz3Am0ZLT/UBwkC92VlxhXv/k/BBQfM2fXElQNC27BVGr0uwUpplYPQM9LnaBMR5NQ==",
      "dev": true,
      "requires": {
        "eventemitter3": "^4.0.0",
        "follow-redirects": "^1.0.0",
        "requires-port": "^1.0.0"
      }
    },
    "http-signature": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/http-signature/-/http-signature-1.2.0.tgz",
      "integrity": "sha512-CAbnr6Rz4CYQkLYUtSNXxQPUH2gK8f3iWexVlsnMeD+GjlsQ0Xsy1cOX+mN3dtxYomRy21CiOzU8Uhw6OwncEQ==",
      "requires": {
        "assert-plus": "^1.0.0",
        "jsprim": "^1.2.2",
        "sshpk": "^1.7.0"
      }
    },
    "iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "requires": {
        "safer-buffer": ">= 2.1.2 < 3"
      }
    },
    "ignore-walk": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/ignore-walk/-/ignore-walk-3.0.4.tgz",
      "integrity": "sha512-PY6Ii8o1jMRA1z4F2hRkH/xN59ox43DavKvD3oDpfurRlOJyAHpifIwpbdv1n4jt4ov0jSpw3kQ4GhJnpBL6WQ==",
      "requires": {
        "minimatch": "^3.0.4"
      }
    },
    "immutable": {
      "version": "3.8.2",
      "resolved": "https://registry.npmjs.org/immutable/-/immutable-3.8.2.tgz",
      "integrity": "sha512-15gZoQ38eYjEjxkorfbcgBKBL6R7T459OuK+CpcWt7O3KF4uPCx2tD0uFETlUDIyo+1789crbMhTvQBSR5yBMg==",
      "dev": true
    },
    "inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "requires": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "ini": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/ini/-/ini-1.3.8.tgz",
      "integrity": "sha512-JV/yugV2uzW5iMRSiZAyDtQd+nxtUnjeLt0acNdw98kKLrvuRVyB80tsREOE7yvGVgalhZ6RNXCmEHkUKBKxew=="
    },
    "invert-kv": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/invert-kv/-/invert-kv-1.0.0.tgz",
      "integrity": "sha512-xgs2NH9AE66ucSq4cNG1nhSFghr5l6tdL15Pk+jl46bmmBapgoaY/AacXyaDznAqmGL99TiLSQgO/XazFSKYeQ==",
      "dev": true
    },
    "is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "requires": {
        "binary-extensions": "^2.0.0"
      }
    },
    "is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true
    },
    "is-fullwidth-code-point": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
      "integrity": "sha512-1pqUqRjkhPJ9miNq9SwMfdvi6lBJcd6eFxvfaivQhaH3SgisfiuudvFntdKOmxuee/77l+FPjKrQjWvmPjWrRw==",
      "requires": {
        "number-is-nan": "^1.0.0"
      }
    },
    "is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "requires": {
        "is-extglob": "^2.1.1"
      }
    },
    "is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true
    },
    "is-number-like": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/is-number-like/-/is-number-like-1.0.8.tgz",
      "integrity": "sha512-6rZi3ezCyFcn5L71ywzz2bS5b2Igl1En3eTlZlvKjpz1n3IZLAYMbKYAIQgFmEu0GENg92ziU/faEOA/aixjbA==",
      "dev": true,
      "requires": {
        "lodash.isfinite": "^3.3.2"
      }
    },
    "is-typedarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-typedarray/-/is-typedarray-1.0.0.tgz",
      "integrity": "sha512-cyA56iCMHAh5CdzjJIa4aohJyeO1YbwLi3Jc35MmRU6poroFjIGZzUzupGiRPOjgHg9TLu43xbpwXk523fMxKA=="
    },
    "is-wsl": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-wsl/-/is-wsl-1.1.0.tgz",
      "integrity": "sha512-gfygJYZ2gLTDlmbWMI0CE2MwnFzSN/2SZfkMlItC4K/JBlsWVDB0bO6XhqcY13YXE7iMcAJnzTCJjPiTeJJ0Mw==",
      "dev": true
    },
    "isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ=="
    },
    "isstream": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/isstream/-/isstream-0.1.2.tgz",
      "integrity": "sha512-Yljz7ffyPbrLpLngrMtZ7NduUgVvi6wG9RJ9IUcyCd59YQ911PBJphODUcbOVbqYfxe1wuYf/LJ8PauMRwsM/g=="
    },
    "jsbn": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/jsbn/-/jsbn-0.1.1.tgz",
      "integrity": "sha512-UVU9dibq2JcFWxQPA6KCqj5O42VOmAY3zQUfEKxU0KpTGXwNoCjkX1e13eHNvw/xPynt6pU0rZ1htjWTNTSXsg=="
    },
    "jsdom": {
      "version": "8.5.0",
      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-8.5.0.tgz",
      "integrity": "sha512-rvWfcn2O8SrXPaX5fTYIfPVwvnbU8DnZkjAXK305wfP67csyaJBhgg0F2aU6imqJ+lZmj9EmrBAXy6rWHf2/9Q==",
      "requires": {
        "abab": "^1.0.0",
        "acorn": "^2.4.0",
        "acorn-globals": "^1.0.4",
        "array-equal": "^1.0.0",
        "cssom": ">= 0.3.0 < 0.4.0",
        "cssstyle": ">= 0.2.34 < 0.3.0",
        "escodegen": "^1.6.1",
        "iconv-lite": "^0.4.13",
        "nwmatcher": ">= 1.3.7 < 2.0.0",
        "parse5": "^1.5.1",
        "request": "^2.55.0",
        "sax": "^1.1.4",
        "symbol-tree": ">= 3.1.0 < 4.0.0",
        "tough-cookie": "^2.2.0",
        "webidl-conversions": "^3.0.1",
        "whatwg-url": "^2.0.1",
        "xml-name-validator": ">= 2.0.1 < 3.0.0"
      }
    },
    "json-schema": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/json-schema/-/json-schema-0.4.0.tgz",
      "integrity": "sha512-es94M3nTIfsEPisRafak+HDLfHXnKBhV3vU5eqPcS3flIWqcxJWgXHXiey3YrpaNsanY5ei1VoYEbOzijuq9BA=="
    },
    "json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
    },
    "json-stringify-safe": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
      "integrity": "sha512-ZClg6AaYvamvYEE82d3Iyd3vSSIjQ+odgjaTzRuO3s7toCdFKczob2i0zCh7JE8kWn17yvAWhUVxvqGwUalsRA=="
    },
    "jsonfile": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-3.0.1.tgz",
      "integrity": "sha512-oBko6ZHlubVB5mRFkur5vgYR1UyqX+S6Y/oCfLhqNdcc2fYFlDpIoNc7AfKS1KOGcnNAkvsr0grLck9ANM815w==",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.6"
      }
    },
    "jsprim": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/jsprim/-/jsprim-1.4.2.tgz",
      "integrity": "sha512-P2bSOMAc/ciLz6DzgjVlGJP9+BrJWu5UDGK70C2iweC5QBIeFf0ZXRvGjEj2uYgrY2MkAAhsSWHDWlFtEroZWw==",
      "requires": {
        "assert-plus": "1.0.0",
        "extsprintf": "1.3.0",
        "json-schema": "0.4.0",
        "verror": "1.10.0"
      }
    },
    "lcid": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/lcid/-/lcid-1.0.0.tgz",
      "integrity": "sha512-YiGkH6EnGrDGqLMITnGjXtGmNtjoXw9SVUzcaos8RBi7Ps0VBylkq+vOcY9QE5poLasPCR849ucFUkl0UzUyOw==",
      "dev": true,
      "requires": {
        "invert-kv": "^1.0.0"
      }
    },
    "levn": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.3.0.tgz",
      "integrity": "sha512-0OO4y2iOHix2W6ujICbKIaEQXvFQHue65vUG3pb5EUomzPI90z9hsA1VsO/dbIIpC53J8gxM9Q4Oho0jrCM/yA==",
      "requires": {
        "prelude-ls": "~1.1.2",
        "type-check": "~0.3.2"
      }
    },
    "limiter": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/limiter/-/limiter-1.1.5.tgz",
      "integrity": "sha512-FWWMIEOxz3GwUI4Ts/IvgVy6LPvoMPgjMdQ185nN6psJyBJ4yOpzqm695/h5umdLJg2vW3GR5iG11MAkR2AzJA==",
      "dev": true
    },
    "lite-server": {
      "version": "1.3.4",
      "resolved": "https://registry.npmjs.org/lite-server/-/lite-server-1.3.4.tgz",
      "integrity": "sha512-0VIINgw5OPFbrtuOyH8E8kQtjX7A/+jOFgjIo+zIZMNrUGKduxSLI9jCBOwukwkLkVGELq0TVBwKqpOXB/z+8A==",
      "dev": true,
      "requires": {
        "browser-sync": "^2.11.1",
        "connect-history-api-fallback": "^1.1.0",
        "connect-logger": "0.0.1",
        "yargs": "^3.32.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
          "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
          "dev": true
        },
        "browser-sync": {
          "version": "2.29.3",
          "resolved": "https://registry.npmjs.org/browser-sync/-/browser-sync-2.29.3.tgz",
          "integrity": "sha512-NiM38O6XU84+MN+gzspVmXV2fTOoe+jBqIBx3IBdhZrdeURr6ZgznJr/p+hQ+KzkKEiGH/GcC4SQFSL0jV49bg==",
          "dev": true,
          "requires": {
            "browser-sync-client": "^2.29.3",
            "browser-sync-ui": "^2.29.3",
            "bs-recipes": "1.3.4",
            "chalk": "4.1.2",
            "chokidar": "^3.5.1",
            "connect": "3.6.6",
            "connect-history-api-fallback": "^1",
            "dev-ip": "^1.0.1",
            "easy-extender": "^2.3.4",
            "eazy-logger": "^4.0.1",
            "etag": "^1.8.1",
            "fresh": "^0.5.2",
            "fs-extra": "3.0.1",
            "http-proxy": "^1.18.1",
            "immutable": "^3",
            "localtunnel": "^2.0.1",
            "micromatch": "^4.0.2",
            "opn": "5.3.0",
            "portscanner": "2.2.0",
            "raw-body": "^2.3.2",
            "resp-modifier": "6.0.2",
            "rx": "4.1.0",
            "send": "0.16.2",
            "serve-index": "1.9.1",
            "serve-static": "1.13.2",
            "server-destroy": "1.0.1",
            "socket.io": "^4.4.1",
            "ua-parser-js": "^1.0.33",
            "yargs": "^17.3.1"
          },
          "dependencies": {
            "yargs": {
              "version": "17.7.2",
              "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz",
              "integrity": "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==",
              "dev": true,
              "requires": {
                "cliui": "^8.0.1",
                "escalade": "^3.1.1",
                "get-caller-file": "^2.0.5",
                "require-directory": "^2.1.1",
                "string-width": "^4.2.3",
                "y18n": "^5.0.5",
                "yargs-parser": "^21.1.1"
              }
            }
          }
        },
        "cliui": {
          "version": "8.0.1",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz",
          "integrity": "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==",
          "dev": true,
          "requires": {
            "string-width": "^4.2.0",
            "strip-ansi": "^6.0.1",
            "wrap-ansi": "^7.0.0"
          }
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.3",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
          "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.1"
          }
        },
        "strip-ansi": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
          "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.1"
          }
        },
        "yargs-parser": {
          "version": "21.1.1",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz",
          "integrity": "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==",
          "dev": true
        }
      }
    },
    "localtunnel": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/localtunnel/-/localtunnel-2.0.2.tgz",
      "integrity": "sha512-n418Cn5ynvJd7m/N1d9WVJISLJF/ellZnfsLnx8WBWGzxv/ntNcFkJ1o6se5quUhCplfLGBNL5tYHiq5WF3Nug==",
      "dev": true,
      "requires": {
        "axios": "0.21.4",
        "debug": "4.3.2",
        "openurl": "1.1.1",
        "yargs": "17.1.1"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
          "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
          "dev": true
        },
        "debug": {
          "version": "4.3.2",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.2.tgz",
          "integrity": "sha512-mOp8wKcvj7XxC78zLgw/ZA+6TSgkoE2C/ienthhRD298T7UNwAg9diBpLRxC0mOezLl4B0xV7M0cCO6P/O0Xhw==",
          "dev": true,
          "requires": {
            "ms": "2.1.2"
          }
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "ms": {
          "version": "2.1.2",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
          "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.3",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
          "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.1"
          }
        },
        "strip-ansi": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
          "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.1"
          }
        },
        "yargs": {
          "version": "17.1.1",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.1.1.tgz",
          "integrity": "sha512-c2k48R0PwKIqKhPMWjeiF6y2xY/gPMUlro0sgxqXpbOIohWiLNXWslsootttv7E1e73QPAMQSg5FeySbVcpsPQ==",
          "dev": true,
          "requires": {
            "cliui": "^7.0.2",
            "escalade": "^3.1.1",
            "get-caller-file": "^2.0.5",
            "require-directory": "^2.1.1",
            "string-width": "^4.2.0",
            "y18n": "^5.0.5",
            "yargs-parser": "^20.2.2"
          }
        }
      }
    },
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "dev": true
    },
    "lodash.isfinite": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/lodash.isfinite/-/lodash.isfinite-3.3.2.tgz",
      "integrity": "sha512-7FGG40uhC8Mm633uKW1r58aElFlBlxCrg9JfSi3P6aYiWmfiWF0PgMd86ZUsxE5GwWPdHoS2+48bwTh2VPkIQA==",
      "dev": true
    },
    "micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "requires": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      }
    },
    "mime": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.4.1.tgz",
      "integrity": "sha512-KI1+qOZu5DcW6wayYHSzR/tXKCDC5Om4s1z2QJjDULzLcmf3DvzS7oluY4HCTrc+9FiKmWUgeNLg7W3uIQvxtQ==",
      "dev": true
    },
    "mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg=="
    },
    "mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "requires": {
        "mime-db": "1.52.0"
      }
    },
    "mimic-response": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-response/-/mimic-response-2.1.0.tgz",
      "integrity": "sha512-wXqjST+SLt7R009ySCglWBCFpjUygmCIfD790/kVbiGmUgfYGuB14PiTd5DwVxSV4NcYHjzMkoj5LjQZwTQLEA=="
    },
    "minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "requires": {
        "brace-expansion": "^1.1.7"
      }
    },
    "minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA=="
    },
    "minipass": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-2.9.0.tgz",
      "integrity": "sha512-wxfUjg9WebH+CUDX/CdbRlh5SmfZiy/hpkxaRI16Y9W56Pa75sWgd/rvFilSgrauD9NyFymP/+JFV3KwzIsJeg==",
      "requires": {
        "safe-buffer": "^5.1.2",
        "yallist": "^3.0.0"
      }
    },
    "minizlib": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-1.3.3.tgz",
      "integrity": "sha512-6ZYMOEnmVsdCeTJVE0W9ZD+pVnE8h9Hma/iOwwRDsdQoePpoX56/8B6z3P9VNwppJuBKNRuFDRNRqRWexT9G9Q==",
      "requires": {
        "minipass": "^2.9.0"
      }
    },
    "mitt": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/mitt/-/mitt-1.2.0.tgz",
      "integrity": "sha512-r6lj77KlwqLhIUku9UWYes7KJtsczvolZkzp8hbaDPPaE24OmWl5s539Mytlj22siEQKosZ26qCBgda2PKwoJw==",
      "dev": true
    },
    "mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "requires": {
        "minimist": "^1.2.6"
      }
    },
    "moment": {
      "version": "2.30.1",
      "resolved": "https://registry.npmjs.org/moment/-/moment-2.30.1.tgz",
      "integrity": "sha512-uEmtNhbDOrWPFS+hdjFCBfy9f2YoyzRpwcl+DqpC6taX21FzsTLQVbMV/W7PzNSX6x/bhC1zA3c2UQ5NzH6how==",
      "dev": true
    },
    "ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "nan": {
      "version": "2.24.0",
      "resolved": "https://registry.npmjs.org/nan/-/nan-2.24.0.tgz",
      "integrity": "sha512-Vpf9qnVW1RaDkoNKFUvfxqAbtI8ncb8OJlqZ9wwpXzWPEsvsB1nvdUi6oYrHIkQ1Y/tMDnr1h4nczS0VB9Xykg=="
    },
    "needle": {
      "version": "2.9.1",
      "resolved": "https://registry.npmjs.org/needle/-/needle-2.9.1.tgz",
      "integrity": "sha512-6R9fqJ5Zcmf+uYaFgdIHmLwNldn5HbK8L5ybn7Uz+ylX/rnOsSp1AHcvQSrCaFN+qNM1wpymHqD7mVasEOlHGQ==",
      "requires": {
        "debug": "^3.2.6",
        "iconv-lite": "^0.4.4",
        "sax": "^1.2.4"
      }
    },
    "negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "dev": true
    },
    "node-pre-gyp": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/node-pre-gyp/-/node-pre-gyp-0.11.0.tgz",
      "integrity": "sha512-TwWAOZb0j7e9eGaf9esRx3ZcLaE5tQ2lvYy1pb5IAaG1a2e2Kv5Lms1Y4hpj+ciXJRofIxxlt5haeQ/2ANeE0Q==",
      "requires": {
        "detect-libc": "^1.0.2",
        "mkdirp": "^0.5.1",
        "needle": "^2.2.1",
        "nopt": "^4.0.1",
        "npm-packlist": "^1.1.6",
        "npmlog": "^4.0.2",
        "rc": "^1.2.7",
        "rimraf": "^2.6.1",
        "semver": "^5.3.0",
        "tar": "^4"
      }
    },
    "nopt": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/nopt/-/nopt-4.0.3.tgz",
      "integrity": "sha512-CvaGwVMztSMJLOeXPrez7fyfObdZqNUK1cPAEzLHrTybIua9pMdmmPR5YwtfNftIOMv3DPUhFaxsZMNTQO20Kg==",
      "requires": {
        "abbrev": "1",
        "osenv": "^0.1.4"
      }
    },
    "normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true
    },
    "npm-bundled": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/npm-bundled/-/npm-bundled-1.1.2.tgz",
      "integrity": "sha512-x5DHup0SuyQcmL3s7Rx/YQ8sbw/Hzg0rj48eN0dV7hf5cmQq5PXIeioroH3raV1QC1yh3uTYuMThvEQF3iKgGQ==",
      "requires": {
        "npm-normalize-package-bin": "^1.0.1"
      }
    },
    "npm-normalize-package-bin": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/npm-normalize-package-bin/-/npm-normalize-package-bin-1.0.1.tgz",
      "integrity": "sha512-EPfafl6JL5/rU+ot6P3gRSCpPDW5VmIzX959Ob1+ySFUuuYHWHekXpwdUZcKP5C+DS4GEtdJluwBjnsNDl+fSA=="
    },
    "npm-packlist": {
      "version": "1.4.8",
      "resolved": "https://registry.npmjs.org/npm-packlist/-/npm-packlist-1.4.8.tgz",
      "integrity": "sha512-5+AZgwru5IevF5ZdnFglB5wNlHG1AOOuw28WhUq8/8emhBmLv6jX5by4WJCh7lW0uSYZYS6DXqIsyZVIXRZU9A==",
      "requires": {
        "ignore-walk": "^3.0.1",
        "npm-bundled": "^1.0.1",
        "npm-normalize-package-bin": "^1.0.1"
      }
    },
    "npmlog": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-4.1.2.tgz",
      "integrity": "sha512-2uUqazuKlTaSI/dC8AzicUck7+IrEaOnN/e0jd3Xtt1KcGpwx30v50mL7oPyr/h9bL3E4aZccVwpwP+5W9Vjkg==",
      "requires": {
        "are-we-there-yet": "~1.1.2",
        "console-control-strings": "~1.1.0",
        "gauge": "~2.7.3",
        "set-blocking": "~2.0.0"
      }
    },
    "number-is-nan": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz",
      "integrity": "sha512-4jbtZXNAsfZbAHiiqjLPBiCl16dES1zI4Hpzzxw61Tk+loF+sBDBKx1ICKKKwIqQ7M0mFn1TmkN7euSncWgHiQ=="
    },
    "nwmatcher": {
      "version": "1.4.4",
      "resolved": "https://registry.npmjs.org/nwmatcher/-/nwmatcher-1.4.4.tgz",
      "integrity": "sha512-3iuY4N5dhgMpCUrOVnuAdGrgxVqV2cJpM+XNccjR2DKOB1RUP0aA+wGXEiNziG/UKboFyGBIoKOaNlJxx8bciQ=="
    },
    "oauth-sign": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/oauth-sign/-/oauth-sign-0.9.0.tgz",
      "integrity": "sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ=="
    },
    "object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg=="
    },
    "on-finished": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
      "integrity": "sha512-ikqdkGAAyf/X/gPhXGvfgAytDZtDbr+bkNUJ0N9h5MI/dmdgCs3l6hoHrcUv41sRKew3jIwrp4qQDXiK99Utww==",
      "dev": true,
      "requires": {
        "ee-first": "1.1.1"
      }
    },
    "once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "requires": {
        "wrappy": "1"
      }
    },
    "openurl": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/openurl/-/openurl-1.1.1.tgz",
      "integrity": "sha512-d/gTkTb1i1GKz5k3XE3XFV/PxQ1k45zDqGP2OA7YhgsaLoqm6qRvARAZOFer1fcXritWlGBRCu/UgeS4HAnXAA==",
      "dev": true
    },
    "opn": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/opn/-/opn-5.3.0.tgz",
      "integrity": "sha512-bYJHo/LOmoTd+pfiYhfZDnf9zekVJrY+cnS2a5F2x+w5ppvTqObojTP7WiFG+kVZs9Inw+qQ/lw7TroWwhdd2g==",
      "dev": true,
      "requires": {
        "is-wsl": "^1.1.0"
      }
    },
    "optionator": {
      "version": "0.8.3",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.8.3.tgz",
      "integrity": "sha512-+IW9pACdk3XWmmTXG8m3upGUJst5XRGzxMRjXzAuJ1XnIFNvfhjjIuYkDvysnPQ7qzqVzLt78BCruntqRhWQbA==",
      "requires": {
        "deep-is": "~0.1.3",
        "fast-levenshtein": "~2.0.6",
        "levn": "~0.3.0",
        "prelude-ls": "~1.1.2",
        "type-check": "~0.3.2",
        "word-wrap": "~1.2.3"
      }
    },
    "os-homedir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-homedir/-/os-homedir-1.0.2.tgz",
      "integrity": "sha512-B5JU3cabzk8c67mRRd3ECmROafjYMXbuzlwtqdM8IbS8ktlTix8aFGb2bAGKrSRIlnfKwovGUUr72JUPyOb6kQ=="
    },
    "os-locale": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/os-locale/-/os-locale-1.4.0.tgz",
      "integrity": "sha512-PRT7ZORmwu2MEFt4/fv3Q+mEfN4zetKxufQrkShY2oGvUms9r8otu5HfdyIFHkYXjO7laNsoVGmM2MANfuTA8g==",
      "dev": true,
      "requires": {
        "lcid": "^1.0.0"
      }
    },
    "os-tmpdir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz",
      "integrity": "sha512-D2FR03Vir7FIu45XBY20mTb+/ZSWB00sjU9jdQXt83gDrI4Ztz5Fs7/yy74g2N5SVQY4xY1qDr4rNddwYRVX0g=="
    },
    "osenv": {
      "version": "0.1.5",
      "resolved": "https://registry.npmjs.org/osenv/-/osenv-0.1.5.tgz",
      "integrity": "sha512-0CWcCECdMVc2Rw3U5w9ZjqX6ga6ubk1xDVKxtBQPK7wis/0F2r9T6k4ydGYhecl7YUBxBVxhL5oisPsNxAPe2g==",
      "requires": {
        "os-homedir": "^1.0.0",
        "os-tmpdir": "^1.0.0"
      }
    },
    "parse5": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-1.5.1.tgz",
      "integrity": "sha512-w2jx/0tJzvgKwZa58sj2vAYq/S/K1QJfIB3cWYea/Iu1scFPDQQ3IQiVZTHWtRBwAjv2Yd7S/xeZf3XqLDb3bA=="
    },
    "parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "dev": true
    },
    "path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg=="
    },
    "performance-now": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/performance-now/-/performance-now-2.1.0.tgz",
      "integrity": "sha512-7EAHlyLHI56VEIdK57uwHdHKIaAGbnXPiw0yWbarQZOKaKpvUIgW0jWRVLiatnM+XXlSwsanIBH/hzGMJulMow=="
    },
    "picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true
    },
    "portscanner": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/portscanner/-/portscanner-2.2.0.tgz",
      "integrity": "sha512-IFroCz/59Lqa2uBvzK3bKDbDDIEaAY8XJ1jFxcLWTqosrsc32//P4VuSB2vZXoHiHqOmx8B5L5hnKOxL/7FlPw==",
      "dev": true,
      "requires": {
        "async": "^2.6.0",
        "is-number-like": "^1.0.3"
      }
    },
    "prelude-ls": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.1.2.tgz",
      "integrity": "sha512-ESF23V4SKG6lVSGZgYNpbsiaAkdab6ZgOxe52p7+Kid3W3u3bxR4Vfd/o21dmN7jSt0IwgZ4v5MUd26FEtXE9w=="
    },
    "process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag=="
    },
    "psl": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/psl/-/psl-1.15.0.tgz",
      "integrity": "sha512-JZd3gMVBAVQkSs6HdNZo9Sdo0LNcQeMNP3CozBJb3JYC/QUYZTnKxP+f8oWRX4rHP5EurWxqAHTSwUCjlNKa1w==",
      "requires": {
        "punycode": "^2.3.1"
      }
    },
    "punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg=="
    },
    "qs": {
      "version": "6.5.3",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.3.tgz",
      "integrity": "sha512-qxXIEh4pCGfHICj1mAJQ2/2XVZkjCDTcEgfoSQxc/fYivUZxTkk7L3bDBJSoNrEzXI17oUO5Dp07ktqE5KzczA=="
    },
    "range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "dev": true
    },
    "raw-body": {
      "version": "2.5.3",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.3.tgz",
      "integrity": "sha512-s4VSOf6yN0rvbRZGxs8Om5CWj6seneMwK3oDb4lWDH0UPhWcxwOWw5+qk24bxq87szX1ydrwylIOp2uG1ojUpA==",
      "dev": true,
      "requires": {
        "bytes": "~3.1.2",
        "http-errors": "~2.0.1",
        "iconv-lite": "~0.4.24",
        "unpipe": "~1.0.0"
      }
    },
    "rc": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/rc/-/rc-1.2.8.tgz",
      "integrity": "sha512-y3bGgqKj3QBdxLbLkomlohkvsA8gdAiUQlSBJnBhfn+BPxg4bc62d8TcBW15wavDfgexCgccckhcZvywyQYPOw==",
      "requires": {
        "deep-extend": "^0.6.0",
        "ini": "~1.3.0",
        "minimist": "^1.2.0",
        "strip-json-comments": "~2.0.1"
      }
    },
    "readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "requires": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "requires": {
        "picomatch": "^2.2.1"
      }
    },
    "request": {
      "version": "2.88.2",
      "resolved": "https://registry.npmjs.org/request/-/request-2.88.2.tgz",
      "integrity": "sha512-MsvtOrfG9ZcrOwAW+Qi+F6HbD0CWXEh9ou77uOb7FM2WPhwT7smM833PzanhJLsgXjN89Ir6V2PczXNnMpwKhw==",
      "requires": {
        "aws-sign2": "~0.7.0",
        "aws4": "^1.8.0",
        "caseless": "~0.12.0",
        "combined-stream": "~1.0.6",
        "extend": "~3.0.2",
        "forever-agent": "~0.6.1",
        "form-data": "~2.3.2",
        "har-validator": "~5.1.3",
        "http-signature": "~1.2.0",
        "is-typedarray": "~1.0.0",
        "isstream": "~0.1.2",
        "json-stringify-safe": "~5.0.1",
        "mime-types": "~2.1.19",
        "oauth-sign": "~0.9.0",
        "performance-now": "^2.1.0",
        "qs": "~6.5.2",
        "safe-buffer": "^5.1.2",
        "tough-cookie": "~2.5.0",
        "tunnel-agent": "^0.6.0",
        "uuid": "^3.3.2"
      }
    },
    "require-directory": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
      "integrity": "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==",
      "dev": true
    },
    "requires-port": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/requires-port/-/requires-port-1.0.0.tgz",
      "integrity": "sha512-KigOCHcocU3XODJxsu8i/j8T9tzT4adHiecwORRQ0ZZFcp7ahwXuRU1m+yuO90C5ZUyGeGfocHDI14M3L3yDAQ==",
      "dev": true
    },
    "resp-modifier": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/resp-modifier/-/resp-modifier-6.0.2.tgz",
      "integrity": "sha512-U1+0kWC/+4ncRFYqQWTx/3qkfE6a4B/h3XXgmXypfa0SPZ3t7cbbaFk297PjQS/yov24R18h6OZe6iZwj3NSLw==",
      "dev": true,
      "requires": {
        "debug": "^2.2.0",
        "minimatch": "^3.0.2"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
          "dev": true
        }
      }
    },
    "rgbcolor": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/rgbcolor/-/rgbcolor-1.0.1.tgz",
      "integrity": "sha512-9aZLIrhRaD97sgVhtJOW6ckOEh6/GnvQtdVNfdZ6s67+3/XwLS9lBcQYzEEhYVeUowN7pRzMLsyGhK2i/xvWbw=="
    },
    "rimraf": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
      "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
      "requires": {
        "glob": "^7.1.3"
      }
    },
    "rx": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/rx/-/rx-4.1.0.tgz",
      "integrity": "sha512-CiaiuN6gapkdl+cZUr67W6I8jquN4lkak3vtIsIWCl4XIPP8ffsoyN6/+PuGXnQy8Cu8W2y9Xxh31Rq4M6wUug==",
      "dev": true
    },
    "safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
    },
    "safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "sax": {
      "version": "1.4.4",
      "resolved": "https://registry.npmjs.org/sax/-/sax-1.4.4.tgz",
      "integrity": "sha512-1n3r/tGXO6b6VXMdFT54SHzT9ytu9yr7TaELowdYpMqY/Ao7EnlQGmAQ1+RatX7Tkkdm6hONI2owqNx2aZj5Sw=="
    },
    "semver": {
      "version": "5.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.2.tgz",
      "integrity": "sha512-cBznnQ9KjJqU67B52RMC65CMarK2600WFnbkcaiwWq3xy/5haFJlshgnpjovMVJ+Hff49d8GEn0b87C5pDQ10g=="
    },
    "send": {
      "version": "0.16.2",
      "resolved": "https://registry.npmjs.org/send/-/send-0.16.2.tgz",
      "integrity": "sha512-E64YFPUssFHEFBvpbbjr44NCLtI1AohxQ8ZSiJjQLskAdKuriYEP6VyGEsRDH8ScozGpkaX1BGvhanqCwkcEZw==",
      "dev": true,
      "requires": {
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "destroy": "~1.0.4",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "~1.6.2",
        "mime": "1.4.1",
        "ms": "2.0.0",
        "on-finished": "~2.3.0",
        "range-parser": "~1.2.0",
        "statuses": "~1.4.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha512-7emPTl6Dpo6JRXOXjLRxck+FlLRX5847cLKEn00PLAgc3g2hTZZgr+e4c2v6QpSmLeFP3n5yUo7ft6avBK/5jQ==",
          "dev": true
        },
        "http-errors": {
          "version": "1.6.3",
          "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.6.3.tgz",
          "integrity": "sha512-lks+lVC8dgGyh97jxvxeYTWQFvh4uw4yC12gVl63Cg30sjPX4wuGcdkICVXDAESr6OJGjqGA8Iz5mkeN6zlD7A==",
          "dev": true,
          "requires": {
            "depd": "~1.1.2",
            "inherits": "2.0.3",
            "setprototypeof": "1.1.0",
            "statuses": ">= 1.4.0 < 2"
          }
        },
        "inherits": {
          "version": "2.0.3",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
          "integrity": "sha512-x00IRNXNy63jwGkJmzPigoySHbaqpNuzKbBOmzK+g2OdZpQ9w+sxCN+VSB3ja7IAge2OP2qpfxTjeNcyjmW1uw==",
          "dev": true
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
          "dev": true
        },
        "setprototypeof": {
          "version": "1.1.0",
          "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.0.tgz",
          "integrity": "sha512-BvE/TwpZX4FXExxOxZyRGQQv651MSwmWKZGqvmPcRIjDqWub67kTKuIMx43cZZrS/cBBzwBcNDWoFxt2XEFIpQ==",
          "dev": true
        },
        "statuses": {
          "version": "1.4.0",
          "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.4.0.tgz",
          "integrity": "sha512-zhSCtt8v2NDrRlPQpCNtw/heZLtfUDqxBM1udqikb/Hbk52LK4nQSwr10u77iopCW5LsyHpuXS0GnEc48mLeew==",
          "dev": true
        }
      }
    },
    "serve-index": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/serve-index/-/serve-index-1.9.1.tgz",
      "integrity": "sha512-pXHfKNP4qujrtteMrSBb0rc8HJ9Ms/GrXwcUtUtD5s4ewDJI8bT3Cz2zTVRMKtri49pLx2e0Ya8ziP5Ya2pZZw==",
      "dev": true,
      "requires": {
        "accepts": "~1.3.4",
        "batch": "0.6.1",
        "debug": "2.6.9",
        "escape-html": "~1.0.3",
        "http-errors": "~1.6.2",
        "mime-types": "~2.1.17",
        "parseurl": "~1.3.2"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha512-7emPTl6Dpo6JRXOXjLRxck+FlLRX5847cLKEn00PLAgc3g2hTZZgr+e4c2v6QpSmLeFP3n5yUo7ft6avBK/5jQ==",
          "dev": true
        },
        "http-errors": {
          "version": "1.6.3",
          "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.6.3.tgz",
          "integrity": "sha512-lks+lVC8dgGyh97jxvxeYTWQFvh4uw4yC12gVl63Cg30sjPX4wuGcdkICVXDAESr6OJGjqGA8Iz5mkeN6zlD7A==",
          "dev": true,
          "requires": {
            "depd": "~1.1.2",
            "inherits": "2.0.3",
            "setprototypeof": "1.1.0",
            "statuses": ">= 1.4.0 < 2"
          }
        },
        "inherits": {
          "version": "2.0.3",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
          "integrity": "sha512-x00IRNXNy63jwGkJmzPigoySHbaqpNuzKbBOmzK+g2OdZpQ9w+sxCN+VSB3ja7IAge2OP2qpfxTjeNcyjmW1uw==",
          "dev": true
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
          "dev": true
        },
        "setprototypeof": {
          "version": "1.1.0",
          "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.0.tgz",
          "integrity": "sha512-BvE/TwpZX4FXExxOxZyRGQQv651MSwmWKZGqvmPcRIjDqWub67kTKuIMx43cZZrS/cBBzwBcNDWoFxt2XEFIpQ==",
          "dev": true
        },
        "statuses": {
          "version": "1.5.0",
          "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
          "integrity": "sha512-OpZ3zP+jT1PI7I8nemJX4AKmAX070ZkYPVWV/AaKTJl+tXCTGyVdC1a4SL8RUQYEwk/f34ZX8UTykN68FwrqAA==",
          "dev": true
        }
      }
    },
    "serve-static": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.13.2.tgz",
      "integrity": "sha512-p/tdJrO4U387R9oMjb1oj7qSMaMfmOyd4j9hOFoxZe2baQszgHcSWjuya/CiT5kgZZKRudHNOA0pYXOl8rQ5nw==",
      "dev": true,
      "requires": {
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.2",
        "send": "0.16.2"
      }
    },
    "server-destroy": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/server-destroy/-/server-destroy-1.0.1.tgz",
      "integrity": "sha512-rb+9B5YBIEzYcD6x2VKidaa+cqYBJQKnU4oe4E3ANwRRN56yk/ua1YCJT1n21NTS8w6CcOclAKNP3PhdCXKYtQ==",
      "dev": true
    },
    "set-blocking": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
      "integrity": "sha512-KiKBS8AnWGEyLzofFfmvKwpdPzqiy16LvQfK3yv/fVH7Bj13/wl3JSR1J+rfgRE9q7xUJK4qvgS8raSOeLUehw=="
    },
    "setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "dev": true
    },
    "signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ=="
    },
    "simple-concat": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
      "integrity": "sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q=="
    },
    "simple-get": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/simple-get/-/simple-get-3.1.1.tgz",
      "integrity": "sha512-CQ5LTKGfCpvE1K0n2us+kuMPbk/q0EKl82s4aheV9oXjFEz6W/Y7oQFVJuU6QG77hRT4Ghb5RURteF5vnWjupA==",
      "requires": {
        "decompress-response": "^4.2.0",
        "once": "^1.3.1",
        "simple-concat": "^1.0.0"
      }
    },
    "socket.io": {
      "version": "4.8.3",
      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.8.3.tgz",
      "integrity": "sha512-2Dd78bqzzjE6KPkD5fHZmDAKRNe3J15q+YHDrIsy9WEkqttc7GY+kT9OBLSMaPbQaEd0x1BjcmtMtXkfpc+T5A==",
      "dev": true,
      "requires": {
        "accepts": "~1.3.4",
        "base64id": "~2.0.0",
        "cors": "~2.8.5",
        "debug": "~4.4.1",
        "engine.io": "~6.6.0",
        "socket.io-adapter": "~2.5.2",
        "socket.io-parser": "~4.2.4"
      },
      "dependencies": {
        "debug": {
          "version": "4.4.3",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
          "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
          "dev": true,
          "requires": {
            "ms": "^2.1.3"
          }
        }
      }
    },
    "socket.io-adapter": {
      "version": "2.5.6",
      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.6.tgz",
      "integrity": "sha512-DkkO/dz7MGln0dHn5bmN3pPy+JmywNICWrJqVWiVOyvXjWQFIv9c2h24JrQLLFJ2aQVQf/Cvl1vblnd4r2apLQ==",
      "dev": true,
      "requires": {
        "debug": "~4.4.1",
        "ws": "~8.18.3"
      },
      "dependencies": {
        "debug": {
          "version": "4.4.3",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
          "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
          "dev": true,
          "requires": {
            "ms": "^2.1.3"
          }
        }
      }
    },
    "socket.io-client": {
      "version": "4.8.3",
      "resolved": "https://registry.npmjs.org/socket.io-client/-/socket.io-client-4.8.3.tgz",
      "integrity": "sha512-uP0bpjWrjQmUt5DTHq9RuoCBdFJF10cdX9X+a368j/Ft0wmaVgxlrjvK3kjvgCODOMMOz9lcaRzxmso0bTWZ/g==",
      "dev": true,
      "requires": {
        "@socket.io/component-emitter": "~3.1.0",
        "debug": "~4.4.1",
        "engine.io-client": "~6.6.1",
        "socket.io-parser": "~4.2.4"
      },
      "dependencies": {
        "debug": {
          "version": "4.4.3",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
          "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
          "dev": true,
          "requires": {
            "ms": "^2.1.3"
          }
        }
      }
    },
    "socket.io-parser": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/socket.io-parser/-/socket.io-parser-4.2.5.tgz",
      "integrity": "sha512-bPMmpy/5WWKHea5Y/jYAP6k74A+hvmRCQaJuJB6I/ML5JZq/KfNieUVo/3Mh7SAqn7TyFdIo6wqYHInG1MU1bQ==",
      "dev": true,
      "requires": {
        "@socket.io/component-emitter": "~3.1.0",
        "debug": "~4.4.1"
      },
      "dependencies": {
        "debug": {
          "version": "4.4.3",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
          "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
          "dev": true,
          "requires": {
            "ms": "^2.1.3"
          }
        }
      }
    },
    "source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "optional": true
    },
    "sshpk": {
      "version": "1.18.0",
      "resolved": "https://registry.npmjs.org/sshpk/-/sshpk-1.18.0.tgz",
      "integrity": "sha512-2p2KJZTSqQ/I3+HX42EpYOa2l3f8Erv8MWKsy2I9uf4wA7yFIkXRffYdsx86y6z4vHtV8u7g+pPlr8/4ouAxsQ==",
      "requires": {
        "asn1": "~0.2.3",
        "assert-plus": "^1.0.0",
        "bcrypt-pbkdf": "^1.0.0",
        "dashdash": "^1.12.0",
        "ecc-jsbn": "~0.1.1",
        "getpass": "^0.1.1",
        "jsbn": "~0.1.0",
        "safer-buffer": "^2.0.2",
        "tweetnacl": "~0.14.0"
      }
    },
    "stackblur-canvas": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/stackblur-canvas/-/stackblur-canvas-1.4.1.tgz",
      "integrity": "sha512-TfbTympL5C1K+F/RizDkMBqH18EkUKU8V+4PphIXR+fWhZwwRi3bekP04gy2TOwOT3R6rJQJXAXFrbcZde7wow=="
    },
    "statuses": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.3.1.tgz",
      "integrity": "sha512-wuTCPGlJONk/a1kqZ4fQM2+908lC7fa7nPYpTC1EhnvqLX/IICbeP1OZGDtA374trpSq68YubKUMo8oRhN46yg==",
      "dev": true
    },
    "stream-throttle": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/stream-throttle/-/stream-throttle-0.1.3.tgz",
      "integrity": "sha512-889+B9vN9dq7/vLbGyuHeZ6/ctf5sNuGWsDy89uNxkFTAgzy0eK7+w5fL3KLNRTkLle7EgZGvHUphZW0Q26MnQ==",
      "dev": true,
      "requires": {
        "commander": "^2.2.0",
        "limiter": "^1.0.5"
      }
    },
    "string-width": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
      "integrity": "sha512-0XsVpQLnVCXHJfyEs8tC0zpTVIr5PKKsQtkT29IwupnPTjtPmQ3xT/4yCREF9hYkV/3M3kzcUTSAZT6a6h81tw==",
      "requires": {
        "code-point-at": "^1.0.0",
        "is-fullwidth-code-point": "^1.0.0",
        "strip-ansi": "^3.0.0"
      }
    },
    "string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "requires": {
        "safe-buffer": "~5.1.0"
      }
    },
    "strip-ansi": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
      "integrity": "sha512-VhumSSbBqDTP8p2ZLKj40UjBCV4+v8bUSEpUb4KjRgWk9pbqGF4REFj6KEagidb2f/M6AzC0EmFyDNGaw9OCzg==",
      "requires": {
        "ansi-regex": "^2.0.0"
      }
    },
    "strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ=="
    },
    "supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "requires": {
        "has-flag": "^4.0.0"
      }
    },
    "svg2img": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/svg2img/-/svg2img-0.6.3.tgz",
      "integrity": "sha512-YHRFWpXJbiDMZY1J3vIORpLe0d9cWqD2YgWyBA/FMmtHumMF394Y2pZlClyBwZw3Y5IUgMRPn4SyPcGpAspizg==",
      "requires": {
        "atob": "^2.0.0",
        "btoa": "^1.1.2",
        "canvas": "^2.0.0-alpha.13",
        "canvg": "^1.5.3"
      }
    },
    "symbol-tree": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.4.tgz",
      "integrity": "sha512-9QNk5KwDF+Bvz+PyObkmSYjI5ksVUYtjW7AU22r2NKcfLJcXp96hkDWU3+XndOsUb+AQ9QhfzfCT2O+CNWT5Tw=="
    },
    "tar": {
      "version": "4.4.19",
      "resolved": "https://registry.npmjs.org/tar/-/tar-4.4.19.tgz",
      "integrity": "sha512-a20gEsvHnWe0ygBY8JbxoM4w3SJdhc7ZAuxkLqh+nvNQN2IOt0B5lLgM490X5Hl8FF0dl0tOf2ewFYAlIFgzVA==",
      "requires": {
        "chownr": "^1.1.4",
        "fs-minipass": "^1.2.7",
        "minipass": "^2.9.0",
        "minizlib": "^1.3.3",
        "mkdirp": "^0.5.5",
        "safe-buffer": "^5.2.1",
        "yallist": "^3.1.1"
      },
      "dependencies": {
        "safe-buffer": {
          "version": "5.2.1",
          "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
          "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
        }
      }
    },
    "to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "requires": {
        "is-number": "^7.0.0"
      }
    },
    "toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "dev": true
    },
    "tough-cookie": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.5.0.tgz",
      "integrity": "sha512-nlLsUzgm1kfLXSXfRZMc1KLAugd4hqJHDTvc2hDIwS3mZAfMEuMbc03SujMF+GEcpaX/qboeycw6iO8JwVv2+g==",
      "requires": {
        "psl": "^1.1.28",
        "punycode": "^2.1.1"
      }
    },
    "tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "tunnel-agent": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
      "integrity": "sha512-McnNiV1l8RYeY8tBgEpuodCC1mLUdbSN+CYBL7kJsJNInOP8UjDDEwdk6Mw60vdLLrr5NHKZhMAOSrR2NZuQ+w==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "tweetnacl": {
      "version": "0.14.5",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-0.14.5.tgz",
      "integrity": "sha512-KXXFFdAbFXY4geFIwoyNK+f5Z1b7swfXABfL7HXCmoIWMKU3dmS26672A4EeQtDzLKy7SXmfBu51JolvEKwtGA=="
    },
    "type-check": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.3.2.tgz",
      "integrity": "sha512-ZCmOJdvOWDBYJlzAoFkC+Q0+bUyEOS1ltgp1MGU03fqHG+dbi9tBFU2Rd9QKiDZFAYrhPh2JUf7rZRIuHRKtOg==",
      "requires": {
        "prelude-ls": "~1.1.2"
      }
    },
    "ua-parser-js": {
      "version": "1.0.41",
      "resolved": "https://registry.npmjs.org/ua-parser-js/-/ua-parser-js-1.0.41.tgz",
      "integrity": "sha512-LbBDqdIC5s8iROCUjMbW1f5dJQTEFB1+KO9ogbvlb3nm9n4YHa5p4KTvFPWvh2Hs8gZMBuiB1/8+pdfe/tDPug==",
      "dev": true
    },
    "universalify": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/universalify/-/universalify-0.1.2.tgz",
      "integrity": "sha512-rBJeI5CXAlmy1pV+617WB9J63U6XcazHHF2f2dbJix4XzpUF0RS3Zbj0FGIOCAva5P/d/GBOYaACQ1w+0azUkg==",
      "dev": true
    },
    "unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "dev": true
    },
    "uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "requires": {
        "punycode": "^2.1.0"
      }
    },
    "util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw=="
    },
    "utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "dev": true
    },
    "uuid": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-3.4.0.tgz",
      "integrity": "sha512-HjSDRw6gZE5JMggctHBcjVak08+KEVhSIiDzFnT9S9aegmp85S/bReBVTb4QTFaRNptJ9kuYaNhnbNEOkbKb/A=="
    },
    "vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "dev": true
    },
    "verror": {
      "version": "1.10.0",
      "resolved": "https://registry.npmjs.org/verror/-/verror-1.10.0.tgz",
      "integrity": "sha512-ZZKSmDAEFOijERBLkmYfJ+vmk3w+7hOLYDNkRCuRuMJGEmqYNCNLyBBFwWKVMhfwaEF3WOd0Zlw86U/WC/+nYw==",
      "requires": {
        "assert-plus": "^1.0.0",
        "core-util-is": "1.0.2",
        "extsprintf": "^1.2.0"
      },
      "dependencies": {
        "core-util-is": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz",
          "integrity": "sha512-3lqz5YjWTYnW6dlDa5TLaTCcShfar1e40rmcJVwCBJC6mWlFuj0eCHIElmG1g5kyuJ/GD+8Wn4FFCcz4gJPfaQ=="
        }
      }
    },
    "webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "whatwg-url": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-2.0.1.tgz",
      "integrity": "sha512-sX+FT4N6iR0ZiqGqyDEKklyfMGR99zvxZD+LQ8IGae5uVGswQ7DOeLPB5KgJY8FzkwSzwqOXLQeVQvtOTSQU9Q==",
      "requires": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "wide-align": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.5.tgz",
      "integrity": "sha512-eDMORYaPNZ4sQIuuYPDHdQvf4gyCF9rEEV/yPxGfwPkRodwEgiMUUXTx/dex+Me0wxx53S+NgUHaP7y3MGlDmg==",
      "requires": {
        "string-width": "^1.0.2 || 2 || 3 || 4"
      }
    },
    "window-size": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/window-size/-/window-size-0.1.4.tgz",
      "integrity": "sha512-2thx4pB0cV3h+Bw7QmMXcEbdmOzv9t0HFplJH/Lz6yu60hXYy5RT8rUu+wlIreVxWsGN20mo+MHeCSfUpQBwPw==",
      "dev": true
    },
    "word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA=="
    },
    "wrap-ansi": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
          "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.3",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
          "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.1"
          }
        },
        "strip-ansi": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
          "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.1"
          }
        }
      }
    },
    "wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ=="
    },
    "ws": {
      "version": "8.18.3",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
      "dev": true
    },
    "xml-name-validator": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-2.0.1.tgz",
      "integrity": "sha512-jRKe/iQYMyVJpzPH+3HL97Lgu5HrCfii+qSo+TfjKHtOnvbnvdVfMYrn9Q34YV81M2e5sviJlI6Ko9y+nByzvA=="
    },
    "xmldom": {
      "version": "0.1.31",
      "resolved": "https://registry.npmjs.org/xmldom/-/xmldom-0.1.31.tgz",
      "integrity": "sha512-yS2uJflVQs6n+CyjHoaBmVSqIDevTAWrzMmjG1Gc7h1qQ7uVozNhEPJAwZXWyGQ/Gafo3fCwrcaokezLPupVyQ=="
    },
    "xmlhttprequest-ssl": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/xmlhttprequest-ssl/-/xmlhttprequest-ssl-2.1.2.tgz",
      "integrity": "sha512-TEU+nJVUUnA4CYJFLvK5X9AOeH4KvDvhIfm0vV1GaQRtchnG0hgK5p8hw/xjv8cunWYCsiPCSDzObPyhEwq3KQ==",
      "dev": true
    },
    "y18n": {
      "version": "5.0.8",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
      "dev": true
    },
    "yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g=="
    },
    "yargs": {
      "version": "3.32.0",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-3.32.0.tgz",
      "integrity": "sha512-ONJZiimStfZzhKamYvR/xvmgW3uEkAUFSP91y2caTEPhzF6uP2JfPiVZcq66b/YR0C3uitxSV7+T1x8p5bkmMg==",
      "dev": true,
      "requires": {
        "camelcase": "^2.0.1",
        "cliui": "^3.0.3",
        "decamelize": "^1.1.1",
        "os-locale": "^1.4.0",
        "string-width": "^1.0.1",
        "window-size": "^0.1.4",
        "y18n": "^3.2.0"
      },
      "dependencies": {
        "cliui": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-3.2.0.tgz",
          "integrity": "sha512-0yayqDxWQbqk3ojkYqUKqaAQ6AfNKeKWRNA8kR0WXzAsdHpP4BIaOmMAG87JGuO6qcobyW4GjxHd9PmhEd+T9w==",
          "dev": true,
          "requires": {
            "string-width": "^1.0.1",
            "strip-ansi": "^3.0.1",
            "wrap-ansi": "^2.0.0"
          }
        },
        "wrap-ansi": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
          "integrity": "sha512-vAaEaDM946gbNpH5pLVNR+vX2ht6n0Bt3GXwVB1AuAqZosOvHNF3P7wDnh8KLkSqgUh0uh77le7Owgoz+Z9XBw==",
          "dev": true,
          "requires": {
            "string-width": "^1.0.1",
            "strip-ansi": "^3.0.1"
          }
        },
        "y18n": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/y18n/-/y18n-3.2.2.tgz",
          "integrity": "sha512-uGZHXkHnhF0XeeAPgnKfPv1bgKAYyVvmNL1xlKsPYZPaIHxGti2hHqvOCQv71XMsLxu1QjergkqogUnms5D3YQ==",
          "dev": true
        }
      }
    },
    "yargs-parser": {
      "version": "20.2.9",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.9.tgz",
      "integrity": "sha512-y11nGElTIV+CT3Zv9t7VKl+Q3hTQoT9a1Qzezhhl6Rp21gJ/IVTW7Z3y9EWXhuUBC2Shnf+DX0antecpAwSP8w==",
      "dev": true
    }
  }
}

--- END FILE: .\package-lock.json ---


--- START FILE: .\package.json ---
{
  "name": "paint-by-numbers-generator",
  "version": "1.0.0",
  "description": "Paint by numbers generator",
  "bin": "./src-cli/main.js",
  "scripts": {
    "lite": "lite-server --port 10001",
    "start": "npm run lite"
  },
  "author": "drake7707",
  "devDependencies": {
    "@types/node": "^12.7.1",
    "lite-server": "^1.3.1"
  },
  "dependencies": {
    "@types/jquery": "^3.3.31",
    "@types/materialize-css": "^1.0.6",
    "@types/minimist": "^1.2.0",
    "canvas": "2.5.0",
    "minimist": "^1.2.3",
    "svg2img": "^0.6.1"
  }
}

--- END FILE: .\package.json ---


--- START FILE: .\PBN_Istzustand_vs_Original.md ---
# PaintByNumbersGenerator â†’ LaserGRBL Export: **Ist-Zustand** vs. Original-Repo

**Zweck dieses Dokuments:**
- Beschreibt **den aktuellen Ist-Zustand** deines Setups **im Vergleich** zum Original-Repo.
- Fokus auf **Was ist anders?** und **Warum wurde es geÃ¤ndert?**
- Ohne â€žPatch-Schritt-fÃ¼r-Schrittâ€œ (damit es nicht verwirrt).

---

## 1) Referenz: Wie das Original-Repo funktioniert (Web)

Im Original-Web-UI ist der SVG-Download Ã¼ber den Button **`#btnDownloadSVG`** verdrahtet. Dieser Button ruft die Download-Funktion aus dem GUI-Code auf. îˆ€citeîˆ‚turn7search54îˆ  
Der ursprÃ¼ngliche Download speichert das aktuell gerenderte SVG aus `#svgContainer` und nutzt als Dateiname standardmÃ¤ÃŸig **`paintbynumbers.svg`**. îˆ€citeîˆ‚turn2search51îˆ  

ZusÃ¤tzlich existiert im Repo neben TypeScript-Quellen (`src/*`) auch ein vorkompilierter Web-Build (`dist/*`), der je nach Start-/Deploy-Setup genutzt werden kann. îˆ€citeîˆ‚turn8search56îˆ‚turn9search73îˆ

---

## 2) Zielbild (Warum Ã¼berhaupt Ã¤ndern?)

Du willst das Tool nicht nur als â€žPaint by Numbersâ€œ-Generator nutzen, sondern als **LaserGRBL-Inputquelle**.

### Anforderungen
1. **Zwei Dateien statt einer:**
   - **`preview.svg`**: Vorschau/Print â€“ Farben optional, so wie im Browser sichtbar
   - **`laser.svg`**: Laser-Datei â€“ **nur Umrandung + Zahlen**, keine FlÃ¤chenfÃ¼llung
2. **Zahlen 0â€“50 als Single-Line (Centerline) Vektoren** (Laser soll eine Linie fahren, nicht eine Kontur â€žumrandenâ€œ)
3. **LaserGRBL-KompatibilitÃ¤t:** Import darf keine Elemente enthalten, die LaserGRBL typischerweise ignoriert oder falsch interpretiert.

---

## 3) Ist-Zustand: Was ist heute anders als im Original?

### 3.1 Zwei Export-Modi (Preview vs. Laser)
**Original:** Ein SVG-Export (Dateiname typischerweise `paintbynumbers.svg`). îˆ€citeîˆ‚turn2search51îˆ  
**Ist:** Zwei getrennte Exporte:
- **`preview.svg`** wird aus dem aktuellen DOM-SVG (`#svgContainer svg`) erzeugt â€“ also genau das, was du siehst.
- **`laser.svg`** wird aus dem gleichen Ausgangs-SVG abgeleitet, aber anschlieÃŸend â€žlaser-tauglichâ€œ transformiert.

### 3.2 Runtime-Integration statt Build-AbhÃ¤ngigkeit
**Original:** Ã„nderungen an `src/*` mÃ¼ssten zuverlÃ¤ssig in den ausgerollten Web-Build gelangen.

**Ist:** Eine zusÃ¤tzliche JavaScript-Datei (**`laser-export.js`**) wird in die Seite eingebunden und erweitert die UI zur Laufzeit:
- Sie hÃ¤ngt sich an den existierenden Download-Button `#btnDownloadSVG` (der im Original verdrahtet ist). îˆ€citeîˆ‚turn7search54îˆ  
- Sie fÃ¼gt einen zweiten Button (â€žDownload Laser SVGâ€œ) hinzu.

**Warum das so gelÃ¶st ist:** Weil das Repo sowohl `src/*` als auch `dist/*` enthÃ¤lt und `npm start`/Deploy je nach Setup aus `dist/` serven kann. Die Runtime-LÃ¶sung ist **unabhÃ¤ngig von der Toolchain** und greift sicher. îˆ€citeîˆ‚turn8search56îˆ‚turn9search73îˆ

### 3.3 Laser-spezifische SVG-Bereinigung (entscheidend)
**Ist:** Beim Export von `laser.svg` werden diese Transformationen angewendet:

1) **Single-Line Zahlen statt Text/Outlines**
- Ziffern 0â€“50 werden als **Single-Line Pfade** generiert (Stroke-Font) statt `<text>`.
- Hintergrund: `<text>` wird von Laser-Tools oft als Font/Outline interpretiert oder anders gerendert als im Browser.

2) **Fills entfernen (â€žnur Strokesâ€œ)**
- Alles, was nur FlÃ¤che ist (Fill ohne Stroke), wird entfernt.
- Bei Elementen mit Stroke+Fill wird `fill="none"` gesetzt.
- Ergebnis: Laser fÃ¤hrt **nur Linien** (Umrandung + Zahlen).

3) **Nested `<svg>` flachmachen (Flatten)**
- Viele Laser/CAM-Importer ignorieren verschachtelte `<svg>`-Elemente.
- Deshalb werden nested `<svg>` in `<g transform="...">` umgewandelt.

4) **VollstÃ¤ndiges Transform-Baking (Skalierung & Zentrierung korrekt)**
- LaserGRBL interpretiert Transform-Ketten (`translate/scale`) teilweise anders als der Browser.
- Daher wird die **komplette Transform-Kette** (inkl. aller Vorfahren-Transforms, auch aus dem Flattening) in die Pfad-Koordinaten â€žeingebackenâ€œ.
- Danach sind Label-Pfade **ohne `transform=`** â€“ nur noch â€žabsoluteâ€œ Koordinaten.

5) **Stroke-Normalisierung**
- Strokes werden fÃ¼r `laser.svg` auf `#000` vereinheitlicht (LaserGRBL-freundlich, konsistent).

### 3.4 â€žMehr Liebeâ€œ fÃ¼r die Ziffern
**Ist:** Die Ziffern-Glyphen wurden optisch verbessert (runder, besser proportioniert), damit sie in Gravur/Plot sauberer aussehen.

---

## 4) Warum genau diese Ã„nderungen (BegrÃ¼ndung nach Problemklassen)

### Problemklasse A: LaserGRBL zeigt Labels nicht
**Ursache:** Nested `<svg>` bei Labels â†’ wird von Importern oft ignoriert.
**LÃ¶sung:** Flatten nested `<svg>`.

### Problemklasse B: Spiegelverkehrt / driftende Position
**Ursache:** Unterschiedliche `transform`-Interpretation im Importer.
**LÃ¶sung:** VollstÃ¤ndiges Transform-Baking und Entfernen von `transform=` bei Label-Pfaden.

### Problemklasse C: Laser fÃ¤hrt â€žKonturenâ€œ statt Single-Line
**Ursache:** `<text>` und Outline-Fonts sind keine Centerline-Geometrie.
**LÃ¶sung:** Single-Line Stroke-Font (Ziffern 0â€“50 als Pfade).

### Problemklasse D: Laser fÃ¼llt FlÃ¤chen / unnÃ¶tige Fahrwege
**Ursache:** Facets haben `fill` (Farben) â€“ sinnvoll fÃ¼r Vorschau, schlecht fÃ¼r Laser.
**LÃ¶sung:** Fills entfernen und nur Strokes exportieren.

---

## 5) Bedienung im Ist-Zustand

### Preview
- Output-Tab: Farben nach Bedarf (Fill facets optional)
- Export: **`preview.svg`**

### Laser
- Export: **`laser.svg`**
- Inhalt: **nur** Umrandung + Single-Line Zahlen

### Tuning
- Ein kleines Feld â€žLaser strokeâ€œ erlaubt Anpassung der Label-LinienstÃ¤rke (typisch: 0.25â€“0.6 je nach Material).

---

## 6) Was bei Fehlern zuerst prÃ¼fen (Kurz-Checkliste)

1. **Sind in `laser.svg` noch nested `<svg>` enthalten?**
   - Wenn ja: Flatten greift nicht â†’ LaserGRBL kann Labels â€žverschluckenâ€œ.
2. **Haben Label-Pfade noch `transform=`?**
   - Wenn ja: Transform-Baking greift nicht â†’ Risiko fÃ¼r Spiegelung/Versatz.
3. **Gibt es noch `fill` oder `style="...fill:`?**
   - Wenn ja: Fills wurden nicht entfernt â†’ Laser kann FlÃ¤chen â€žfalschâ€œ behandeln.
4. **EnthÃ¤lt `laser.svg` Ã¼berhaupt `<path>` fÃ¼r Zahlen?**
   - Wenn nicht: Single-Line Conversion greift nicht.

---

## 7) Kontext-Summary fÃ¼r neue Chats (Copy/Paste)

- Projekt: **paintbynumbersgenerator (Web)**, Start via **`npm start`**.
- Ziel: **`preview.svg`** (Vorschau, Farben optional) + **`laser.svg`** (nur Umrandung + Single-Line-Zahlen).
- Laser-Import: **LaserGRBL**.
- Zahlenbereich: **0â€“50**.
- Ist-Zustand unterscheidet sich vom Original:
  - UI bietet zwei Exporte (preview/laser) statt `paintbynumbers.svg`. îˆ€citeîˆ‚turn2search51îˆ
  - Runtime-Datei `laser-export.js` erweitert den bestehenden Download-Button `#btnDownloadSVG`. îˆ€citeîˆ‚turn7search54îˆ
  - Laser-Export macht: Single-Line-Zahlen, Fills raus, nested `<svg>` flatten, komplette Transforms baken (keine `transform=` in Label-Pfaden), Stroke `#000`.


--- END FILE: .\PBN_Istzustand_vs_Original.md ---


--- START FILE: .\README.md ---
# Paint by numbers generator
Generate paint by number images (vectorized with SVG) from any input image. Orginal from https://github.com/drake7707/paintbynumbersgenerator. Trying to make some some changes.

*** This project was a proof of concept for fun back in the day, it is not being actively maintained but feel free to fork and make your own changes.  ***

## Demo

Try it out [here](https://drake7707.github.io/paintbynumbersgenerator/index.html)

### CLI Version

The CLI version is a self contained node application that does the conversion from arguments, for example:
```
paint-by-numbers-generator-win.exe -i input.png -o output.svg
```
You can change the settings in settings.json or optionally specify a specific settings.json with the `-c path_to_settings.json` argument.

The settings contain mostly the same settings in the web version:
 - randomSeed: the random seed to choose the initial starting points of the k-means clustering algorithm. This ensures that the same results are generated each time.
 - kMeansNrOfClusters: the number of colors to quantize the image to
 - kMeansMinDeltaDifference: the threshold delta distance of the k-means clustering to reach before stopping. Having a bigger value will speed up the clustering but may yield suboptimal clusters. Default 1
 - kMeansClusteringColorSpace: the color space to apply clustering in
 - kMeansColorRestrictions: Specify which colors should be used. An array of rgb values (as number array) or names of colors (reference to color aliases). If no colors are specified no restrictions are applied. Useful if you only have a few colors of paint on hand.
 - colorAliases: map of key/values where the keys are the color names and the values are the rgb colors (as number array). You can use the color names in the color restrictions above. The names are also mentioned in the output json that tells you how much % of the area is of that specific color.
       ```
       "colorAliases": {
              "A1": [            0,            0,            0        ],
              "A2": [            255,            0,            0        ],
              "A3": [            0,            255,            0        ],
          }
        ```
 - removeFacetsSmallerThanNrOfPoints: removes any facets that are smaller than the given amount of pixels. Lowering the value will create more detailed results but might be much harder to actually paint due to their size.
 - removeFacetsFromLargeToSmall (true/false): largest to smallest will prevent boundaries from warping the shapes because the smaller facets act as border anchorpoints but can be considerably slower
 - maximumNumberOfFacets: if there are more facets than the given maximum number, keep removing the smallest facets until the limit is reached
 
 - nrOfTimesToHalveBorderSegments: reducing the amount of points in a border segment (using haar wavelet reduction) will smooth out the quadratic curve more but at a loss of detail. A segment (shared border with a facet) will always retain its start and end point.
 
 - narrowPixelStripCleanupRuns: narrow pixel cleanup removes strips of single pixel rows, which would make some facets have some borders segments that are way too narrow to be useful. The small facet removal can introduce new narrow pixel strips, so this is repeated in a few iterative runs.
 
 - resizeImageIfTooLarge (true/false): if true and the input image is larger than the given dimensions then it will be resized to fit but will maintain its ratio.
 - resizeImageWidth: width restriction
 - resizeImageHeight: height restriction

There are also output profiles that you can define to output the result to svg, png, jpg with specific settings, for example:
```
  "outputProfiles": [
        {
            "name": "full",
            "svgShowLabels": true,
            "svgFillFacets": true,
            "svgShowBorders": true,
            "svgSizeMultiplier": 3,
            "svgFontSize": 50,
            "svgFontColor": "#333",
            "filetype": "png"
        },
        {
            "name": "bordersLabels",
            "svgShowLabels": true,
            "svgFillFacets": false,
            "svgShowBorders": true,
            "svgSizeMultiplier": 3,
            "svgFontSize": 50,
            "svgFontColor": "#333",
            "filetype": "svg"
        },
        {
            "name": "jpgtest",
            "svgShowLabels": false,
            "svgFillFacets": true,
            "svgShowBorders": false,
            "svgSizeMultiplier": 3,
            "svgFontSize": 50,
            "svgFontColor": "#333",
            "filetype": "jpg",
            "filetypeQuality": 80
        }
    ]
```
This defines 3 output profiles. The "full" profile shows labels, fills the facets and shows the borders with a 3x size multiplier, font size weight of 50, color of #333 and output to a png image. The bordersLabels profile outputs to a svg file without filling facets and jpgtest outputs to a jpg file with jpg quality setting  of 80.

The CLI version also outputs a json file that gives more information about the palette, which colors are used and in what quantity, e.g.:
```
  ...
  {
    "areaPercentage": 0.20327615489130435,
    "color": [ 59, 36, 27 ],
    "frequency": 119689,
    "index": 0
  },
   ...
```

The CLI version is useful if you want to automate the process into your own scripts.

## Screenshots

![Screenshot](https://i.imgur.com/6uHm78x.png])

![Screenshot](https://i.imgur.com/cY9ieAy.png)


## Example output

![ExampleOutput](https://i.imgur.com/2Zuo13d.png)

![ExampleOutput2](https://i.imgur.com/SxWhOc7.png)

## Running locally

I used VSCode, which has built in typescript support. To debug it uses a tiny webserver to host the files on localhost. 

To run do `npm install` to restore packages and then `npm start` to start the webserver


## Compiling the cli version

Install pkg first if you don't have it yet `npm install pkg -g`. Then in the root folder run `pkg .`. This will generate the output for linux, windows and macos.

--- END FILE: .\README.md ---


--- START FILE: .\report.20260112.225834.29868.0.001.json ---

{
  "header": {
    "reportVersion": 1,
    "event": "Allocation failed - JavaScript heap out of memory",
    "trigger": "FatalError",
    "filename": "report.20260112.225834.29868.0.001.json",
    "dumpEventTime": "2026-01-12T22:58:34Z",
    "dumpEventTimeStamp": "1768255114974",
    "processId": 29868,
    "cwd": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "commandLine": [
      "node",
      "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin\\\\..\\lite-server\\bin\\lite-server",
      "--port",
      "10001"
    ],
    "nodejsVersion": "v12.7.0",
    "wordSize": 64,
    "arch": "x64",
    "platform": "win32",
    "componentVersions": {
      "node": "12.7.0",
      "v8": "7.5.288.22-node.16",
      "uv": "1.30.1",
      "zlib": "1.2.11",
      "brotli": "1.0.7",
      "ares": "1.15.0",
      "modules": "72",
      "nghttp2": "1.39.1",
      "napi": "4",
      "llhttp": "1.1.4",
      "http_parser": "2.8.0",
      "openssl": "1.1.1c",
      "cldr": "35.1",
      "icu": "64.2",
      "tz": "2019a",
      "unicode": "12.1"
    },
    "release": {
      "name": "node",
      "headersUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0-headers.tar.gz",
      "sourceUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0.tar.gz",
      "libUrl": "https://nodejs.org/download/release/v12.7.0/win-x64/node.lib"
    },
    "osName": "Windows_NT",
    "osRelease": "10.0.26200",
    "osVersion": "Windows 10 Pro",
    "osMachine": "x86_64",
    "cpus": [
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14090093,
        "nice": 0,
        "sys": 23559062,
        "idle": 289454281,
        "irq": 2935343
      }
    ],
    "host": "PC-J"
  },
  "javascriptStack": {
    "message": "No stack.",
    "stack": [
      "Unavailable."
    ]
  },
  "nativeStack": [
    {
      "pc": "0x00007ff6f2616b89",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+10841"
    },
    {
      "pc": "0x00007ff6f261a4fc",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+25548"
    },
    {
      "pc": "0x00007ff6f26194a8",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+21368"
    },
    {
      "pc": "0x00007ff6f27033db",
      "symbol": "v8::base::CPU::has_sse+37691"
    },
    {
      "pc": "0x00007ff6f2eea3de",
      "symbol": "v8::Isolate::ReportExternalAllocationLimitReached+94"
    },
    {
      "pc": "0x00007ff6f2ed272a",
      "symbol": "v8::SharedArrayBuffer::Externalize+842"
    },
    {
      "pc": "0x00007ff6f2d63e3c",
      "symbol": "v8::internal::Heap::EphemeronKeyWriteBarrierFromCode+1436"
    },
    {
      "pc": "0x00007ff6f2d6bd5f",
      "symbol": "v8::internal::Heap::OldGenerationSizeOfObjects+4879"
    },
    {
      "pc": "0x00007ff6f2d62003",
      "symbol": "v8::internal::Heap::CollectGarbage+1235"
    },
    {
      "pc": "0x00007ff6f2d60894",
      "symbol": "v8::internal::Heap::AddRetainedMap+2292"
    },
    {
      "pc": "0x00007ff6f2d7f375",
      "symbol": "v8::internal::Factory::NewFillerObject+53"
    },
    {
      "pc": "0x00007ff6f2b356ed",
      "symbol": "v8::internal::interpreter::JumpTableTargetOffsets::iterator::operator=+3757"
    },
    {
      "pc": "0x00007ff6f330982d",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+614605"
    },
    {
      "pc": "0x00007ff6f327f15d",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+47613"
    },
    {
      "pc": "0x00000344e1989c73",
      "symbol": ""
    }
  ],
  "javascriptHeap": {
    "totalMemory": 2152337408,
    "totalCommittedMemory": 2152337408,
    "usedMemory": 2144986208,
    "availableMemory": 47672608,
    "memoryLimit": 2197815296,
    "heapSpaces": {
      "read_only_space": {
        "memorySize": 262144,
        "committedMemory": 262144,
        "capacity": 261832,
        "used": 31960,
        "available": 229872
      },
      "new_space": {
        "memorySize": 2097152,
        "committedMemory": 2097152,
        "capacity": 1047328,
        "used": 222728,
        "available": 824600
      },
      "old_space": {
        "memorySize": 2144743424,
        "committedMemory": 2144743424,
        "capacity": 2140203632,
        "used": 2140110712,
        "available": 92920
      },
      "code_space": {
        "memorySize": 688128,
        "committedMemory": 688128,
        "capacity": 516640,
        "used": 516640,
        "available": 0
      },
      "map_space": {
        "memorySize": 1052672,
        "committedMemory": 1052672,
        "capacity": 691840,
        "used": 691840,
        "available": 0
      },
      "large_object_space": {
        "memorySize": 3444736,
        "committedMemory": 3444736,
        "capacity": 3408872,
        "used": 3408872,
        "available": 0
      },
      "code_large_object_space": {
        "memorySize": 49152,
        "committedMemory": 49152,
        "capacity": 3456,
        "used": 3456,
        "available": 0
      },
      "new_large_object_space": {
        "memorySize": 0,
        "committedMemory": 0,
        "capacity": 1047328,
        "used": 0,
        "available": 1047328
      }
    }
  },
  "resourceUsage": {
    "userCpuSeconds": 78,
    "kernelCpuSeconds": 57.906,
    "cpuConsumptionPercent": 7.90611,
    "maxRss": 3836321792,
    "pageFaults": {
      "IORequired": 1585919,
      "IONotRequired": 0
    },
    "fsActivity": {
      "reads": 557,
      "writes": 7
    }
  },
  "libuv": [
  ],
  "environmentVariables": {
    "3DVPATH": "C:\\AMD\\Chipset_Software\\Binaries\\3D_V-Cache_Performance_Optimizer_Driver\\",
    "=C:": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "ALLUSERSPROFILE": "C:\\ProgramData",
    "APPDATA": "C:\\Users\\joshu\\AppData\\Roaming",
    "ChocolateyInstall": "C:\\ProgramData\\chocolatey",
    "ChocolateyLastPathUpdate": "134127106401206038",
    "CommonProgramFiles": "C:\\Program Files\\Common Files",
    "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files",
    "CommonProgramW6432": "C:\\Program Files\\Common Files",
    "COMPUTERNAME": "PC-J",
    "ComSpec": "C:\\WINDOWS\\system32\\cmd.exe",
    "DriverData": "C:\\Windows\\System32\\Drivers\\DriverData",
    "EFC_12024_1592913036": "1",
    "FPS_BROWSER_APP_PROFILE_STRING": "Internet Explorer",
    "FPS_BROWSER_USER_PROFILE_STRING": "Default",
    "HOME": "C:\\Users\\joshu",
    "HOMEDRIVE": "C:",
    "HOMEPATH": "\\Users\\joshu",
    "INIT_CWD": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "LOCALAPPDATA": "C:\\Users\\joshu\\AppData\\Local",
    "LOGONSERVER": "\\\\PC-J",
    "NODE": "C:\\nvm4w\\nodejs\\node.exe",
    "nodejs": "C:\\nvm4w\\nodejs",
    "NODE_EXE": "C:\\nvm4w\\nodejs\\\\node.exe",
    "NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_config_access": "",
    "npm_config_allow_same_version": "",
    "npm_config_also": "",
    "npm_config_always_auth": "",
    "npm_config_argv": "{\"remain\":[],\"cooked\":[\"run\",\"lite\"],\"original\":[\"run\",\"lite\"]}",
    "npm_config_audit": "true",
    "npm_config_audit_level": "low",
    "npm_config_auth_type": "legacy",
    "npm_config_before": "",
    "npm_config_bin_links": "true",
    "npm_config_browser": "",
    "npm_config_ca": "",
    "npm_config_cache": "C:\\Users\\joshu\\AppData\\Roaming\\npm-cache",
    "npm_config_cache_lock_retries": "10",
    "npm_config_cache_lock_stale": "60000",
    "npm_config_cache_lock_wait": "10000",
    "npm_config_cache_max": "Infinity",
    "npm_config_cache_min": "10",
    "npm_config_cafile": "",
    "npm_config_cert": "",
    "npm_config_cidr": "",
    "npm_config_color": "true",
    "npm_config_commit_hooks": "true",
    "npm_config_depth": "Infinity",
    "npm_config_description": "true",
    "npm_config_dev": "",
    "npm_config_dry_run": "",
    "npm_config_editor": "notepad.exe",
    "npm_config_engine_strict": "",
    "npm_config_fetch_retries": "2",
    "npm_config_fetch_retry_factor": "10",
    "npm_config_fetch_retry_maxtimeout": "60000",
    "npm_config_fetch_retry_mintimeout": "10000",
    "npm_config_force": "",
    "npm_config_git": "git",
    "npm_config_git_tag_version": "true",
    "npm_config_global": "",
    "npm_config_globalconfig": "C:\\nvm4w\\nodejs\\etc\\npmrc",
    "npm_config_globalignorefile": "C:\\nvm4w\\nodejs\\etc\\npmignore",
    "npm_config_global_style": "",
    "npm_config_group": "",
    "npm_config_ham_it_up": "",
    "npm_config_heading": "npm",
    "npm_config_https_proxy": "",
    "npm_config_if_present": "",
    "npm_config_ignore_prepublish": "",
    "npm_config_ignore_scripts": "",
    "npm_config_init_author_email": "",
    "npm_config_init_author_name": "",
    "npm_config_init_author_url": "",
    "npm_config_init_license": "ISC",
    "npm_config_init_module": "C:\\Users\\joshu\\.npm-init.js",
    "npm_config_init_version": "1.0.0",
    "npm_config_json": "",
    "npm_config_key": "",
    "npm_config_legacy_bundling": "",
    "npm_config_link": "",
    "npm_config_local_address": "",
    "npm_config_loglevel": "notice",
    "npm_config_logs_max": "10",
    "npm_config_long": "",
    "npm_config_maxsockets": "50",
    "npm_config_message": "%s",
    "npm_config_metrics_registry": "https://registry.npmjs.org/",
    "npm_config_node_gyp": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js",
    "npm_config_node_options": "",
    "npm_config_node_version": "12.7.0",
    "npm_config_noproxy": "",
    "npm_config_offline": "",
    "npm_config_onload_script": "",
    "npm_config_only": "",
    "npm_config_optional": "true",
    "npm_config_otp": "",
    "npm_config_package_lock": "true",
    "npm_config_package_lock_only": "",
    "npm_config_parseable": "",
    "npm_config_prefer_offline": "",
    "npm_config_prefer_online": "",
    "npm_config_prefix": "C:\\nvm4w\\nodejs",
    "npm_config_preid": "",
    "npm_config_production": "",
    "npm_config_progress": "true",
    "npm_config_proxy": "",
    "npm_config_read_only": "",
    "npm_config_rebuild_bundle": "true",
    "npm_config_registry": "https://registry.npmjs.org/",
    "npm_config_rollback": "true",
    "npm_config_save": "true",
    "npm_config_save_bundle": "",
    "npm_config_save_dev": "",
    "npm_config_save_exact": "",
    "npm_config_save_optional": "",
    "npm_config_save_prefix": "^",
    "npm_config_save_prod": "",
    "npm_config_scope": "",
    "npm_config_scripts_prepend_node_path": "warn-only",
    "npm_config_script_shell": "",
    "npm_config_searchexclude": "",
    "npm_config_searchlimit": "20",
    "npm_config_searchopts": "",
    "npm_config_searchstaleness": "900",
    "npm_config_send_metrics": "",
    "npm_config_shell": "C:\\WINDOWS\\system32\\cmd.exe",
    "npm_config_shrinkwrap": "true",
    "npm_config_sign_git_commit": "",
    "npm_config_sign_git_tag": "",
    "npm_config_sso_poll_frequency": "500",
    "npm_config_sso_type": "oauth",
    "npm_config_strict_ssl": "true",
    "npm_config_tag": "latest",
    "npm_config_tag_version_prefix": "v",
    "npm_config_timing": "",
    "npm_config_tmp": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "npm_config_umask": "0000",
    "npm_config_unicode": "",
    "npm_config_unsafe_perm": "true",
    "npm_config_update_notifier": "true",
    "npm_config_usage": "",
    "npm_config_user": "",
    "npm_config_userconfig": "C:\\Users\\joshu\\.npmrc",
    "npm_config_user_agent": "npm/6.10.0 node/v12.7.0 win32 x64",
    "npm_config_version": "",
    "npm_config_versions": "",
    "npm_config_viewer": "browser",
    "npm_execpath": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_lifecycle_event": "lite",
    "npm_lifecycle_script": "lite-server --port 10001",
    "npm_node_execpath": "C:\\nvm4w\\nodejs\\node.exe",
    "npm_package_author_name": "drake7707",
    "npm_package_bin_paint_by_numbers_generator": "./src-cli/main.js",
    "npm_package_dependencies_canvas": "2.5.0",
    "npm_package_dependencies_minimist": "^1.2.3",
    "npm_package_dependencies_svg2img": "^0.6.1",
    "npm_package_dependencies__types_jquery": "^3.3.31",
    "npm_package_dependencies__types_materialize_css": "^1.0.6",
    "npm_package_dependencies__types_minimist": "^1.2.0",
    "npm_package_description": "Paint by numbers generator",
    "npm_package_devDependencies_lite_server": "^1.3.1",
    "npm_package_devDependencies__types_node": "^12.7.1",
    "npm_package_name": "paint-by-numbers-generator",
    "npm_package_readmeFilename": "README.md",
    "npm_package_scripts_lite": "lite-server --port 10001",
    "npm_package_scripts_start": "npm run lite",
    "npm_package_version": "1.0.0",
    "NPM_PREFIX_NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "NUMBER_OF_PROCESSORS": "16",
    "NVM_HOME": "C:\\Users\\joshu\\AppData\\Local\\nvm",
    "NVM_SYMLINK": "C:\\nvm4w\\nodejs",
    "OneDrive": "C:\\Users\\joshu\\OneDrive",
    "OneDriveConsumer": "C:\\Users\\joshu\\OneDrive",
    "OS": "Windows_NT",
    "Path": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Python314\\Scripts\\;C:\\Python314\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files\\NVIDIA Corporation\\NVIDIA App\\NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\dotnet\\;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Program Files\\Arduino PLC IDE Tools\\;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs;C:\\Program Files (x86)\\Arm GNU Toolchain arm-none-eabi\\14.3 rel1\\bin;C:\\Users\\joshu\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\joshu\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs",
    "PATHEXT": ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW",
    "PROCESSOR_ARCHITECTURE": "AMD64",
    "PROCESSOR_IDENTIFIER": "AMD64 Family 25 Model 97 Stepping 2, AuthenticAMD",
    "PROCESSOR_LEVEL": "25",
    "PROCESSOR_REVISION": "6102",
    "ProgramData": "C:\\ProgramData",
    "ProgramFiles": "C:\\Program Files",
    "ProgramFiles(x86)": "C:\\Program Files (x86)",
    "ProgramW6432": "C:\\Program Files",
    "PROMPT": "$P$G",
    "PSModulePath": "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules",
    "PUBLIC": "C:\\Users\\Public",
    "SESSIONNAME": "Console",
    "SystemDrive": "C:",
    "SystemRoot": "C:\\WINDOWS",
    "TEMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "TMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "URL": "http://localhost:10001",
    "USERDOMAIN": "PC-J",
    "USERDOMAIN_ROAMINGPROFILE": "PC-J",
    "USERNAME": "joshu",
    "USERPROFILE": "C:\\Users\\joshu",
    "windir": "C:\\WINDOWS"
  },
  "sharedObjects": [
    "C:\\nvm4w\\nodejs\\node.exe",
    "C:\\WINDOWS\\SYSTEM32\\ntdll.dll",
    "C:\\WINDOWS\\System32\\KERNEL32.DLL",
    "C:\\WINDOWS\\System32\\KERNELBASE.dll",
    "C:\\WINDOWS\\System32\\WS2_32.dll",
    "C:\\WINDOWS\\System32\\ucrtbase.dll",
    "C:\\WINDOWS\\SYSTEM32\\dbghelp.dll",
    "C:\\WINDOWS\\System32\\RPCRT4.dll",
    "C:\\WINDOWS\\System32\\combase.dll",
    "C:\\WINDOWS\\System32\\ADVAPI32.dll",
    "C:\\WINDOWS\\System32\\OLEAUT32.dll",
    "C:\\WINDOWS\\System32\\msvcrt.dll",
    "C:\\WINDOWS\\System32\\msvcp_win.dll",
    "C:\\WINDOWS\\System32\\sechost.dll",
    "C:\\WINDOWS\\System32\\USER32.dll",
    "C:\\WINDOWS\\System32\\win32u.dll",
    "C:\\WINDOWS\\System32\\GDI32.dll",
    "C:\\WINDOWS\\System32\\gdi32full.dll",
    "C:\\WINDOWS\\System32\\PSAPI.DLL",
    "C:\\WINDOWS\\System32\\CRYPT32.dll",
    "C:\\WINDOWS\\SYSTEM32\\IPHLPAPI.DLL",
    "C:\\WINDOWS\\SYSTEM32\\bcrypt.dll",
    "C:\\WINDOWS\\SYSTEM32\\WINMM.dll",
    "C:\\WINDOWS\\SYSTEM32\\USERENV.dll",
    "C:\\WINDOWS\\System32\\IMM32.DLL",
    "C:\\WINDOWS\\SYSTEM32\\powrprof.dll",
    "C:\\WINDOWS\\SYSTEM32\\UMPDC.dll",
    "C:\\WINDOWS\\system32\\uxtheme.dll",
    "C:\\WINDOWS\\system32\\mswsock.dll",
    "C:\\WINDOWS\\SYSTEM32\\kernel.appcore.dll",
    "C:\\WINDOWS\\System32\\bcryptprimitives.dll",
    "C:\\WINDOWS\\SYSTEM32\\CRYPTBASE.DLL",
    "C:\\WINDOWS\\System32\\NSI.dll",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc6.DLL",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc.DLL",
    "C:\\WINDOWS\\SYSTEM32\\DNSAPI.dll",
    "C:\\Windows\\System32\\rasadhlp.dll",
    "C:\\WINDOWS\\System32\\fwpuclnt.dll",
    "C:\\WINDOWS\\system32\\napinsp.dll",
    "C:\\WINDOWS\\System32\\winrnr.dll",
    "C:\\WINDOWS\\system32\\nlansp_c.dll",
    "C:\\WINDOWS\\system32\\wshbth.dll"
  ]
}
--- END FILE: .\report.20260112.225834.29868.0.001.json ---


--- START FILE: .\report.20260112.225841.45404.0.001.json ---

{
  "header": {
    "reportVersion": 1,
    "event": "Allocation failed - JavaScript heap out of memory",
    "trigger": "FatalError",
    "filename": "report.20260112.225841.45404.0.001.json",
    "dumpEventTime": "2026-01-12T22:58:41Z",
    "dumpEventTimeStamp": "1768255121336",
    "processId": 45404,
    "cwd": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "commandLine": [
      "node",
      "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin\\\\..\\lite-server\\bin\\lite-server",
      "--port",
      "10001"
    ],
    "nodejsVersion": "v12.7.0",
    "wordSize": 64,
    "arch": "x64",
    "platform": "win32",
    "componentVersions": {
      "node": "12.7.0",
      "v8": "7.5.288.22-node.16",
      "uv": "1.30.1",
      "zlib": "1.2.11",
      "brotli": "1.0.7",
      "ares": "1.15.0",
      "modules": "72",
      "nghttp2": "1.39.1",
      "napi": "4",
      "llhttp": "1.1.4",
      "http_parser": "2.8.0",
      "openssl": "1.1.1c",
      "cldr": "35.1",
      "icu": "64.2",
      "tz": "2019a",
      "unicode": "12.1"
    },
    "release": {
      "name": "node",
      "headersUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0-headers.tar.gz",
      "sourceUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0.tar.gz",
      "libUrl": "https://nodejs.org/download/release/v12.7.0/win-x64/node.lib"
    },
    "osName": "Windows_NT",
    "osRelease": "10.0.26200",
    "osVersion": "Windows 10 Pro",
    "osMachine": "x86_64",
    "cpus": [
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093406,
        "nice": 0,
        "sys": 23560312,
        "idle": 289456078,
        "irq": 2935500
      }
    ],
    "host": "PC-J"
  },
  "javascriptStack": {
    "message": "No stack.",
    "stack": [
      "Unavailable."
    ]
  },
  "nativeStack": [
    {
      "pc": "0x00007ff6f2616b89",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+10841"
    },
    {
      "pc": "0x00007ff6f261a4fc",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+25548"
    },
    {
      "pc": "0x00007ff6f26194a8",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+21368"
    },
    {
      "pc": "0x00007ff6f27033db",
      "symbol": "v8::base::CPU::has_sse+37691"
    },
    {
      "pc": "0x00007ff6f2eea3de",
      "symbol": "v8::Isolate::ReportExternalAllocationLimitReached+94"
    },
    {
      "pc": "0x00007ff6f2ed272a",
      "symbol": "v8::SharedArrayBuffer::Externalize+842"
    },
    {
      "pc": "0x00007ff6f2d63e3c",
      "symbol": "v8::internal::Heap::EphemeronKeyWriteBarrierFromCode+1436"
    },
    {
      "pc": "0x00007ff6f2d6bd5f",
      "symbol": "v8::internal::Heap::OldGenerationSizeOfObjects+4879"
    },
    {
      "pc": "0x00007ff6f2d62003",
      "symbol": "v8::internal::Heap::CollectGarbage+1235"
    },
    {
      "pc": "0x00007ff6f2d60894",
      "symbol": "v8::internal::Heap::AddRetainedMap+2292"
    },
    {
      "pc": "0x00007ff6f2d7f375",
      "symbol": "v8::internal::Factory::NewFillerObject+53"
    },
    {
      "pc": "0x00007ff6f2b356ed",
      "symbol": "v8::internal::interpreter::JumpTableTargetOffsets::iterator::operator=+3757"
    },
    {
      "pc": "0x00007ff6f330982d",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+614605"
    },
    {
      "pc": "0x00007ff6f32a53a7",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+203847"
    },
    {
      "pc": "0x00007ff6f32d3a96",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+394038"
    },
    {
      "pc": "0x00000361b780918d",
      "symbol": ""
    }
  ],
  "javascriptHeap": {
    "totalMemory": 2152337408,
    "totalCommittedMemory": 2152337408,
    "usedMemory": 2144875032,
    "availableMemory": 47702488,
    "memoryLimit": 2197815296,
    "heapSpaces": {
      "read_only_space": {
        "memorySize": 262144,
        "committedMemory": 262144,
        "capacity": 261832,
        "used": 31960,
        "available": 229872
      },
      "new_space": {
        "memorySize": 2097152,
        "committedMemory": 2097152,
        "capacity": 1047328,
        "used": 195608,
        "available": 851720
      },
      "old_space": {
        "memorySize": 2144743424,
        "committedMemory": 2144743424,
        "capacity": 2140159360,
        "used": 2140063680,
        "available": 95680
      },
      "code_space": {
        "memorySize": 688128,
        "committedMemory": 688128,
        "capacity": 483296,
        "used": 483296,
        "available": 0
      },
      "map_space": {
        "memorySize": 1052672,
        "committedMemory": 1052672,
        "capacity": 688160,
        "used": 688160,
        "available": 0
      },
      "large_object_space": {
        "memorySize": 3444736,
        "committedMemory": 3444736,
        "capacity": 3408872,
        "used": 3408872,
        "available": 0
      },
      "code_large_object_space": {
        "memorySize": 49152,
        "committedMemory": 49152,
        "capacity": 3456,
        "used": 3456,
        "available": 0
      },
      "new_large_object_space": {
        "memorySize": 0,
        "committedMemory": 0,
        "capacity": 1047328,
        "used": 0,
        "available": 1047328
      }
    }
  },
  "resourceUsage": {
    "userCpuSeconds": 79.421,
    "kernelCpuSeconds": 56.265,
    "cpuConsumptionPercent": 18.3856,
    "maxRss": 3681632256,
    "pageFaults": {
      "IORequired": 1489949,
      "IONotRequired": 0
    },
    "fsActivity": {
      "reads": 549,
      "writes": 7
    }
  },
  "libuv": [
  ],
  "environmentVariables": {
    "3DVPATH": "C:\\AMD\\Chipset_Software\\Binaries\\3D_V-Cache_Performance_Optimizer_Driver\\",
    "=C:": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "ALLUSERSPROFILE": "C:\\ProgramData",
    "APPDATA": "C:\\Users\\joshu\\AppData\\Roaming",
    "ChocolateyInstall": "C:\\ProgramData\\chocolatey",
    "ChocolateyLastPathUpdate": "134127106401206038",
    "CommonProgramFiles": "C:\\Program Files\\Common Files",
    "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files",
    "CommonProgramW6432": "C:\\Program Files\\Common Files",
    "COMPUTERNAME": "PC-J",
    "ComSpec": "C:\\WINDOWS\\system32\\cmd.exe",
    "DriverData": "C:\\Windows\\System32\\Drivers\\DriverData",
    "EFC_12024_1592913036": "1",
    "FPS_BROWSER_APP_PROFILE_STRING": "Internet Explorer",
    "FPS_BROWSER_USER_PROFILE_STRING": "Default",
    "HOME": "C:\\Users\\joshu",
    "HOMEDRIVE": "C:",
    "HOMEPATH": "\\Users\\joshu",
    "INIT_CWD": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "LOCALAPPDATA": "C:\\Users\\joshu\\AppData\\Local",
    "LOGONSERVER": "\\\\PC-J",
    "NODE": "C:\\nvm4w\\nodejs\\node.exe",
    "nodejs": "C:\\nvm4w\\nodejs",
    "NODE_EXE": "C:\\nvm4w\\nodejs\\\\node.exe",
    "NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_config_access": "",
    "npm_config_allow_same_version": "",
    "npm_config_also": "",
    "npm_config_always_auth": "",
    "npm_config_argv": "{\"remain\":[],\"cooked\":[\"run\",\"lite\"],\"original\":[\"run\",\"lite\"]}",
    "npm_config_audit": "true",
    "npm_config_audit_level": "low",
    "npm_config_auth_type": "legacy",
    "npm_config_before": "",
    "npm_config_bin_links": "true",
    "npm_config_browser": "",
    "npm_config_ca": "",
    "npm_config_cache": "C:\\Users\\joshu\\AppData\\Roaming\\npm-cache",
    "npm_config_cache_lock_retries": "10",
    "npm_config_cache_lock_stale": "60000",
    "npm_config_cache_lock_wait": "10000",
    "npm_config_cache_max": "Infinity",
    "npm_config_cache_min": "10",
    "npm_config_cafile": "",
    "npm_config_cert": "",
    "npm_config_cidr": "",
    "npm_config_color": "true",
    "npm_config_commit_hooks": "true",
    "npm_config_depth": "Infinity",
    "npm_config_description": "true",
    "npm_config_dev": "",
    "npm_config_dry_run": "",
    "npm_config_editor": "notepad.exe",
    "npm_config_engine_strict": "",
    "npm_config_fetch_retries": "2",
    "npm_config_fetch_retry_factor": "10",
    "npm_config_fetch_retry_maxtimeout": "60000",
    "npm_config_fetch_retry_mintimeout": "10000",
    "npm_config_force": "",
    "npm_config_git": "git",
    "npm_config_git_tag_version": "true",
    "npm_config_global": "",
    "npm_config_globalconfig": "C:\\nvm4w\\nodejs\\etc\\npmrc",
    "npm_config_globalignorefile": "C:\\nvm4w\\nodejs\\etc\\npmignore",
    "npm_config_global_style": "",
    "npm_config_group": "",
    "npm_config_ham_it_up": "",
    "npm_config_heading": "npm",
    "npm_config_https_proxy": "",
    "npm_config_if_present": "",
    "npm_config_ignore_prepublish": "",
    "npm_config_ignore_scripts": "",
    "npm_config_init_author_email": "",
    "npm_config_init_author_name": "",
    "npm_config_init_author_url": "",
    "npm_config_init_license": "ISC",
    "npm_config_init_module": "C:\\Users\\joshu\\.npm-init.js",
    "npm_config_init_version": "1.0.0",
    "npm_config_json": "",
    "npm_config_key": "",
    "npm_config_legacy_bundling": "",
    "npm_config_link": "",
    "npm_config_local_address": "",
    "npm_config_loglevel": "notice",
    "npm_config_logs_max": "10",
    "npm_config_long": "",
    "npm_config_maxsockets": "50",
    "npm_config_message": "%s",
    "npm_config_metrics_registry": "https://registry.npmjs.org/",
    "npm_config_node_gyp": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js",
    "npm_config_node_options": "",
    "npm_config_node_version": "12.7.0",
    "npm_config_noproxy": "",
    "npm_config_offline": "",
    "npm_config_onload_script": "",
    "npm_config_only": "",
    "npm_config_optional": "true",
    "npm_config_otp": "",
    "npm_config_package_lock": "true",
    "npm_config_package_lock_only": "",
    "npm_config_parseable": "",
    "npm_config_prefer_offline": "",
    "npm_config_prefer_online": "",
    "npm_config_prefix": "C:\\nvm4w\\nodejs",
    "npm_config_preid": "",
    "npm_config_production": "",
    "npm_config_progress": "true",
    "npm_config_proxy": "",
    "npm_config_read_only": "",
    "npm_config_rebuild_bundle": "true",
    "npm_config_registry": "https://registry.npmjs.org/",
    "npm_config_rollback": "true",
    "npm_config_save": "true",
    "npm_config_save_bundle": "",
    "npm_config_save_dev": "",
    "npm_config_save_exact": "",
    "npm_config_save_optional": "",
    "npm_config_save_prefix": "^",
    "npm_config_save_prod": "",
    "npm_config_scope": "",
    "npm_config_scripts_prepend_node_path": "warn-only",
    "npm_config_script_shell": "",
    "npm_config_searchexclude": "",
    "npm_config_searchlimit": "20",
    "npm_config_searchopts": "",
    "npm_config_searchstaleness": "900",
    "npm_config_send_metrics": "",
    "npm_config_shell": "C:\\WINDOWS\\system32\\cmd.exe",
    "npm_config_shrinkwrap": "true",
    "npm_config_sign_git_commit": "",
    "npm_config_sign_git_tag": "",
    "npm_config_sso_poll_frequency": "500",
    "npm_config_sso_type": "oauth",
    "npm_config_strict_ssl": "true",
    "npm_config_tag": "latest",
    "npm_config_tag_version_prefix": "v",
    "npm_config_timing": "",
    "npm_config_tmp": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "npm_config_umask": "0000",
    "npm_config_unicode": "",
    "npm_config_unsafe_perm": "true",
    "npm_config_update_notifier": "true",
    "npm_config_usage": "",
    "npm_config_user": "",
    "npm_config_userconfig": "C:\\Users\\joshu\\.npmrc",
    "npm_config_user_agent": "npm/6.10.0 node/v12.7.0 win32 x64",
    "npm_config_version": "",
    "npm_config_versions": "",
    "npm_config_viewer": "browser",
    "npm_execpath": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_lifecycle_event": "lite",
    "npm_lifecycle_script": "lite-server --port 10001",
    "npm_node_execpath": "C:\\nvm4w\\nodejs\\node.exe",
    "npm_package_author_name": "drake7707",
    "npm_package_bin_paint_by_numbers_generator": "./src-cli/main.js",
    "npm_package_dependencies_canvas": "2.5.0",
    "npm_package_dependencies_minimist": "^1.2.3",
    "npm_package_dependencies_svg2img": "^0.6.1",
    "npm_package_dependencies__types_jquery": "^3.3.31",
    "npm_package_dependencies__types_materialize_css": "^1.0.6",
    "npm_package_dependencies__types_minimist": "^1.2.0",
    "npm_package_description": "Paint by numbers generator",
    "npm_package_devDependencies_lite_server": "^1.3.1",
    "npm_package_devDependencies__types_node": "^12.7.1",
    "npm_package_name": "paint-by-numbers-generator",
    "npm_package_readmeFilename": "README.md",
    "npm_package_scripts_lite": "lite-server --port 10001",
    "npm_package_scripts_start": "npm run lite",
    "npm_package_version": "1.0.0",
    "NPM_PREFIX_NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "NUMBER_OF_PROCESSORS": "16",
    "NVM_HOME": "C:\\Users\\joshu\\AppData\\Local\\nvm",
    "NVM_SYMLINK": "C:\\nvm4w\\nodejs",
    "OneDrive": "C:\\Users\\joshu\\OneDrive",
    "OneDriveConsumer": "C:\\Users\\joshu\\OneDrive",
    "OS": "Windows_NT",
    "Path": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Python314\\Scripts\\;C:\\Python314\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files\\NVIDIA Corporation\\NVIDIA App\\NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\dotnet\\;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Program Files\\Arduino PLC IDE Tools\\;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs;C:\\Program Files (x86)\\Arm GNU Toolchain arm-none-eabi\\14.3 rel1\\bin;C:\\Users\\joshu\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\joshu\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs",
    "PATHEXT": ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW",
    "PROCESSOR_ARCHITECTURE": "AMD64",
    "PROCESSOR_IDENTIFIER": "AMD64 Family 25 Model 97 Stepping 2, AuthenticAMD",
    "PROCESSOR_LEVEL": "25",
    "PROCESSOR_REVISION": "6102",
    "ProgramData": "C:\\ProgramData",
    "ProgramFiles": "C:\\Program Files",
    "ProgramFiles(x86)": "C:\\Program Files (x86)",
    "ProgramW6432": "C:\\Program Files",
    "PROMPT": "$P$G",
    "PSModulePath": "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules",
    "PUBLIC": "C:\\Users\\Public",
    "SESSIONNAME": "Console",
    "SystemDrive": "C:",
    "SystemRoot": "C:\\WINDOWS",
    "TEMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "TMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "URL": "http://localhost:10001",
    "USERDOMAIN": "PC-J",
    "USERDOMAIN_ROAMINGPROFILE": "PC-J",
    "USERNAME": "joshu",
    "USERPROFILE": "C:\\Users\\joshu",
    "windir": "C:\\WINDOWS"
  },
  "sharedObjects": [
    "C:\\nvm4w\\nodejs\\node.exe",
    "C:\\WINDOWS\\SYSTEM32\\ntdll.dll",
    "C:\\WINDOWS\\System32\\KERNEL32.DLL",
    "C:\\WINDOWS\\System32\\KERNELBASE.dll",
    "C:\\WINDOWS\\System32\\WS2_32.dll",
    "C:\\WINDOWS\\System32\\ucrtbase.dll",
    "C:\\WINDOWS\\SYSTEM32\\dbghelp.dll",
    "C:\\WINDOWS\\System32\\RPCRT4.dll",
    "C:\\WINDOWS\\System32\\combase.dll",
    "C:\\WINDOWS\\System32\\ADVAPI32.dll",
    "C:\\WINDOWS\\System32\\msvcrt.dll",
    "C:\\WINDOWS\\System32\\OLEAUT32.dll",
    "C:\\WINDOWS\\System32\\sechost.dll",
    "C:\\WINDOWS\\System32\\USER32.dll",
    "C:\\WINDOWS\\System32\\msvcp_win.dll",
    "C:\\WINDOWS\\System32\\win32u.dll",
    "C:\\WINDOWS\\System32\\GDI32.dll",
    "C:\\WINDOWS\\System32\\gdi32full.dll",
    "C:\\WINDOWS\\System32\\PSAPI.DLL",
    "C:\\WINDOWS\\System32\\CRYPT32.dll",
    "C:\\WINDOWS\\SYSTEM32\\IPHLPAPI.DLL",
    "C:\\WINDOWS\\SYSTEM32\\bcrypt.dll",
    "C:\\WINDOWS\\SYSTEM32\\USERENV.dll",
    "C:\\WINDOWS\\SYSTEM32\\WINMM.dll",
    "C:\\WINDOWS\\System32\\IMM32.DLL",
    "C:\\WINDOWS\\SYSTEM32\\powrprof.dll",
    "C:\\WINDOWS\\SYSTEM32\\UMPDC.dll",
    "C:\\WINDOWS\\system32\\uxtheme.dll",
    "C:\\WINDOWS\\system32\\mswsock.dll",
    "C:\\WINDOWS\\SYSTEM32\\kernel.appcore.dll",
    "C:\\WINDOWS\\System32\\bcryptprimitives.dll",
    "C:\\WINDOWS\\SYSTEM32\\CRYPTBASE.DLL",
    "C:\\WINDOWS\\System32\\NSI.dll",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc6.DLL",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc.DLL",
    "C:\\WINDOWS\\SYSTEM32\\DNSAPI.dll",
    "C:\\Windows\\System32\\rasadhlp.dll",
    "C:\\WINDOWS\\System32\\fwpuclnt.dll",
    "C:\\WINDOWS\\system32\\napinsp.dll",
    "C:\\WINDOWS\\System32\\winrnr.dll",
    "C:\\WINDOWS\\system32\\nlansp_c.dll",
    "C:\\WINDOWS\\system32\\wshbth.dll"
  ]
}
--- END FILE: .\report.20260112.225841.45404.0.001.json ---


--- START FILE: .\report.20260112.225848.19388.0.001.json ---

{
  "header": {
    "reportVersion": 1,
    "event": "Allocation failed - JavaScript heap out of memory",
    "trigger": "FatalError",
    "filename": "report.20260112.225848.19388.0.001.json",
    "dumpEventTime": "2026-01-12T22:58:48Z",
    "dumpEventTimeStamp": "1768255128995",
    "processId": 19388,
    "cwd": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "commandLine": [
      "node",
      "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin\\\\..\\lite-server\\bin\\lite-server",
      "--port",
      "10001"
    ],
    "nodejsVersion": "v12.7.0",
    "wordSize": 64,
    "arch": "x64",
    "platform": "win32",
    "componentVersions": {
      "node": "12.7.0",
      "v8": "7.5.288.22-node.16",
      "uv": "1.30.1",
      "zlib": "1.2.11",
      "brotli": "1.0.7",
      "ares": "1.15.0",
      "modules": "72",
      "nghttp2": "1.39.1",
      "napi": "4",
      "llhttp": "1.1.4",
      "http_parser": "2.8.0",
      "openssl": "1.1.1c",
      "cldr": "35.1",
      "icu": "64.2",
      "tz": "2019a",
      "unicode": "12.1"
    },
    "release": {
      "name": "node",
      "headersUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0-headers.tar.gz",
      "sourceUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0.tar.gz",
      "libUrl": "https://nodejs.org/download/release/v12.7.0/win-x64/node.lib"
    },
    "osName": "Windows_NT",
    "osRelease": "10.0.26200",
    "osVersion": "Windows 10 Pro",
    "osMachine": "x86_64",
    "cpus": [
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 14093796,
        "nice": 0,
        "sys": 23561140,
        "idle": 289462515,
        "irq": 2935609
      }
    ],
    "host": "PC-J"
  },
  "javascriptStack": {
    "message": "No stack.",
    "stack": [
      "Unavailable."
    ]
  },
  "nativeStack": [
    {
      "pc": "0x00007ff6f2616b89",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+10841"
    },
    {
      "pc": "0x00007ff6f261a4fc",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+25548"
    },
    {
      "pc": "0x00007ff6f26194a8",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+21368"
    },
    {
      "pc": "0x00007ff6f27033db",
      "symbol": "v8::base::CPU::has_sse+37691"
    },
    {
      "pc": "0x00007ff6f2eea3de",
      "symbol": "v8::Isolate::ReportExternalAllocationLimitReached+94"
    },
    {
      "pc": "0x00007ff6f2ed272a",
      "symbol": "v8::SharedArrayBuffer::Externalize+842"
    },
    {
      "pc": "0x00007ff6f2d63e3c",
      "symbol": "v8::internal::Heap::EphemeronKeyWriteBarrierFromCode+1436"
    },
    {
      "pc": "0x00007ff6f2d6bd5f",
      "symbol": "v8::internal::Heap::OldGenerationSizeOfObjects+4879"
    },
    {
      "pc": "0x00007ff6f2d62003",
      "symbol": "v8::internal::Heap::CollectGarbage+1235"
    },
    {
      "pc": "0x00007ff6f2d60894",
      "symbol": "v8::internal::Heap::AddRetainedMap+2292"
    },
    {
      "pc": "0x00007ff6f2d86eb3",
      "symbol": "v8::internal::Factory::NewRawOneByteString+83"
    },
    {
      "pc": "0x00007ff6f2bf922a",
      "symbol": "v8::internal::String::SlowFlatten+394"
    },
    {
      "pc": "0x00007ff6f2ab7cc0",
      "symbol": "unibrow::Utf8::EncodeOneByte+672"
    },
    {
      "pc": "0x00007ff6f2afacc8",
      "symbol": "v8::internal::DispatchTableConstructor::AddRange+3288"
    },
    {
      "pc": "0x00007ff6f330982d",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+614605"
    },
    {
      "pc": "0x000003e5cdc69cf7",
      "symbol": ""
    }
  ],
  "javascriptHeap": {
    "totalMemory": 2154434560,
    "totalCommittedMemory": 2154434560,
    "usedMemory": 2144833104,
    "availableMemory": 47672016,
    "memoryLimit": 2197815296,
    "heapSpaces": {
      "read_only_space": {
        "memorySize": 262144,
        "committedMemory": 262144,
        "capacity": 261832,
        "used": 31960,
        "available": 229872
      },
      "new_space": {
        "memorySize": 4194304,
        "committedMemory": 4194304,
        "capacity": 2094656,
        "used": 169576,
        "available": 1925080
      },
      "old_space": {
        "memorySize": 2144743424,
        "committedMemory": 2144743424,
        "capacity": 2140065360,
        "used": 2140023688,
        "available": 41672
      },
      "code_space": {
        "memorySize": 688128,
        "committedMemory": 688128,
        "capacity": 522432,
        "used": 522432,
        "available": 0
      },
      "map_space": {
        "memorySize": 1052672,
        "committedMemory": 1052672,
        "capacity": 673120,
        "used": 673120,
        "available": 0
      },
      "large_object_space": {
        "memorySize": 3444736,
        "committedMemory": 3444736,
        "capacity": 3408872,
        "used": 3408872,
        "available": 0
      },
      "code_large_object_space": {
        "memorySize": 49152,
        "committedMemory": 49152,
        "capacity": 3456,
        "used": 3456,
        "available": 0
      },
      "new_large_object_space": {
        "memorySize": 0,
        "committedMemory": 0,
        "capacity": 2094656,
        "used": 0,
        "available": 2094656
      }
    }
  },
  "resourceUsage": {
    "userCpuSeconds": 89.734,
    "kernelCpuSeconds": 65.437,
    "cpuConsumptionPercent": 14.8774,
    "maxRss": 3625881600,
    "pageFaults": {
      "IORequired": 1807835,
      "IONotRequired": 0
    },
    "fsActivity": {
      "reads": 548,
      "writes": 7
    }
  },
  "libuv": [
  ],
  "environmentVariables": {
    "3DVPATH": "C:\\AMD\\Chipset_Software\\Binaries\\3D_V-Cache_Performance_Optimizer_Driver\\",
    "=C:": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "ALLUSERSPROFILE": "C:\\ProgramData",
    "APPDATA": "C:\\Users\\joshu\\AppData\\Roaming",
    "ChocolateyInstall": "C:\\ProgramData\\chocolatey",
    "ChocolateyLastPathUpdate": "134127106401206038",
    "CommonProgramFiles": "C:\\Program Files\\Common Files",
    "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files",
    "CommonProgramW6432": "C:\\Program Files\\Common Files",
    "COMPUTERNAME": "PC-J",
    "ComSpec": "C:\\WINDOWS\\system32\\cmd.exe",
    "DriverData": "C:\\Windows\\System32\\Drivers\\DriverData",
    "EFC_12024_1592913036": "1",
    "FPS_BROWSER_APP_PROFILE_STRING": "Internet Explorer",
    "FPS_BROWSER_USER_PROFILE_STRING": "Default",
    "HOME": "C:\\Users\\joshu",
    "HOMEDRIVE": "C:",
    "HOMEPATH": "\\Users\\joshu",
    "INIT_CWD": "C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "LOCALAPPDATA": "C:\\Users\\joshu\\AppData\\Local",
    "LOGONSERVER": "\\\\PC-J",
    "NODE": "C:\\nvm4w\\nodejs\\node.exe",
    "nodejs": "C:\\nvm4w\\nodejs",
    "NODE_EXE": "C:\\nvm4w\\nodejs\\\\node.exe",
    "NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_config_access": "",
    "npm_config_allow_same_version": "",
    "npm_config_also": "",
    "npm_config_always_auth": "",
    "npm_config_argv": "{\"remain\":[],\"cooked\":[\"run\",\"lite\"],\"original\":[\"run\",\"lite\"]}",
    "npm_config_audit": "true",
    "npm_config_audit_level": "low",
    "npm_config_auth_type": "legacy",
    "npm_config_before": "",
    "npm_config_bin_links": "true",
    "npm_config_browser": "",
    "npm_config_ca": "",
    "npm_config_cache": "C:\\Users\\joshu\\AppData\\Roaming\\npm-cache",
    "npm_config_cache_lock_retries": "10",
    "npm_config_cache_lock_stale": "60000",
    "npm_config_cache_lock_wait": "10000",
    "npm_config_cache_max": "Infinity",
    "npm_config_cache_min": "10",
    "npm_config_cafile": "",
    "npm_config_cert": "",
    "npm_config_cidr": "",
    "npm_config_color": "true",
    "npm_config_commit_hooks": "true",
    "npm_config_depth": "Infinity",
    "npm_config_description": "true",
    "npm_config_dev": "",
    "npm_config_dry_run": "",
    "npm_config_editor": "notepad.exe",
    "npm_config_engine_strict": "",
    "npm_config_fetch_retries": "2",
    "npm_config_fetch_retry_factor": "10",
    "npm_config_fetch_retry_maxtimeout": "60000",
    "npm_config_fetch_retry_mintimeout": "10000",
    "npm_config_force": "",
    "npm_config_git": "git",
    "npm_config_git_tag_version": "true",
    "npm_config_global": "",
    "npm_config_globalconfig": "C:\\nvm4w\\nodejs\\etc\\npmrc",
    "npm_config_globalignorefile": "C:\\nvm4w\\nodejs\\etc\\npmignore",
    "npm_config_global_style": "",
    "npm_config_group": "",
    "npm_config_ham_it_up": "",
    "npm_config_heading": "npm",
    "npm_config_https_proxy": "",
    "npm_config_if_present": "",
    "npm_config_ignore_prepublish": "",
    "npm_config_ignore_scripts": "",
    "npm_config_init_author_email": "",
    "npm_config_init_author_name": "",
    "npm_config_init_author_url": "",
    "npm_config_init_license": "ISC",
    "npm_config_init_module": "C:\\Users\\joshu\\.npm-init.js",
    "npm_config_init_version": "1.0.0",
    "npm_config_json": "",
    "npm_config_key": "",
    "npm_config_legacy_bundling": "",
    "npm_config_link": "",
    "npm_config_local_address": "",
    "npm_config_loglevel": "notice",
    "npm_config_logs_max": "10",
    "npm_config_long": "",
    "npm_config_maxsockets": "50",
    "npm_config_message": "%s",
    "npm_config_metrics_registry": "https://registry.npmjs.org/",
    "npm_config_node_gyp": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js",
    "npm_config_node_options": "",
    "npm_config_node_version": "12.7.0",
    "npm_config_noproxy": "",
    "npm_config_offline": "",
    "npm_config_onload_script": "",
    "npm_config_only": "",
    "npm_config_optional": "true",
    "npm_config_otp": "",
    "npm_config_package_lock": "true",
    "npm_config_package_lock_only": "",
    "npm_config_parseable": "",
    "npm_config_prefer_offline": "",
    "npm_config_prefer_online": "",
    "npm_config_prefix": "C:\\nvm4w\\nodejs",
    "npm_config_preid": "",
    "npm_config_production": "",
    "npm_config_progress": "true",
    "npm_config_proxy": "",
    "npm_config_read_only": "",
    "npm_config_rebuild_bundle": "true",
    "npm_config_registry": "https://registry.npmjs.org/",
    "npm_config_rollback": "true",
    "npm_config_save": "true",
    "npm_config_save_bundle": "",
    "npm_config_save_dev": "",
    "npm_config_save_exact": "",
    "npm_config_save_optional": "",
    "npm_config_save_prefix": "^",
    "npm_config_save_prod": "",
    "npm_config_scope": "",
    "npm_config_scripts_prepend_node_path": "warn-only",
    "npm_config_script_shell": "",
    "npm_config_searchexclude": "",
    "npm_config_searchlimit": "20",
    "npm_config_searchopts": "",
    "npm_config_searchstaleness": "900",
    "npm_config_send_metrics": "",
    "npm_config_shell": "C:\\WINDOWS\\system32\\cmd.exe",
    "npm_config_shrinkwrap": "true",
    "npm_config_sign_git_commit": "",
    "npm_config_sign_git_tag": "",
    "npm_config_sso_poll_frequency": "500",
    "npm_config_sso_type": "oauth",
    "npm_config_strict_ssl": "true",
    "npm_config_tag": "latest",
    "npm_config_tag_version_prefix": "v",
    "npm_config_timing": "",
    "npm_config_tmp": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "npm_config_umask": "0000",
    "npm_config_unicode": "",
    "npm_config_unsafe_perm": "true",
    "npm_config_update_notifier": "true",
    "npm_config_usage": "",
    "npm_config_user": "",
    "npm_config_userconfig": "C:\\Users\\joshu\\.npmrc",
    "npm_config_user_agent": "npm/6.10.0 node/v12.7.0 win32 x64",
    "npm_config_version": "",
    "npm_config_versions": "",
    "npm_config_viewer": "browser",
    "npm_execpath": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_lifecycle_event": "lite",
    "npm_lifecycle_script": "lite-server --port 10001",
    "npm_node_execpath": "C:\\nvm4w\\nodejs\\node.exe",
    "npm_package_author_name": "drake7707",
    "npm_package_bin_paint_by_numbers_generator": "./src-cli/main.js",
    "npm_package_dependencies_canvas": "2.5.0",
    "npm_package_dependencies_minimist": "^1.2.3",
    "npm_package_dependencies_svg2img": "^0.6.1",
    "npm_package_dependencies__types_jquery": "^3.3.31",
    "npm_package_dependencies__types_materialize_css": "^1.0.6",
    "npm_package_dependencies__types_minimist": "^1.2.0",
    "npm_package_description": "Paint by numbers generator",
    "npm_package_devDependencies_lite_server": "^1.3.1",
    "npm_package_devDependencies__types_node": "^12.7.1",
    "npm_package_name": "paint-by-numbers-generator",
    "npm_package_readmeFilename": "README.md",
    "npm_package_scripts_lite": "lite-server --port 10001",
    "npm_package_scripts_start": "npm run lite",
    "npm_package_version": "1.0.0",
    "NPM_PREFIX_NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "NUMBER_OF_PROCESSORS": "16",
    "NVM_HOME": "C:\\Users\\joshu\\AppData\\Local\\nvm",
    "NVM_SYMLINK": "C:\\nvm4w\\nodejs",
    "OneDrive": "C:\\Users\\joshu\\OneDrive",
    "OneDriveConsumer": "C:\\Users\\joshu\\OneDrive",
    "OS": "Windows_NT",
    "Path": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\Downloads\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Python314\\Scripts\\;C:\\Python314\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files\\NVIDIA Corporation\\NVIDIA App\\NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\dotnet\\;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Program Files\\Arduino PLC IDE Tools\\;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs;C:\\Program Files (x86)\\Arm GNU Toolchain arm-none-eabi\\14.3 rel1\\bin;C:\\Users\\joshu\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\joshu\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs",
    "PATHEXT": ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW",
    "PROCESSOR_ARCHITECTURE": "AMD64",
    "PROCESSOR_IDENTIFIER": "AMD64 Family 25 Model 97 Stepping 2, AuthenticAMD",
    "PROCESSOR_LEVEL": "25",
    "PROCESSOR_REVISION": "6102",
    "ProgramData": "C:\\ProgramData",
    "ProgramFiles": "C:\\Program Files",
    "ProgramFiles(x86)": "C:\\Program Files (x86)",
    "ProgramW6432": "C:\\Program Files",
    "PROMPT": "$P$G",
    "PSModulePath": "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules",
    "PUBLIC": "C:\\Users\\Public",
    "SESSIONNAME": "Console",
    "SystemDrive": "C:",
    "SystemRoot": "C:\\WINDOWS",
    "TEMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "TMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "URL": "http://localhost:10001",
    "USERDOMAIN": "PC-J",
    "USERDOMAIN_ROAMINGPROFILE": "PC-J",
    "USERNAME": "joshu",
    "USERPROFILE": "C:\\Users\\joshu",
    "windir": "C:\\WINDOWS"
  },
  "sharedObjects": [
    "C:\\nvm4w\\nodejs\\node.exe",
    "C:\\WINDOWS\\SYSTEM32\\ntdll.dll",
    "C:\\WINDOWS\\System32\\KERNEL32.DLL",
    "C:\\WINDOWS\\System32\\KERNELBASE.dll",
    "C:\\WINDOWS\\System32\\WS2_32.dll",
    "C:\\WINDOWS\\System32\\ucrtbase.dll",
    "C:\\WINDOWS\\SYSTEM32\\dbghelp.dll",
    "C:\\WINDOWS\\System32\\RPCRT4.dll",
    "C:\\WINDOWS\\System32\\combase.dll",
    "C:\\WINDOWS\\System32\\ADVAPI32.dll",
    "C:\\WINDOWS\\System32\\OLEAUT32.dll",
    "C:\\WINDOWS\\System32\\msvcrt.dll",
    "C:\\WINDOWS\\System32\\msvcp_win.dll",
    "C:\\WINDOWS\\System32\\sechost.dll",
    "C:\\WINDOWS\\System32\\USER32.dll",
    "C:\\WINDOWS\\System32\\win32u.dll",
    "C:\\WINDOWS\\System32\\GDI32.dll",
    "C:\\WINDOWS\\System32\\gdi32full.dll",
    "C:\\WINDOWS\\System32\\PSAPI.DLL",
    "C:\\WINDOWS\\System32\\CRYPT32.dll",
    "C:\\WINDOWS\\SYSTEM32\\IPHLPAPI.DLL",
    "C:\\WINDOWS\\SYSTEM32\\USERENV.dll",
    "C:\\WINDOWS\\SYSTEM32\\bcrypt.dll",
    "C:\\WINDOWS\\SYSTEM32\\WINMM.dll",
    "C:\\WINDOWS\\System32\\IMM32.DLL",
    "C:\\WINDOWS\\SYSTEM32\\powrprof.dll",
    "C:\\WINDOWS\\SYSTEM32\\UMPDC.dll",
    "C:\\WINDOWS\\system32\\uxtheme.dll",
    "C:\\WINDOWS\\system32\\mswsock.dll",
    "C:\\WINDOWS\\SYSTEM32\\kernel.appcore.dll",
    "C:\\WINDOWS\\System32\\bcryptprimitives.dll",
    "C:\\WINDOWS\\SYSTEM32\\CRYPTBASE.DLL",
    "C:\\WINDOWS\\System32\\NSI.dll",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc6.DLL",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc.DLL",
    "C:\\WINDOWS\\SYSTEM32\\DNSAPI.dll",
    "C:\\Windows\\System32\\rasadhlp.dll",
    "C:\\WINDOWS\\System32\\fwpuclnt.dll",
    "C:\\WINDOWS\\system32\\napinsp.dll",
    "C:\\WINDOWS\\System32\\winrnr.dll",
    "C:\\WINDOWS\\system32\\nlansp_c.dll",
    "C:\\WINDOWS\\system32\\wshbth.dll"
  ]
}
--- END FILE: .\report.20260112.225848.19388.0.001.json ---


--- START FILE: .\report.20260117.142506.10308.0.001.json ---

{
  "header": {
    "reportVersion": 1,
    "event": "Allocation failed - JavaScript heap out of memory",
    "trigger": "FatalError",
    "filename": "report.20260117.142506.10308.0.001.json",
    "dumpEventTime": "2026-01-17T14:25:06Z",
    "dumpEventTimeStamp": "1768656306650",
    "processId": 10308,
    "cwd": "C:\\Users\\joshu\\OneDrive\\Dokumente\\Arduino\\CNC\\DrakeClone\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "commandLine": [
      "node",
      "C:\\Users\\joshu\\OneDrive\\Dokumente\\Arduino\\CNC\\DrakeClone\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin\\\\..\\lite-server\\bin\\lite-server",
      "--port",
      "10001"
    ],
    "nodejsVersion": "v12.7.0",
    "wordSize": 64,
    "arch": "x64",
    "platform": "win32",
    "componentVersions": {
      "node": "12.7.0",
      "v8": "7.5.288.22-node.16",
      "uv": "1.30.1",
      "zlib": "1.2.11",
      "brotli": "1.0.7",
      "ares": "1.15.0",
      "modules": "72",
      "nghttp2": "1.39.1",
      "napi": "4",
      "llhttp": "1.1.4",
      "http_parser": "2.8.0",
      "openssl": "1.1.1c",
      "cldr": "35.1",
      "icu": "64.2",
      "tz": "2019a",
      "unicode": "12.1"
    },
    "release": {
      "name": "node",
      "headersUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0-headers.tar.gz",
      "sourceUrl": "https://nodejs.org/download/release/v12.7.0/node-v12.7.0.tar.gz",
      "libUrl": "https://nodejs.org/download/release/v12.7.0/win-x64/node.lib"
    },
    "osName": "Windows_NT",
    "osRelease": "10.0.26200",
    "osVersion": "Windows 10 Pro",
    "osMachine": "x86_64",
    "cpus": [
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      },
      {
        "model": "AMD Ryzen 7 7800X3D 8-Core Processor           ",
        "speed": 4192,
        "user": 3203187,
        "nice": 0,
        "sys": 1812812,
        "idle": 19724640,
        "irq": 327921
      }
    ],
    "host": "PC-J"
  },
  "javascriptStack": {
    "message": "No stack.",
    "stack": [
      "Unavailable."
    ]
  },
  "nativeStack": [
    {
      "pc": "0x00007ff676c76b89",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+10841"
    },
    {
      "pc": "0x00007ff676c7a4fc",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+25548"
    },
    {
      "pc": "0x00007ff676c794a8",
      "symbol": "std::basic_ostream<char,std::char_traits<char> >::operator<<+21368"
    },
    {
      "pc": "0x00007ff676d633db",
      "symbol": "v8::base::CPU::has_sse+37691"
    },
    {
      "pc": "0x00007ff67754a3de",
      "symbol": "v8::Isolate::ReportExternalAllocationLimitReached+94"
    },
    {
      "pc": "0x00007ff67753272a",
      "symbol": "v8::SharedArrayBuffer::Externalize+842"
    },
    {
      "pc": "0x00007ff6773c3e3c",
      "symbol": "v8::internal::Heap::EphemeronKeyWriteBarrierFromCode+1436"
    },
    {
      "pc": "0x00007ff6773cbd5f",
      "symbol": "v8::internal::Heap::OldGenerationSizeOfObjects+4879"
    },
    {
      "pc": "0x00007ff6773c2003",
      "symbol": "v8::internal::Heap::CollectGarbage+1235"
    },
    {
      "pc": "0x00007ff6773c0894",
      "symbol": "v8::internal::Heap::AddRetainedMap+2292"
    },
    {
      "pc": "0x00007ff6773df375",
      "symbol": "v8::internal::Factory::NewFillerObject+53"
    },
    {
      "pc": "0x00007ff6771956ed",
      "symbol": "v8::internal::interpreter::JumpTableTargetOffsets::iterator::operator=+3757"
    },
    {
      "pc": "0x00007ff67796982d",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+614605"
    },
    {
      "pc": "0x00007ff67796a8f5",
      "symbol": "v8::internal::SetupIsolateDelegate::SetupHeap+618901"
    },
    {
      "pc": "0x00000099fb8c2c64",
      "symbol": ""
    }
  ],
  "javascriptHeap": {
    "totalMemory": 2151878656,
    "totalCommittedMemory": 2151878656,
    "usedMemory": 2143964792,
    "availableMemory": 48154216,
    "memoryLimit": 2197815296,
    "heapSpaces": {
      "read_only_space": {
        "memorySize": 262144,
        "committedMemory": 262144,
        "capacity": 261832,
        "used": 31960,
        "available": 229872
      },
      "new_space": {
        "memorySize": 2097152,
        "committedMemory": 2097152,
        "capacity": 1047328,
        "used": 192920,
        "available": 854408
      },
      "old_space": {
        "memorySize": 2143694848,
        "committedMemory": 2143694848,
        "capacity": 2138738224,
        "used": 2138652256,
        "available": 85968
      },
      "code_space": {
        "memorySize": 950272,
        "committedMemory": 950272,
        "capacity": 655168,
        "used": 655168,
        "available": 0
      },
      "map_space": {
        "memorySize": 1052672,
        "committedMemory": 1052672,
        "capacity": 692480,
        "used": 692480,
        "available": 0
      },
      "large_object_space": {
        "memorySize": 3772416,
        "committedMemory": 3772416,
        "capacity": 3736552,
        "used": 3736552,
        "available": 0
      },
      "code_large_object_space": {
        "memorySize": 49152,
        "committedMemory": 49152,
        "capacity": 3456,
        "used": 3456,
        "available": 0
      },
      "new_large_object_space": {
        "memorySize": 0,
        "committedMemory": 0,
        "capacity": 1047328,
        "used": 0,
        "available": 1047328
      }
    }
  },
  "resourceUsage": {
    "userCpuSeconds": 204.109,
    "kernelCpuSeconds": 208.218,
    "cpuConsumptionPercent": 5.67084,
    "maxRss": 4049899520,
    "pageFaults": {
      "IORequired": 2904778,
      "IONotRequired": 0
    },
    "fsActivity": {
      "reads": 576,
      "writes": 7
    }
  },
  "libuv": [
  ],
  "environmentVariables": {
    "3DVPATH": "C:\\AMD\\Chipset_Software\\Binaries\\3D_V-Cache_Performance_Optimizer_Driver\\",
    "=C:": "C:\\Users\\joshu\\OneDrive\\Dokumente\\Arduino\\CNC\\DrakeClone\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "ALLUSERSPROFILE": "C:\\ProgramData",
    "APPDATA": "C:\\Users\\joshu\\AppData\\Roaming",
    "ChocolateyInstall": "C:\\ProgramData\\chocolatey",
    "ChocolateyLastPathUpdate": "134127106401206038",
    "CommonProgramFiles": "C:\\Program Files\\Common Files",
    "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files",
    "CommonProgramW6432": "C:\\Program Files\\Common Files",
    "COMPUTERNAME": "PC-J",
    "ComSpec": "C:\\WINDOWS\\system32\\cmd.exe",
    "DriverData": "C:\\Windows\\System32\\Drivers\\DriverData",
    "EFC_17064_1592913036": "1",
    "FPS_BROWSER_APP_PROFILE_STRING": "Internet Explorer",
    "FPS_BROWSER_USER_PROFILE_STRING": "Default",
    "HOME": "C:\\Users\\joshu",
    "HOMEDRIVE": "C:",
    "HOMEPATH": "\\Users\\joshu",
    "INIT_CWD": "C:\\Users\\joshu\\OneDrive\\Dokumente\\Arduino\\CNC\\DrakeClone\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master",
    "LOCALAPPDATA": "C:\\Users\\joshu\\AppData\\Local",
    "LOGONSERVER": "\\\\PC-J",
    "NODE": "C:\\nvm4w\\nodejs\\node.exe",
    "nodejs": "C:\\nvm4w\\nodejs",
    "NODE_EXE": "C:\\nvm4w\\nodejs\\\\node.exe",
    "NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_config_access": "",
    "npm_config_allow_same_version": "",
    "npm_config_also": "",
    "npm_config_always_auth": "",
    "npm_config_argv": "{\"remain\":[],\"cooked\":[\"run\",\"lite\"],\"original\":[\"run\",\"lite\"]}",
    "npm_config_audit": "true",
    "npm_config_audit_level": "low",
    "npm_config_auth_type": "legacy",
    "npm_config_before": "",
    "npm_config_bin_links": "true",
    "npm_config_browser": "",
    "npm_config_ca": "",
    "npm_config_cache": "C:\\Users\\joshu\\AppData\\Roaming\\npm-cache",
    "npm_config_cache_lock_retries": "10",
    "npm_config_cache_lock_stale": "60000",
    "npm_config_cache_lock_wait": "10000",
    "npm_config_cache_max": "Infinity",
    "npm_config_cache_min": "10",
    "npm_config_cafile": "",
    "npm_config_cert": "",
    "npm_config_cidr": "",
    "npm_config_color": "true",
    "npm_config_commit_hooks": "true",
    "npm_config_depth": "Infinity",
    "npm_config_description": "true",
    "npm_config_dev": "",
    "npm_config_dry_run": "",
    "npm_config_editor": "notepad.exe",
    "npm_config_engine_strict": "",
    "npm_config_fetch_retries": "2",
    "npm_config_fetch_retry_factor": "10",
    "npm_config_fetch_retry_maxtimeout": "60000",
    "npm_config_fetch_retry_mintimeout": "10000",
    "npm_config_force": "",
    "npm_config_git": "git",
    "npm_config_git_tag_version": "true",
    "npm_config_global": "",
    "npm_config_globalconfig": "C:\\nvm4w\\nodejs\\etc\\npmrc",
    "npm_config_globalignorefile": "C:\\nvm4w\\nodejs\\etc\\npmignore",
    "npm_config_global_style": "",
    "npm_config_group": "",
    "npm_config_ham_it_up": "",
    "npm_config_heading": "npm",
    "npm_config_https_proxy": "",
    "npm_config_if_present": "",
    "npm_config_ignore_prepublish": "",
    "npm_config_ignore_scripts": "",
    "npm_config_init_author_email": "",
    "npm_config_init_author_name": "",
    "npm_config_init_author_url": "",
    "npm_config_init_license": "ISC",
    "npm_config_init_module": "C:\\Users\\joshu\\.npm-init.js",
    "npm_config_init_version": "1.0.0",
    "npm_config_json": "",
    "npm_config_key": "",
    "npm_config_legacy_bundling": "",
    "npm_config_link": "",
    "npm_config_local_address": "",
    "npm_config_loglevel": "notice",
    "npm_config_logs_max": "10",
    "npm_config_long": "",
    "npm_config_maxsockets": "50",
    "npm_config_message": "%s",
    "npm_config_metrics_registry": "https://registry.npmjs.org/",
    "npm_config_node_gyp": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js",
    "npm_config_node_options": "",
    "npm_config_node_version": "12.7.0",
    "npm_config_noproxy": "",
    "npm_config_offline": "",
    "npm_config_onload_script": "",
    "npm_config_only": "",
    "npm_config_optional": "true",
    "npm_config_otp": "",
    "npm_config_package_lock": "true",
    "npm_config_package_lock_only": "",
    "npm_config_parseable": "",
    "npm_config_prefer_offline": "",
    "npm_config_prefer_online": "",
    "npm_config_prefix": "C:\\nvm4w\\nodejs",
    "npm_config_preid": "",
    "npm_config_production": "",
    "npm_config_progress": "true",
    "npm_config_proxy": "",
    "npm_config_read_only": "",
    "npm_config_rebuild_bundle": "true",
    "npm_config_registry": "https://registry.npmjs.org/",
    "npm_config_rollback": "true",
    "npm_config_save": "true",
    "npm_config_save_bundle": "",
    "npm_config_save_dev": "",
    "npm_config_save_exact": "",
    "npm_config_save_optional": "",
    "npm_config_save_prefix": "^",
    "npm_config_save_prod": "",
    "npm_config_scope": "",
    "npm_config_scripts_prepend_node_path": "warn-only",
    "npm_config_script_shell": "",
    "npm_config_searchexclude": "",
    "npm_config_searchlimit": "20",
    "npm_config_searchopts": "",
    "npm_config_searchstaleness": "900",
    "npm_config_send_metrics": "",
    "npm_config_shell": "C:\\WINDOWS\\system32\\cmd.exe",
    "npm_config_shrinkwrap": "true",
    "npm_config_sign_git_commit": "",
    "npm_config_sign_git_tag": "",
    "npm_config_sso_poll_frequency": "500",
    "npm_config_sso_type": "oauth",
    "npm_config_strict_ssl": "true",
    "npm_config_tag": "latest",
    "npm_config_tag_version_prefix": "v",
    "npm_config_timing": "",
    "npm_config_tmp": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "npm_config_umask": "0000",
    "npm_config_unicode": "",
    "npm_config_unsafe_perm": "true",
    "npm_config_update_notifier": "true",
    "npm_config_usage": "",
    "npm_config_user": "",
    "npm_config_userconfig": "C:\\Users\\joshu\\.npmrc",
    "npm_config_user_agent": "npm/6.10.0 node/v12.7.0 win32 x64",
    "npm_config_version": "",
    "npm_config_versions": "",
    "npm_config_viewer": "browser",
    "npm_execpath": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\bin\\npm-cli.js",
    "npm_lifecycle_event": "lite",
    "npm_lifecycle_script": "lite-server --port 10001",
    "npm_node_execpath": "C:\\nvm4w\\nodejs\\node.exe",
    "npm_package_author_name": "drake7707",
    "npm_package_bin_paint_by_numbers_generator": "./src-cli/main.js",
    "npm_package_dependencies_canvas": "2.5.0",
    "npm_package_dependencies_minimist": "^1.2.3",
    "npm_package_dependencies_svg2img": "^0.6.1",
    "npm_package_dependencies__types_jquery": "^3.3.31",
    "npm_package_dependencies__types_materialize_css": "^1.0.6",
    "npm_package_dependencies__types_minimist": "^1.2.0",
    "npm_package_description": "Paint by numbers generator",
    "npm_package_devDependencies_lite_server": "^1.3.1",
    "npm_package_devDependencies__types_node": "^12.7.1",
    "npm_package_name": "paint-by-numbers-generator",
    "npm_package_readmeFilename": "README.md",
    "npm_package_scripts_lite": "lite-server --port 10001",
    "npm_package_scripts_start": "npm run lite",
    "npm_package_version": "1.0.0",
    "NPM_PREFIX_NPM_CLI_JS": "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js",
    "NUMBER_OF_PROCESSORS": "16",
    "NVM_HOME": "C:\\Users\\joshu\\AppData\\Local\\nvm",
    "NVM_SYMLINK": "C:\\nvm4w\\nodejs",
    "OneDrive": "C:\\Users\\joshu\\OneDrive",
    "OneDriveConsumer": "C:\\Users\\joshu\\OneDrive",
    "OS": "Windows_NT",
    "Path": "C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\OneDrive\\Dokumente\\Arduino\\CNC\\DrakeClone\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Users\\joshu\\AppData\\Local\\nvm\\v12.7.0\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\joshu\\OneDrive\\Dokumente\\Arduino\\CNC\\DrakeClone\\paintbynumbersgenerator-master\\paintbynumbersgenerator-master\\node_modules\\.bin;C:\\Python314\\Scripts\\;C:\\Python314\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files\\NVIDIA Corporation\\NVIDIA App\\NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\dotnet\\;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Program Files\\Arduino PLC IDE Tools\\;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs;C:\\Program Files (x86)\\Arm GNU Toolchain arm-none-eabi\\14.3 rel1\\bin;C:\\Users\\joshu\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\joshu\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\joshu\\AppData\\Local\\nvm;C:\\nvm4w\\nodejs",
    "PATHEXT": ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW",
    "PROCESSOR_ARCHITECTURE": "AMD64",
    "PROCESSOR_IDENTIFIER": "AMD64 Family 25 Model 97 Stepping 2, AuthenticAMD",
    "PROCESSOR_LEVEL": "25",
    "PROCESSOR_REVISION": "6102",
    "ProgramData": "C:\\ProgramData",
    "ProgramFiles": "C:\\Program Files",
    "ProgramFiles(x86)": "C:\\Program Files (x86)",
    "ProgramW6432": "C:\\Program Files",
    "PROMPT": "$P$G",
    "PSModulePath": "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules",
    "PUBLIC": "C:\\Users\\Public",
    "SESSIONNAME": "Console",
    "SystemDrive": "C:",
    "SystemRoot": "C:\\WINDOWS",
    "TEMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "TMP": "C:\\Users\\joshu\\AppData\\Local\\Temp",
    "URL": "http://localhost:10001",
    "USERDOMAIN": "PC-J",
    "USERDOMAIN_ROAMINGPROFILE": "PC-J",
    "USERNAME": "joshu",
    "USERPROFILE": "C:\\Users\\joshu",
    "windir": "C:\\WINDOWS"
  },
  "sharedObjects": [
    "C:\\nvm4w\\nodejs\\node.exe",
    "C:\\WINDOWS\\SYSTEM32\\ntdll.dll",
    "C:\\WINDOWS\\System32\\KERNEL32.DLL",
    "C:\\WINDOWS\\System32\\KERNELBASE.dll",
    "C:\\WINDOWS\\System32\\WS2_32.dll",
    "C:\\WINDOWS\\System32\\ucrtbase.dll",
    "C:\\WINDOWS\\SYSTEM32\\dbghelp.dll",
    "C:\\WINDOWS\\System32\\RPCRT4.dll",
    "C:\\WINDOWS\\System32\\combase.dll",
    "C:\\WINDOWS\\System32\\ADVAPI32.dll",
    "C:\\WINDOWS\\System32\\msvcrt.dll",
    "C:\\WINDOWS\\System32\\OLEAUT32.dll",
    "C:\\WINDOWS\\System32\\sechost.dll",
    "C:\\WINDOWS\\System32\\msvcp_win.dll",
    "C:\\WINDOWS\\System32\\USER32.dll",
    "C:\\WINDOWS\\System32\\win32u.dll",
    "C:\\WINDOWS\\System32\\GDI32.dll",
    "C:\\WINDOWS\\System32\\gdi32full.dll",
    "C:\\WINDOWS\\System32\\PSAPI.DLL",
    "C:\\WINDOWS\\System32\\CRYPT32.dll",
    "C:\\WINDOWS\\SYSTEM32\\IPHLPAPI.DLL",
    "C:\\WINDOWS\\SYSTEM32\\USERENV.dll",
    "C:\\WINDOWS\\SYSTEM32\\bcrypt.dll",
    "C:\\WINDOWS\\SYSTEM32\\WINMM.dll",
    "C:\\WINDOWS\\System32\\IMM32.DLL",
    "C:\\WINDOWS\\SYSTEM32\\powrprof.dll",
    "C:\\WINDOWS\\SYSTEM32\\UMPDC.dll",
    "C:\\WINDOWS\\system32\\uxtheme.dll",
    "C:\\WINDOWS\\system32\\mswsock.dll",
    "C:\\WINDOWS\\SYSTEM32\\kernel.appcore.dll",
    "C:\\WINDOWS\\System32\\bcryptprimitives.dll",
    "C:\\WINDOWS\\SYSTEM32\\CRYPTBASE.DLL",
    "C:\\WINDOWS\\System32\\NSI.dll",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc6.DLL",
    "C:\\WINDOWS\\SYSTEM32\\dhcpcsvc.DLL",
    "C:\\WINDOWS\\SYSTEM32\\DNSAPI.dll",
    "C:\\Windows\\System32\\rasadhlp.dll",
    "C:\\WINDOWS\\System32\\fwpuclnt.dll",
    "C:\\WINDOWS\\system32\\napinsp.dll",
    "C:\\WINDOWS\\System32\\winrnr.dll",
    "C:\\WINDOWS\\system32\\nlansp_c.dll",
    "C:\\WINDOWS\\system32\\wshbth.dll"
  ]
}
--- END FILE: .\report.20260117.142506.10308.0.001.json ---


--- START FILE: .\runtime-manual-recolor.js ---
/*
 * PaintByNumbersGenerator â€“ Runtime Manual Recolor v1.0
 * 
 * Enables manual recoloring of individual facets by clicking in the finished SVG.
 */

(() => {
  'use strict';

  const STATE = {
    active: false,
    facetResult: null,
    colorsByIndex: null, // The real RGB values
    selectedFacetId: null
  };

  function $(id) { return document.getElementById(id); }

  // --- UI ---
  function injectUI() {
    const parent = document.querySelector('#options-pane .collection');
    if (!parent || $('pbnManualRecolorItem')) return;

    const li = document.createElement('li');
    li.id = 'pbnManualRecolorItem';
    li.className = 'collection-item';
    
    li.innerHTML = `
      <div class="row" style="margin-bottom:0; display:flex; align-items:center;">
        <div class="col s8">
           <label style="font-size:1rem; color:#000; font-weight:500;">ðŸ–Šï¸ Recolor Facets</label>
           <p style="font-size:0.8rem; margin:0; color:#666;">
             Enable this, then click an area in the <b>output image</b> below.
           </p>
        </div>
        <div class="col s4" style="text-align:right;">
           <div class="switch">
            <label>
              Off
              <input id="chkManualRecolor" type="checkbox">
              <span class="lever"></span>
              On
            </label>
          </div>
        </div>
      </div>
    `;

    // Insert after the Protection Item (or at the end)
    const ref = $('pbnProtectionItem');
    if(ref) ref.parentNode.insertBefore(li, ref.nextSibling);
    else parent.appendChild(li);

    // Event
    $('chkManualRecolor').addEventListener('change', (e) => {
        STATE.active = e.target.checked;
        updateCursor();
    });

    // Create color picker modal
    createColorModal();
  }

  function createColorModal() {
    if($('pbnColorModal')) return;

    const div = document.createElement('div');
    div.id = 'pbnColorModal';
    div.className = 'modal';
    div.style.cssText = 'max-width: 400px; max-height: 80%;';
    
    div.innerHTML = `
      <div class="modal-content">
        <h5>Select Color</h5>
        <p>Choose a new color for the selected facet.</p>
        <div id="pbnColorGrid" style="display:flex; flex-wrap:wrap; gap:5px; justify-content:center;"></div>
      </div>
      <div class="modal-footer">
        <a href="#!" class="modal-close waves-effect waves-green btn-flat">Cancel</a>
      </div>
    `;
    
    document.body.appendChild(div);
    // Materialize Modal init
    if(M && M.Modal) M.Modal.init(div);
  }

  function updateCursor() {
    const svgContainer = $('svgContainer');
    if(!svgContainer) return;
    svgContainer.style.cursor = STATE.active ? 'pointer' : 'default';
  }

  // --- LOGIC ---

  // We need access to the data (facetResult). We patch createSVG to intercept the reference.
  function patchProcessManager() {
      if (typeof window.require !== 'function') return;

      window.require(['guiprocessmanager'], function(GUI) {
          if (!GUI || !GUI.GUIProcessManager) return;
          
          const originalCreateSVG = GUI.GUIProcessManager.createSVG;
          
          GUI.GUIProcessManager.createSVG = async function(facetResult, colorsByIndex, sizeMultiplier, fill, stroke, addColorLabels, fontSize, fontColor, onUpdate) {
              
              // STORE DATA
              STATE.facetResult = facetResult;
              STATE.colorsByIndex = colorsByIndex;
              
              // Run original
              return await originalCreateSVG.call(this, facetResult, colorsByIndex, sizeMultiplier, fill, stroke, addColorLabels, fontSize, fontColor, onUpdate);
          };
          
          console.log("âœ… GUIProcessManager patched for Manual Recolor.");
      });
  }

  function attachSvgListeners() {
      const svg = document.querySelector('#svgContainer svg');
      if(!svg) return;

      // We use event delegation on the SVG because there are thousands of paths
      svg.addEventListener('click', (e) => {
          if(!STATE.active) return;
          
          const target = e.target;
          // Check if it is a path (facet) or text (label)
          // We look for the data-facetId attribute
          let facetId = target.getAttribute('data-facetId');
          
          // If clicking on a label, we often hit <g> or <text>
          // Unfortunately labels have no DOM ID link in the original code.
          
          if (!facetId) {
             // Click was on text or border
             return; 
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          openColorPicker(parseInt(facetId));
      });
      
      // Hover effect
      svg.addEventListener('mouseover', (e) => {
          if(!STATE.active) return;
          if(e.target.tagName === 'path' && e.target.hasAttribute('data-facetId')) {
              e.target.style.opacity = '0.5';
          }
      });
      svg.addEventListener('mouseout', (e) => {
          if(!STATE.active) return;
          if(e.target.tagName === 'path') {
              e.target.style.opacity = '1';
          }
      });
  }

  function openColorPicker(facetId) {
      STATE.selectedFacetId = facetId;
      const facet = STATE.facetResult.facets[facetId];
      if(!facet) return;

      const grid = $('pbnColorGrid');
      grid.innerHTML = '';
      
      const currentColorIdx = facet.color;
      
      // Render palette
      STATE.colorsByIndex.forEach((rgb, idx) => {
          const colorStr = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
          const div = document.createElement('div');
          
          const isSelected = (idx === currentColorIdx);
          
          div.style.cssText = `
            width: 40px; height: 40px; 
            background-color: ${colorStr};
            border: ${isSelected ? '3px solid red' : '1px solid #ccc'};
            cursor: pointer;
            border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold;
            color: ${getContrastYIQ(colorStr)};
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
          `;
          
          // Show the "new number" from the palette DOM (safest source)
          const paletteDom = document.querySelectorAll('#palette .color');
          let label = idx; // Fallback: index 0..N
          if(paletteDom && paletteDom[idx]) {
              label = paletteDom[idx].innerText; // The number the user sees (1..N)
          }
          div.innerText = label;
          
          div.onclick = () => applyColorChange(facetId, idx);
          
          grid.appendChild(div);
      });

      const modal = M.Modal.getInstance($('pbnColorModal'));
      modal.open();
  }

  function applyColorChange(facetId, newColorIndex) {
      if(!STATE.facetResult) return;
      
      // 1. Change data
      STATE.facetResult.facets[facetId].color = newColorIndex;
      
      // 2. Close modal
      const modal = M.Modal.getInstance($('pbnColorModal'));
      modal.close();
      
      // 3. Re-render SVG
      window.require(['gui'], function(GUI) {
         if(GUI && GUI.updateOutput) {
             GUI.updateOutput();
             M.toast({html: 'Facet recolored!', classes: 'rounded green'});
         }
      });
  }

  // Helper
  function getContrastYIQ(rgbStr){
    const parts = rgbStr.match(/\d+/g);
    if(!parts) return 'black';
    const r = parseInt(parts[0]);
    const g = parseInt(parts[1]);
    const b = parseInt(parts[2]);
    var yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? 'black' : 'white';
  }

  // --- INIT ---
  function init() {
      setTimeout(injectUI, 1000);
      setTimeout(patchProcessManager, 2000);
      
      // SVG listeners must be reattached when the SVG is rebuilt
      const container = $('svgContainer');
      if(container) {
          const obs = new MutationObserver(() => {
              attachSvgListeners();
              updateCursor();
          });
          obs.observe(container, {childList: true});
      }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();

--- END FILE: .\runtime-manual-recolor.js ---


--- START FILE: .\runtime-protection.js ---
/*
 * PaintByNumbersGenerator â€“ Runtime Protection v3.2 (Single Interaction & Persistence)
 * 
 * Features:
 * - Interaktiver Schutz Ã¶ffnet sich nur beim ersten Bereinigungs-Durchlauf.
 * - Speichert Koordinaten der geschÃ¼tzten Bereiche, um sie in FolgedurchlÃ¤ufen (wo sich IDs Ã¤ndern) automatisch wiederzufinden.
 * - Zoom & Smart Filter inklusive.
 */

(() => {
  'use strict';

  // --- STATE ---
  const STATE = {
    enabled: false,
    isPaused: false,
    hasShownUI: false, // Neu: Merkt sich, ob wir schon gefragt haben
    
    // Daten
    protectedIds: new Set(),      // Aktuelle IDs im laufenden Step
    protectedCoords: [],          // Neu: Permanente Koordinaten {x,y} fÃ¼r FolgedurchlÃ¤ufe
    candidates: new Set(),
    ignoredIds: new Set(),
    
    // Referenzen
    facetResult: null,
    colorsByIndex: null,
    resolveFunc: null,
    
    // UI Settings
    zoomLevel: 2.0,      
    filterPercent: 50,   
    
    // Canvas
    canvas: null,
    ctx: null
  };

  // --- DOM HELPERS ---
  function $(id) { return document.getElementById(id); }

  // --- UI INTEGRATION ---
  function injectUI() {
    const parent = document.querySelector('#options-pane .collection');
    if (!parent || $('pbnProtectionItem')) return;

    const li = document.createElement('li');
    li.id = 'pbnProtectionItem';
    li.className = 'collection-item';
    
    li.innerHTML = `
      <div class="row" style="margin-bottom:0;">
        <div class="col s12">
           <label style="font-size:1rem; color:#000; font-weight:500;">ðŸ›¡ï¸ Interaktiver Detailschutz v3.2</label>
        </div>
        
        <div class="col s4" style="margin-top:10px;">
           <div class="switch">
            <label>
              Aus
              <input id="chkEnableProtection" type="checkbox">
              <span class="lever"></span>
              An
            </label>
          </div>
        </div>

        <div class="input-field col s4" style="margin-top:0;">
            <input id="txtProtectionZoom" type="number" value="2" min="1" max="10" step="0.5">
            <label for="txtProtectionZoom" class="active">Vorschau Zoom (x)</label>
        </div>

        <div class="input-field col s4" style="margin-top:0;">
            <input id="txtProtectionFilter" type="number" value="50" min="0" max="100">
            <label for="txtProtectionFilter" class="active">Filter % (Staub)</label>
        </div>
        
        <div class="col s12">
            <p style="font-size:0.8rem; margin:0; color:#666;">
            Pausiert <b>einmalig</b> beim ersten Durchlauf. <br>
            <b>Rot:</b> Wird gelÃ¶scht. <b>GrÃ¼n:</b> Gerettet (auch fÃ¼r FolgedurchlÃ¤ufe).
            </p>
        </div>
      </div>
    `;

    parent.insertBefore(li, parent.children[3]);

    // Bindings
    $('chkEnableProtection').addEventListener('change', (e) => STATE.enabled = e.target.checked);
    
    $('txtProtectionZoom').addEventListener('change', (e) => {
        STATE.zoomLevel = parseFloat(e.target.value) || 1;
        if(STATE.isPaused) drawInteractiveScreen(); 
    });

    $('txtProtectionFilter').addEventListener('change', (e) => {
        STATE.filterPercent = parseInt(e.target.value) || 0;
        if(STATE.isPaused) {
            recalcCandidates(STATE.threshold);
            drawInteractiveScreen();
        }
    });

    // Reset State wenn User "Process Image" drÃ¼ckt
    const processBtn = $('btnProcess');
    if (processBtn) {
        processBtn.addEventListener('click', () => {
            STATE.hasShownUI = false;
            STATE.protectedCoords = [];
            STATE.protectedIds.clear();
        });
    }

    const floatBtn = document.createElement('div');
    floatBtn.id = 'pbnContinueBtn';
    floatBtn.style.cssText = `
        position: fixed; bottom: 30px; right: 30px; z-index: 9999;
        display: none; padding: 15px 25px; background: #26a69a; color: white;
        font-weight: bold; font-size: 16px; border-radius: 50px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer;
        transition: transform 0.2s;
    `;
    floatBtn.innerHTML = 'Weiter <i class="material-icons" style="vertical-align:middle;">play_arrow</i>';
    floatBtn.onclick = resumeProcess;
    document.body.appendChild(floatBtn);

    const style = document.createElement('style');
    style.textContent = `
        #reduction-pane {
            overflow: auto !important;
            max-height: 80vh;
            background: #e0e0e0;
            text-align: center;
        }
        #cReduction {
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            background: white;
            image-rendering: pixelated;
        }
    `;
    document.head.appendChild(style);
}

  // --- LOGIC HELPER ---

  // Findet einen reprÃ¤sentativen Punkt (x,y) innerhalb einer Facette
  // Wird benÃ¶tigt, um die Facette in spÃ¤teren DurchlÃ¤ufen wiederzufinden
  function getRepresentativePoint(facetId, facetResult) {
      const f = facetResult.facets[facetId];
      if (!f) return null;

      // Wir scannen die Bounding Box, bis wir einen Pixel finden, der zur ID gehÃ¶rt
      for (let y = f.bbox.minY; y <= f.bbox.maxY; y++) {
          for (let x = f.bbox.minX; x <= f.bbox.maxX; x++) {
              if (facetResult.facetMap.get(x, y) === facetId) {
                  return { x, y };
              }
          }
      }
      return null;
  }

  function recalcCandidates(smallerThan) {
      if (!STATE.facetResult) return;
      STATE.candidates.clear();
      STATE.ignoredIds.clear();
      
      const minSize = Math.floor(smallerThan * (STATE.filterPercent / 100));

      for (const f of STATE.facetResult.facets) {
          if (!f) continue;
          if (f.pointCount < smallerThan) {
              if (f.pointCount < minSize) {
                  STATE.ignoredIds.add(f.id); 
              } else {
                  STATE.candidates.add(f.id);
              }
          }
      }
      
      const btn = $('pbnContinueBtn');
      if(btn) btn.innerHTML = `Weiter (${STATE.candidates.size} Bereiche lÃ¶schen) <i class="material-icons" style="vertical-align:middle;">play_arrow</i>`;
  }

  function drawInteractiveScreen() {
    if (!STATE.canvas || !STATE.facetResult) return;
    
    const width = STATE.facetResult.width;
    const height = STATE.facetResult.height;
    const map = STATE.facetResult.facetMap;
    const colors = STATE.colorsByIndex; 
    
    const displayW = Math.floor(width * STATE.zoomLevel);
    const displayH = Math.floor(height * STATE.zoomLevel);
    
    STATE.canvas.width = displayW;
    STATE.canvas.height = displayH;
    
    STATE.ctx.scale(STATE.zoomLevel, STATE.zoomLevel);

    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = width;
    bgCanvas.height = height;
    const bgCtx = bgCanvas.getContext('2d');
    const imgData = bgCtx.createImageData(width, height);
    const data = imgData.data;

    for (let i = 0; i < width * height; i++) {
        const x = i % width;
        const y = Math.floor(i / width);
        const id = map.get(x, y);
        
        let r=255, g=255, b=255;
        
        const facet = STATE.facetResult.facets[id];
        if (facet) {
            const col = colors[facet.color]; 
            r = col[0]; g = col[1]; b = col[2];
            
            if (STATE.protectedIds.has(id)) {
                r = (r + 0) / 2; g = (g + 255) / 2; b = (b + 0) / 2;
            } else if (STATE.candidates.has(id)) {
                r = (r + 255) / 2; g = (g + 0) / 2; b = (b + 0) / 2;
            } else if (STATE.ignoredIds.has(id)) {
                r = (r + 200) / 2; g = (g + 200) / 2; b = (b + 200) / 2;
            }
        }

        const idx = i * 4;
        data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = 255;
    }
    
    bgCtx.putImageData(imgData, 0, 0);

    STATE.ctx.imageSmoothingEnabled = false;
    STATE.ctx.drawImage(bgCanvas, 0, 0);

    STATE.ctx.fillStyle = "rgba(0,0,0,0.5)"; 
    
    const drawBorders = (id, color) => {
        const f = STATE.facetResult.facets[id];
        if (!f || !f.borderPoints) return;

        STATE.ctx.fillStyle = color;
        for (const pt of f.borderPoints) {
            STATE.ctx.fillRect(pt.x, pt.y, 1, 1);
        }
    };

    STATE.candidates.forEach(id => {
        if (!STATE.protectedIds.has(id)) drawBorders(id, "rgba(200, 0, 0, 0.8)");
    });

    STATE.protectedIds.forEach(id => {
        drawBorders(id, "rgba(0, 150, 0, 0.9)");
    });
  }

  function handleCanvasClick(e) {
    if (!STATE.isPaused || !STATE.facetResult) return;

    const rect = STATE.canvas.getBoundingClientRect();
    const scaleX = STATE.canvas.width / rect.width;
    const scaleY = STATE.canvas.height / rect.height;

    const canvasX = (e.clientX - rect.left) * scaleX;
    const canvasY = (e.clientY - rect.top) * scaleY;

    const originalX = Math.floor(canvasX / STATE.zoomLevel);
    const originalY = Math.floor(canvasY / STATE.zoomLevel);

    if (originalX < 0 || originalX >= STATE.facetResult.width || originalY < 0 || originalY >= STATE.facetResult.height) return;

    const id = STATE.facetResult.facetMap.get(originalX, originalY);

    if (STATE.candidates.has(id) || STATE.ignoredIds.has(id)) {
        if (STATE.protectedIds.has(id)) {
            STATE.protectedIds.delete(id);
        } else {
            STATE.protectedIds.add(id);
        }
        requestAnimationFrame(drawInteractiveScreen);
    }
  }

  function resumeProcess() {
    if (STATE.resolveFunc) {
        // Jetzt speichern wir die Koordinaten der geschÃ¼tzten Facetten fÃ¼r spÃ¤ter
        STATE.protectedCoords = [];
        STATE.protectedIds.forEach(id => {
            const pt = getRepresentativePoint(id, STATE.facetResult);
            if (pt) STATE.protectedCoords.push(pt);
        });

        // UI Reset
        $('pbnContinueBtn').style.display = 'none';
        STATE.canvas.style.cursor = 'default';
        STATE.canvas.removeEventListener('mousedown', handleCanvasClick);
        STATE.isPaused = false;
        
        // Merken dass wir fertig sind
        STATE.hasShownUI = true;

        STATE.resolveFunc();
    }
  }

  // --- PATCH ---
  function patchFacetReducer() {
    if (typeof window.require !== 'function') return;

    window.require(['facetReducer'], function(FacetReducerModule) {
      if (!FacetReducerModule || !FacetReducerModule.FacetReducer) return;

      const FacetReducer = FacetReducerModule.FacetReducer;
      
      if (!FacetReducer._originalReduceFacets) {
        FacetReducer._originalReduceFacets = FacetReducer.reduceFacets;
      }

      FacetReducer.reduceFacets = async function(smallerThan, removeLargeToSmall, maxFacets, colors, facetResult, imgIndices, onUpdate) {
        
        if (!STATE.enabled) {
            return await FacetReducer._originalReduceFacets.call(this, smallerThan, removeLargeToSmall, maxFacets, colors, facetResult, imgIndices, onUpdate);
        }

        // --- Logik fÃ¼r Durchlauf ---
        
        STATE.facetResult = facetResult;
        STATE.colorsByIndex = colors;
        STATE.threshold = smallerThan;
        
        // Liste fÃ¼r den aktuellen Durchlauf leeren
        STATE.protectedIds.clear();

        // 1. Wenn UI noch nicht gezeigt wurde (Erster Durchlauf): Interaktion
        if (!STATE.hasShownUI) {
            console.log(`[Protection] First run. Pausing for user interaction.`);
            STATE.isPaused = true;
            
            recalcCandidates(smallerThan);

            const tabs = M.Tabs.getInstance($('tabsOutput'));
            if (tabs) tabs.select('reduction-pane');
            
            STATE.canvas = $('cReduction');
            STATE.ctx = STATE.canvas.getContext('2d');
            
            STATE.canvas.addEventListener('mousedown', handleCanvasClick);
            STATE.canvas.style.cursor = 'crosshair';

            drawInteractiveScreen();

            const btn = $('pbnContinueBtn');
            btn.style.display = 'block';
            
            // WARTEN auf User
            await new Promise(resolve => STATE.resolveFunc = resolve);
            
            if(btn) btn.innerHTML = "Verarbeite...";
            await new Promise(r => setTimeout(r, 50)); 
        } 
        // 2. Wenn UI schon gezeigt wurde (Folge-DurchlÃ¤ufe): Automatisch schÃ¼tzen
        else {
            console.log(`[Protection] Subsequent run. Auto-protecting based on coordinates.`);
            // Wir nutzen die gespeicherten Koordinaten, um die IDs im *neuen* facetResult zu finden
            // Da sich die IDs zwischen den DurchlÃ¤ufen Ã¤ndern kÃ¶nnen (Neuaufbau der Facetten)
            if (STATE.protectedCoords.length > 0) {
                STATE.protectedCoords.forEach(pt => {
                    if (pt.x < facetResult.width && pt.y < facetResult.height) {
                        const currentId = facetResult.facetMap.get(pt.x, pt.y);
                        STATE.protectedIds.add(currentId);
                    }
                });
            }
        }

        // 3. Schutz anwenden (Hack: PointCount riesig machen)
        const restoreList = [];
        STATE.protectedIds.forEach(id => {
            const facet = facetResult.facets[id];
            if (facet) {
                restoreList.push({ facet: facet, origCount: facet.pointCount });
                facet.pointCount = 999999999; 
            }
        });

        // 4. Original ausfÃ¼hren
        await FacetReducer._originalReduceFacets.call(this, smallerThan, removeLargeToSmall, maxFacets, colors, facetResult, imgIndices, onUpdate);

        // 5. Restore (damit Labels nicht explodieren oder so)
        restoreList.forEach(item => {
            if (item.facet) item.facet.pointCount = item.origCount;
        });
      };
      
      console.log("âœ… FacetReducer patched for Interactive Mode v3.2 (Single Prompt).");
    });
  }

  // --- INIT ---
  function init() {
    setTimeout(injectUI, 1000);
    setTimeout(patchFacetReducer, 2000);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();
--- END FILE: .\runtime-protection.js ---


--- START FILE: .\runtime-recolor.js ---
/*
 * PaintByNumbersGenerator â€“ Runtime Recolor v4.3 (Sync Fix + Highlighting)
 * 
 * Features:
 * 1. Live Recolor (SVG + HTML UI)
 * 2. Intelligent Sorting (White -> Chromatic -> Black)
 * 3. Stable Renumbering (Fixes sync issues between image and palette)
 * 4. Visual Connection: Hover over a color in the list to highlight it in the SVG.
 * 5. Persistence: Keeps custom colors when resizing image.
 */

(() => {
  'use strict';

  // --- STATE MANAGEMENT ---
  const STATE = {
    // Array of objects
    palette: [], 
    // Map: "originalHex" -> "newHex"
    mapping: new Map(),
    // Map: "originalIndex" (string) -> "newIndex" (number)
    indexMap: new Map() 
  };

  // --- DOM HELPERS ---
  function $(sel, root = document) { return root.querySelector(sel); }
  function $all(sel, root = document) { return Array.from(root.querySelectorAll(sel)); }

  function getSvg() {
    const c = $('#svgContainer');
    return c ? c.querySelector('svg') : null;
  }

  function injectStyles() {
    if ($('#pbn-styles')) return;
    const style = document.createElement('style');
    style.id = 'pbn-styles';
    style.textContent = `
      .pbn-highlight-path {
        stroke: #ff0000 !important;
        stroke-width: 3px !important;
        vector-effect: non-scaling-stroke;
        opacity: 0.9 !important;
      }
      .pbn-highlight-text {
        fill: #ff0000 !important;
        font-weight: bold;
        font-size: 1.2em;
      }
      .pbn-row-hover {
        background-color: #e0f2f1 !important;
        cursor: crosshair;
      }
    `;
    document.head.appendChild(style);
  }

  // --- COLOR UTILS ---
  function rgbToHex(r, g, b) {
    const to = (x) => x.toString(16).padStart(2, '0');
    return `#${to(r)}${to(g)}${to(b)}`;
  }

  function parseColorToHex(color) {
    if (!color) return null;
    const c = String(color).trim().toLowerCase();
    if (!c || c === 'none' || c === 'transparent') return null;

    if (c.startsWith('#')) {
      if (c.length === 4) return `#${c[1]}${c[1]}${c[2]}${c[2]}${c[3]}${c[3]}`;
      return c.substring(0, 7);
    }
    if (c.startsWith('rgb')) {
      const parts = c.match(/\d+/g);
      if (parts && parts.length >= 3) return rgbToHex(Number(parts[0]), Number(parts[1]), Number(parts[2]));
    }
    return null;
  }

  function hexToRgb(hex) {
    const m = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(hex);
    return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : null;
  }

  function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h *= 60;
    }
    return { h: h < 0 ? h + 360 : h, s, l };
  }

  // --- SORTING LOGIC ---
  function getCategory(h, s, l) {
    if (l > 0.90) return { order: 1, label: 'âšª WeiÃŸ / Hell' };
    if (l < 0.1) return { order: 99, label: 'âš« Schwarz / Dunkel' };
    if (s < 0.12) return { order: 90, label: 'ðŸŒ«ï¸ Grau / Neutral' };
    if (h >= 330 || h < 60) return { order: 10, label: 'ðŸŸ¡ðŸ”´ Gelb & Rot' };
    if (h >= 60 && h < 170) return { order: 20, label: 'ðŸŸ¢ GrÃ¼n & TÃ¼rkis' };
    return { order: 30, label: 'ðŸ”µðŸŸ£ Blau & Violett' };
  }

  // --- CORE ANALYSIS ---

  // Liest die ursprÃ¼ngliche Palette aus dem DOM aus
  function analyzeOriginalData() {
    const rawPalette = [];
    const tiles = $all('#palette .color');
    
    tiles.forEach(tile => {
      const bg = parseColorToHex(tile.style.backgroundColor);
      // WICHTIG: Wir holen die ID entweder aus dem Text (beim ersten Mal) oder aus dem Attribut (wenn wir es schon mal geÃ¤ndert haben)
      let nr = tile.getAttribute('data-orig-id');
      
      if (!nr) {
        nr = tile.innerText.trim();
        if (nr !== '') {
            tile.setAttribute('data-orig-id', nr); // ID festnageln
        }
      }

      if (bg && nr !== '') {
        if (!tile.hasAttribute('data-orig-bg')) {
          tile.setAttribute('data-orig-bg', bg);
        }
        
        rawPalette.push({
          id: nr, // Das ist die "wahre" ID (0-15)
          origHex: bg
        });
      }
    });
    return rawPalette;
  }

  function arePalettesEqual(oldPalette, newRawData) {
    if (!oldPalette || oldPalette.length === 0) return false;
    if (oldPalette.length !== newRawData.length) return false;

    const oldMap = new Map();
    oldPalette.forEach(p => oldMap.set(p.id, p.origHex));

    for (const newItem of newRawData) {
        if (!oldMap.has(newItem.id)) return false;
        if (oldMap.get(newItem.id) !== newItem.origHex) return false;
    }
    return true;
  }

  function refreshStateFromDom() {
    const newRawData = analyzeOriginalData();
    const isSameImage = arePalettesEqual(STATE.palette, newRawData);

    if (!isSameImage) {
        STATE.mapping.clear();
    }
    STATE.palette = newRawData;
    performResort();
  }

  function performResort() {
    // Metriken aktualisieren
    STATE.palette.forEach(item => {
        const currentHex = STATE.mapping.get(item.origHex) || item.origHex;
        const rgb = hexToRgb(currentHex) || {r:0,g:0,b:0};
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        const cat = getCategory(hsl.h, hsl.s, hsl.l);

        item.groupOrder = cat.order;
        item.groupLabel = cat.label;
        item.light = hsl.l;
    });

    // Sortieren
    STATE.palette.sort((a, b) => {
      if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
      return b.light - a.light;
    });

    // Mapping erstellen
    STATE.indexMap.clear();
    STATE.palette.forEach((item, idx) => {
      const newNr = idx + 1;
      STATE.indexMap.set(item.id, newNr);
      item.newNr = newNr;
    });

    updateRuntimeInterface();
    updateNativePalette();
    updateSvgContent();
  }

  // --- HIGHLIGHTING ---
  function toggleHighlight(originalId, originalHex, active) {
    const svg = getSvg();
    if (!svg) return;

    // 1. FlÃ¤chen highlighten (basierend auf Original-Farbe, da diese in data-orig-fill steht)
    // Wir nutzen hier den Hex-Wert, da SVG paths oft keine ID haben, aber wir haben data-orig-fill gesetzt.
    const paths = $all(`path[data-orig-fill="${originalHex}"]`, svg);
    paths.forEach(p => {
        if (active) p.classList.add('pbn-highlight-path');
        else p.classList.remove('pbn-highlight-path');
    });

    // 2. Zahlen highlighten (basierend auf Original-ID 0-15)
    const texts = $all(`text[data-orig-text="${originalId}"]`, svg);
    texts.forEach(t => {
        if (active) t.classList.add('pbn-highlight-text');
        else t.classList.remove('pbn-highlight-text');
    });
  }

  // --- UPDATE FUNCTIONS ---

  function updateRuntimeInterface() {
    const list = $('#pbnRecolorList');
    if (!list) return;
    
    const scrollPos = list.scrollTop;
    list.innerHTML = '';

    let lastLabel = '';

    STATE.palette.forEach(item => {
      const currentHex = STATE.mapping.get(item.origHex) || item.origHex;

      if (item.groupLabel !== lastLabel) {
        const h = document.createElement('div');
        h.style.cssText = 'padding:6px 0 2px 0;margin-top:5px;font-size:0.75rem;font-weight:bold;color:#666;border-bottom:1px solid #eee;';
        h.textContent = item.groupLabel;
        list.appendChild(h);
        lastLabel = item.groupLabel;
      }

      const row = document.createElement('div');
      row.className = 'pbn-row';
      row.style.cssText = 'display:flex;gap:6px;align-items:center;margin-bottom:2px;padding:2px 0;border-radius:4px;transition:background 0.2s;';

      // Mouse Events fÃ¼r Highlight
      row.addEventListener('mouseenter', () => {
          row.classList.add('pbn-row-hover');
          toggleHighlight(item.id, item.origHex, true);
      });
      row.addEventListener('mouseleave', () => {
          row.classList.remove('pbn-row-hover');
          toggleHighlight(item.id, item.origHex, false);
      });

      // Nummer
      const nr = document.createElement('div');
      nr.textContent = `#${item.newNr}`;
      nr.style.cssText = 'font-weight:bold;width:30px;text-align:right;font-size:12px;color:#333;pointer-events:none;';

      // Input
      const inp = document.createElement('input');
      inp.type = 'text';
      inp.value = currentHex;
      inp.style.cssText = `
        width:70px; height:24px; font-size:12px; border:1px solid #ccc; padding:0 4px; margin:0;
        background-color: ${currentHex};
        color: ${getContrastYIQ(currentHex)};
        text-shadow: none;
      `;
      
      inp.addEventListener('change', (e) => {
        let val = e.target.value.trim();
        if (/^[0-9a-f]{6}$/i.test(val)) val = '#' + val;
        
        const valid = parseColorToHex(val);
        if (valid) {
          STATE.mapping.set(item.origHex, valid);
        } else {
          STATE.mapping.delete(item.origHex);
        }
        
        requestAnimationFrame(() => {
            performResort();
        });
      });

      row.append(nr, inp);
      list.appendChild(row);
    });

    list.scrollTop = scrollPos;
  }

  function updateNativePalette() {
    const container = $('#palette');
    if (!container) return;

    // Nur den visuellen Inhalt leeren, nicht die Logik zerstÃ¶ren
    // Da wir aber analyzeOriginalData am Anfang machen, ist das hier okay fÃ¼r die Anzeige
    container.innerHTML = '';

    STATE.palette.forEach(item => {
      const currentHex = STATE.mapping.get(item.origHex) || item.origHex;
      
      const div = document.createElement('div');
      div.className = 'color tooltipped';
      div.style.cssText = `
        float: left; width: 40px; height: 40px; 
        border: 1px solid #AAA; border-radius: 5px; 
        text-align: center; padding: 5px; font-weight: 600; margin: 5px;
        background-color: ${currentHex};
        color: ${getContrastYIQ(currentHex)};
        text-shadow: none;
      `;
      // Hier schreiben wir die NEUE Nummer rein
      div.innerText = item.newNr;
      div.setAttribute('data-tooltip', `Original ID: ${item.id} | Hex: ${currentHex}`);
      
      // Damit analyzeOriginalData beim nÃ¤chsten Resize nicht verwirrt ist, schreiben wir die alte ID als Attribut rein
      div.setAttribute('data-orig-id', item.id);
      div.setAttribute('data-orig-bg', item.origHex);
      
      container.appendChild(div);
    });
    
    if (window.M && M.Tooltip) M.Tooltip.init($all('.tooltipped'));
  }

  function updateSvgContent() {
    const svg = getSvg();
    if (!svg) return;

    // 1. Fills aktualisieren
    $all('path, polygon, rect, circle', svg).forEach(el => {
        let hex = el.getAttribute('data-orig-fill');
        if (!hex) {
            // Beim ersten Lauf sichern
            hex = parseColorToHex(el.getAttribute('fill') || el.style.fill);
            if (hex) el.setAttribute('data-orig-fill', hex);
        }

        if (hex) {
            const newHex = STATE.mapping.get(hex);
            if (newHex) {
                el.setAttribute('fill', newHex);
                el.style.fill = newHex;
            } else {
                el.setAttribute('fill', hex);
                el.style.fill = hex;
            }
        }
    });

    // 2. Labels (Nummern) aktualisieren
    $all('text', svg).forEach(el => {
        let originalId = el.getAttribute('data-orig-text');
        
        if (!originalId) {
            // Versuchen, die ID aus dem Textinhalt zu retten, BEVOR wir ihn Ã¼berschreiben
            const textContent = el.textContent.trim();
            if (/^\d+$/.test(textContent)) {
                originalId = textContent;
                el.setAttribute('data-orig-text', originalId);
            } else {
                return;
            }
        }

        const newNr = STATE.indexMap.get(originalId);
        if (newNr !== undefined) {
            el.textContent = newNr;
        }
    });
  }

  // --- CUSTOM PNG GENERATOR ---
  function hijackDownloadButton() {
    const btn = $('#btnDownloadPalettePNG');
    if (!btn) return;

    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    newBtn.addEventListener('click', (e) => {
      e.preventDefault();
      generateCustomPalettePng();
    });
  }

  function generateCustomPalettePng() {
    const canvas = document.createElement("canvas");
    const items = STATE.palette; 

    const nrOfItemsPerRow = 5; 
    const nrRows = Math.ceil(items.length / nrOfItemsPerRow);
    
    const margin = 20;
    const cellWidth = 150;
    const cellHeight = 100;

    canvas.width = margin + nrOfItemsPerRow * (cellWidth + margin);
    canvas.height = margin + nrRows * (cellHeight + margin);
    
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.font = "bold 24px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    items.forEach((item, i) => {
      const currentHex = STATE.mapping.get(item.origHex) || item.origHex;
      
      const col = i % nrOfItemsPerRow;
      const row = Math.floor(i / nrOfItemsPerRow);

      const x = margin + col * (cellWidth + margin);
      const y = margin + row * (cellHeight + margin);

      ctx.fillStyle = currentHex;
      ctx.fillRect(x, y, cellWidth, cellHeight - 30);
      
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, cellWidth, cellHeight - 30);

      ctx.fillStyle = getContrastYIQ(currentHex);
      ctx.fillText(item.newNr, x + cellWidth / 2, y + (cellHeight - 30) / 2);

      ctx.fillStyle = "black";
      ctx.font = "14px Arial";
      ctx.fillText(currentHex, x + cellWidth / 2, y + cellHeight - 10);
      
      ctx.font = "bold 24px Arial";
    });

    const link = document.createElement('a');
    link.download = 'Mischpalette_Sortiert.png';
    link.href = canvas.toDataURL();
    link.click();
  }

  function getContrastYIQ(hexcolor){
    hexcolor = hexcolor.replace("#", "");
    var r = parseInt(hexcolor.substr(0,2),16);
    var g = parseInt(hexcolor.substr(2,2),16);
    var b = parseInt(hexcolor.substr(4,2),16);
    var yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? 'black' : 'white';
  }

  // --- INIT ---
  function ensurePanel() {
    if ($('#pbnRecolorPanel')) return;
    const anchor = $('#output-pane .row:last-child') || $('#output-pane');
    if (!anchor) return;

    const panel = document.createElement('div');
    panel.id = 'pbnRecolorPanel';
    panel.className = 'card-panel';
    panel.style.cssText = 'margin-top:20px;padding:15px;background:#fafafa;border-left:5px solid #26a69a;';
    
    panel.innerHTML = `
      <h5 style="margin-top:0;font-size:1.2rem;">ðŸŽ¨ Mischpalette & Farben</h5>
      <p style="font-size:0.8rem;color:#666;">
        Die Farben wurden automatisch nach Logik sortiert (WeiÃŸ -> Bunt -> Schwarz).<br>
        Ã„ndere die Farben hier. <b>Wichtig:</b> Die Nummern im Bild passen sich der neuen Sortierung an!
        <br><i>Tipp: Fahre mit der Maus Ã¼ber eine Farbe, um sie im Bild zu finden.</i>
      </p>
      <div id="pbnRecolorList" style="max-height:400px;overflow-y:auto;padding-right:10px;"></div>
    `;

    anchor.parentElement.appendChild(panel);
  }

  function init() {
    injectStyles();
    
    const container = $('#svgContainer');
    if (container) {
      const obs = new MutationObserver((mutations) => {
        const hasSvg = mutations.some(m => Array.from(m.addedNodes).some(n => n.nodeName === 'svg'));
        if (hasSvg) {
          setTimeout(() => {
            refreshStateFromDom(); 
            hijackDownloadButton();
          }, 500);
        }
      });
      obs.observe(container, { childList: true });
    }

    ensurePanel();
    
    if (getSvg()) {
        refreshStateFromDom();
        hijackDownloadButton();
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();
--- END FILE: .\runtime-recolor.js ---


--- START FILE: .\runtime-target-size.js ---
/*
 * PaintByNumbersGenerator â€“ Runtime extension
 * Feature: Target SVG size (mm) for preview + laser exports.
 * Default: 800 x 600 mm
 *
 * FIX v1.1 (blank/white SVG prevention):
 *  - We DO NOT auto-create/override viewBox anymore.
 *    Some builds render an <svg> without viewBox initially; if we set viewBox
 *    too early (when contents are not yet inserted), we can lock it to 0 0 0 0
 *    which makes the preview + exports appear empty/white.
 *  - We only set width/height in mm. Rendering logic of the app remains intact.
 */

(() => {
  'use strict';

  const DEFAULT_W = 800;
  const DEFAULT_H = 600;
  const LS_KEY = 'pbn_target_size_mm';

  function clamp(n, min, max) {
    n = Number(n);
    if (!Number.isFinite(n)) return min;
    return Math.min(max, Math.max(min, n));
  }

  function normalizeMm(v, fallback) {
    const n = Number(v);
    if (!Number.isFinite(n)) return fallback;
    // Keep it sane: 10mm..5000mm
    return clamp(n, 10, 5000);
  }

  function load() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return { w: DEFAULT_W, h: DEFAULT_H };
      const obj = JSON.parse(raw);
      return {
        w: normalizeMm(obj.w, DEFAULT_W),
        h: normalizeMm(obj.h, DEFAULT_H),
      };
    } catch {
      return { w: DEFAULT_W, h: DEFAULT_H };
    }
  }

  function save(w, h) {
    try {
      localStorage.setItem(LS_KEY, JSON.stringify({ w, h }));
    } catch {
      /* ignore */
    }
  }

  function ensureSettings() {
    if (!window.__pbnRuntimeSettings) window.__pbnRuntimeSettings = {};
    if (!window.__pbnRuntimeSettings.targetSizeMm) {
      const { w, h } = load();
      window.__pbnRuntimeSettings.targetSizeMm = { w, h };
    }
    return window.__pbnRuntimeSettings;
  }

  function getSvg() {
    const container = document.querySelector('#svgContainer');
    if (!container) return null;
    return container.querySelector('svg');
  }

  function applySizeToSvg(svg, wMm, hMm) {
    if (!svg) return;
    // IMPORTANT: Only set physical size. Do NOT touch viewBox.
    svg.setAttribute('width', `${wMm}mm`);
    svg.setAttribute('height', `${hMm}mm`);
  }

  function scheduleApply() {
    const settings = ensureSettings();
    const svg = getSvg();
    if (!svg) return;

    // Apply after the current render tick to avoid racing with the app's renderer.
    requestAnimationFrame(() => {
      applySizeToSvg(getSvg(), settings.targetSizeMm.w, settings.targetSizeMm.h);
    });
  }

  function injectUI() {
    const settings = ensureSettings();

    const mountCandidates = [
      '#options', '#optionsPanel', '#controls', '#divOptions',
      '.options', '.controls', '.sidebar', 'main', 'body'
    ];
    let mount = null;
    for (const sel of mountCandidates) {
      mount = document.querySelector(sel);
      if (mount) break;
    }
    if (!mount) return;

    // Avoid double injection
    if (document.querySelector('#pbnTargetSizeFieldset')) return;

    const fieldset = document.createElement('fieldset');
    fieldset.id = 'pbnTargetSizeFieldset';
    fieldset.style.cssText = 'margin:10px 0;padding:10px;border:1px solid #ccc;border-radius:6px;';

    const legend = document.createElement('legend');
    legend.textContent = 'ZielgrÃ¶ÃŸe (SVG)';
    legend.style.cssText = 'padding:0 6px;font-weight:600;';

    const row = document.createElement('div');
    row.style.cssText = 'display:flex;gap:10px;align-items:center;flex-wrap:wrap;';

    function mkNumber(label, id, value) {
      const wrap = document.createElement('label');
      wrap.style.cssText = 'display:flex;gap:6px;align-items:center;';
      wrap.setAttribute('for', id);

      const span = document.createElement('span');
      span.textContent = label;

      const input = document.createElement('input');
      input.type = 'number';
      input.id = id;
      input.min = '10';
      input.max = '5000';
      input.step = '1';
      input.value = String(value);
      input.style.cssText = 'width:90px;';

      const unit = document.createElement('span');
      unit.textContent = 'mm';
      unit.style.opacity = '0.7';

      wrap.append(span, input, unit);
      return { wrap, input };
    }

    const wCtrl = mkNumber('Breite', 'pbnTargetW', settings.targetSizeMm.w);
    const hCtrl = mkNumber('HÃ¶he', 'pbnTargetH', settings.targetSizeMm.h);

    const hint = document.createElement('div');
    hint.style.cssText = 'font-size:12px;opacity:0.75;margin-top:6px;';
    hint.textContent = 'Wirkt auf preview.svg und laser.svg Ã¼ber width/height in mm. (viewBox bleibt unverÃ¤ndert.)';

    function onChange() {
      const w = normalizeMm(wCtrl.input.value, DEFAULT_W);
      const h = normalizeMm(hCtrl.input.value, DEFAULT_H);
      settings.targetSizeMm = { w, h };
      save(w, h);
      scheduleApply();
    }

    wCtrl.input.addEventListener('input', onChange);
    hCtrl.input.addEventListener('input', onChange);

    row.append(wCtrl.wrap, hCtrl.wrap);
    fieldset.append(legend, row, hint);

    // Insert near existing download buttons if possible
    const dlBtn = document.querySelector('#btnDownloadSVG');
    if (dlBtn && dlBtn.parentElement) {
      dlBtn.parentElement.insertAdjacentElement('afterend', fieldset);
    } else {
      mount.appendChild(fieldset);
    }

    scheduleApply();
  }

  function observeSvgChanges() {
    const container = document.querySelector('#svgContainer');
    if (!container) return;

    const obs = new MutationObserver(() => {
      // Any new render: reapply size after tick
      scheduleApply();
    });

    obs.observe(container, { childList: true, subtree: true });
  }

  // Public helper for laser-export.js (read-only)
  window.__pbnGetTargetSizeMm = function __pbnGetTargetSizeMm() {
    const settings = ensureSettings();
    return { ...settings.targetSizeMm };
  };

  function init() {
    injectUI();
    observeSvgChanges();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();

--- END FILE: .\runtime-target-size.js ---


--- START FILE: .\Start-PaintByNumbers.bat ---
@echo off
setlocal EnableExtensions

REM ==========================================================
REM Start-PaintByNumbers.bat
REM - Starts the local web version (lite-server via npm start)
REM - Optionally switches to Node v12.7.0 via nvm-windows
REM - Installs dependencies on first run
REM ==========================================================

echo.
echo === Paint-by-Numbers Generator: Local Start ===
echo.

REM Go to the folder where this .bat file is located (project root)
pushd "%~dp0" || (echo [ERROR] Could not change directory.& pause & exit /b 1)

REM Start browser (optional) and start the dev server
set "URL=http://localhost:10001"
echo.
echo [INFO] Starting server (npm start) ...
echo [INFO] Opening browser: %URL%
echo.

start "PaintByNumbers" "%URL%" >nul 2>&1

REM Give the server a moment (optional)
timeout /t 2 /nobreak >nul 2>&1

npm start

echo.
echo [INFO] Server stopped.
popd
endlocal
pause

--- END FILE: .\Start-PaintByNumbers.bat ---


--- START FILE: .\Start-PaintByNumbers.ps1 ---
# Start-PaintByNumbers.ps1
# PowerShell alternative starter
# - switches Node via nvm
# - installs dependencies if missing
# - runs npm start and opens the browser

$ErrorActionPreference = 'Stop'

Write-Host "`n=== Paint-by-Numbers Generator: Local Start (PowerShell) ===`n"

$root = Split-Path -Parent $MyInvocation.MyCommand.Path
Set-Location $root

# Try to switch Node version
if (Get-Command nvm -ErrorAction SilentlyContinue) {
    Write-Host "[INFO] Using nvm to select Node v12.7.0 ..."
    & nvm use 12.7.0 | Out-Null
} else {
    Write-Host "[WARN] nvm not found in PATH. Continuing with current Node installation."
}

# Ensure node/npm are reachable
if (-not (Get-Command node -ErrorAction SilentlyContinue)) {
    if ($env:NVM_SYMLINK) {
        Write-Host "[INFO] node not found; adding NVM_SYMLINK to PATH: $($env:NVM_SYMLINK)"
        $env:Path = "$($env:NVM_SYMLINK);$($env:Path)"
    }
}

if (-not (Get-Command node -ErrorAction SilentlyContinue)) {
    throw "node not found. Please fix PATH or reopen the terminal."
}
if (-not (Get-Command npm -ErrorAction SilentlyContinue)) {
    throw "npm not found. Please fix PATH or reinstall Node/npm for this version."
}

# First-time install
if (-not (Test-Path "node_modules")) {
    Write-Host "[INFO] node_modules not found - running npm install (first start only) ..."
    & npm install
}

$url = 'http://localhost:10001'
Write-Host "[INFO] Starting server (npm start) ..."
Write-Host "[INFO] Opening browser: $url"
Start-Process $url

Start-Sleep -Seconds 2
& npm start

Write-Host "[INFO] Server stopped."
Read-Host "Press Enter to close"

--- END FILE: .\Start-PaintByNumbers.ps1 ---


--- START FILE: .\.github\workflows\main.yml ---
name: CLI build

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: windows-latest

    strategy:
      matrix:
        node-version: [10.x]

    steps:
    - uses: actions/checkout@v2
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm ci
      name: "Install dependencies from package-lock.json"
    - run: npm install pkg -g
      name: "Install pkg"
    - run: npm install typescript -g
      name: "Install typescript"
    - run: tsc
      working-directory: ./src-cli
      name: "Build cli to javascript"
    - run: pkg .
      name: "Package cli to single executable"
    
    - run:  mkdir "out"
      name: "Create output directory"
    - run: copy paint-by-numbers-generator-win.exe .\out\paint-by-numbers-generator-win.exe
      name: "Copy binary to out directory"
    - run: copy .\node_modules\canvas\build\Release\* .\out
      name: "Copy node-canvas binaries to output"
    - run: del *.pdb, *.ipdb, *.iobj
      name: "Cleanup unnecessary debug files"
      working-directory: ./out
    - uses: actions/upload-artifact@v2
      name: "Upload out as artifact"
      with:
        name: pbn-cli-win
        path: .\out\*
      env:
        CI: true
    - run: mkdir artifacts
    - name: Download a Build Artifact zip
      uses: actions/download-artifact@v2.0.5
      with:
        name: "pbn-cli-win"
        path: "./artifacts/pbn-cli-win.zip"
    - uses: ncipollo/release-action@v1
      name: "Create development prerelease"
      with:
        artifact: "artifacts/*"
        prerelease: true
        allowUpdates: true
        name: "CLI Development build"
        tag: "latest"
        token: ${{ secrets.GITHUB_TOKEN }}  


--- END FILE: .\.github\workflows\main.yml ---


--- START FILE: .\scripts\main.js ---
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
define("common", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function delay(ms) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof window !== "undefined") {
                return new Promise((exec) => window.setTimeout(exec, ms));
            }
            else {
                return new Promise((exec) => exec());
            }
        });
    }
    exports.delay = delay;
    class CancellationToken {
        constructor() {
            this.isCancelled = false;
        }
    }
    exports.CancellationToken = CancellationToken;
});
define("random", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Random {
        constructor(seed) {
            if (typeof seed === "undefined") {
                this.seed = new Date().getTime();
            }
            else {
                this.seed = seed;
            }
        }
        next() {
            const x = Math.sin(this.seed++) * 10000;
            return x - Math.floor(x);
        }
    }
    exports.Random = Random;
});
define("lib/clustering", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Vector {
        constructor(values, weight = 1) {
            this.values = values;
            this.weight = weight;
        }
        distanceTo(p) {
            let sumSquares = 0;
            for (let i = 0; i < this.values.length; i++) {
                sumSquares += (p.values[i] - this.values[i]) * (p.values[i] - this.values[i]);
            }
            return Math.sqrt(sumSquares);
        }
        /**
         *  Calculates the weighted average of the given points
         */
        static average(pts) {
            if (pts.length === 0) {
                throw Error("Can't average 0 elements");
            }
            const dims = pts[0].values.length;
            const values = [];
            for (let i = 0; i < dims; i++) {
                values.push(0);
            }
            let weightSum = 0;
            for (const p of pts) {
                weightSum += p.weight;
                for (let i = 0; i < dims; i++) {
                    values[i] += p.weight * p.values[i];
                }
            }
            for (let i = 0; i < values.length; i++) {
                values[i] /= weightSum;
            }
            return new Vector(values);
        }
    }
    exports.Vector = Vector;
    class KMeans {
        constructor(points, k, random, centroids = null) {
            this.points = points;
            this.k = k;
            this.random = random;
            this.currentIteration = 0;
            this.pointsPerCategory = [];
            this.centroids = [];
            this.currentDeltaDistanceDifference = 0;
            if (centroids != null) {
                this.centroids = centroids;
                for (let i = 0; i < this.k; i++) {
                    this.pointsPerCategory.push([]);
                }
            }
            else {
                this.initCentroids();
            }
        }
        initCentroids() {
            for (let i = 0; i < this.k; i++) {
                this.centroids.push(this.points[Math.floor(this.points.length * this.random.next())]);
                this.pointsPerCategory.push([]);
            }
        }
        step() {
            // clear category
            for (let i = 0; i < this.k; i++) {
                this.pointsPerCategory[i] = [];
            }
            // calculate points per centroid
            for (const p of this.points) {
                let minDist = Number.MAX_VALUE;
                let centroidIndex = -1;
                for (let k = 0; k < this.k; k++) {
                    const dist = this.centroids[k].distanceTo(p);
                    if (dist < minDist) {
                        centroidIndex = k;
                        minDist = dist;
                    }
                }
                this.pointsPerCategory[centroidIndex].push(p);
            }
            let totalDistanceDiff = 0;
            // adjust centroids
            for (let k = 0; k < this.pointsPerCategory.length; k++) {
                const cat = this.pointsPerCategory[k];
                if (cat.length > 0) {
                    const avg = Vector.average(cat);
                    const dist = this.centroids[k].distanceTo(avg);
                    totalDistanceDiff += dist;
                    this.centroids[k] = avg;
                }
            }
            this.currentDeltaDistanceDifference = totalDistanceDiff;
            this.currentIteration++;
        }
    }
    exports.KMeans = KMeans;
});
// From https://stackoverflow.com/a/9493060/694640
define("lib/colorconversion", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
      * Converts an RGB color value to HSL. Conversion formula
      * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
      * Assumes r, g, and b are contained in the set [0, 255] and
      * returns h, s, and l in the set [0, 1].
      *
      * @param   Number  r       The red color value
      * @param   Number  g       The green color value
      * @param   Number  b       The blue color value
      * @return  Array           The HSL representation
      */
    function rgbToHsl(r, g, b) {
        r /= 255, g /= 255, b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                default: h = 0;
            }
            h /= 6;
        }
        return [h, s, l];
    }
    exports.rgbToHsl = rgbToHsl;
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     *
     * @param   Number  h       The hue
     * @param   Number  s       The saturation
     * @param   Number  l       The lightness
     * @return  Array           The RGB representation
     */
    function hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) {
                    t += 1;
                }
                if (t > 1) {
                    t -= 1;
                }
                if (t < 1 / 6) {
                    return p + (q - p) * 6 * t;
                }
                if (t < 1 / 2) {
                    return q;
                }
                if (t < 2 / 3) {
                    return p + (q - p) * (2 / 3 - t) * 6;
                }
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r * 255, g * 255, b * 255];
    }
    exports.hslToRgb = hslToRgb;
    // From https://github.com/antimatter15/rgb-lab/blob/master/color.js
    function lab2rgb(lab) {
        let y = (lab[0] + 16) / 116, x = lab[1] / 500 + y, z = y - lab[2] / 200, r, g, b;
        x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16 / 116) / 7.787);
        y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16 / 116) / 7.787);
        z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16 / 116) / 7.787);
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.2040 + z * 1.0570;
        r = (r > 0.0031308) ? (1.055 * Math.pow(r, 1 / 2.4) - 0.055) : 12.92 * r;
        g = (g > 0.0031308) ? (1.055 * Math.pow(g, 1 / 2.4) - 0.055) : 12.92 * g;
        b = (b > 0.0031308) ? (1.055 * Math.pow(b, 1 / 2.4) - 0.055) : 12.92 * b;
        return [Math.max(0, Math.min(1, r)) * 255,
            Math.max(0, Math.min(1, g)) * 255,
            Math.max(0, Math.min(1, b)) * 255];
    }
    exports.lab2rgb = lab2rgb;
    function rgb2lab(rgb) {
        let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, x, y, z;
        r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
        y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
        z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
        x = (x > 0.008856) ? Math.pow(x, 1 / 3) : (7.787 * x) + 16 / 116;
        y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y) + 16 / 116;
        z = (z > 0.008856) ? Math.pow(z, 1 / 3) : (7.787 * z) + 16 / 116;
        return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
    }
    exports.rgb2lab = rgb2lab;
});
define("settings", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ClusteringColorSpace;
    (function (ClusteringColorSpace) {
        ClusteringColorSpace[ClusteringColorSpace["RGB"] = 0] = "RGB";
        ClusteringColorSpace[ClusteringColorSpace["HSL"] = 1] = "HSL";
        ClusteringColorSpace[ClusteringColorSpace["LAB"] = 2] = "LAB";
    })(ClusteringColorSpace = exports.ClusteringColorSpace || (exports.ClusteringColorSpace = {}));
    class Settings {
        constructor() {
            this.kMeansNrOfClusters = 16;
            this.kMeansMinDeltaDifference = 1;
            this.kMeansClusteringColorSpace = ClusteringColorSpace.RGB;
            this.kMeansColorRestrictions = [];
            this.colorAliases = {};
            this.narrowPixelStripCleanupRuns = 3; // 3 seems like a good compromise between removing enough narrow pixel strips to convergence. This fixes e.g. https://i.imgur.com/dz4ANz1.png
            this.removeFacetsSmallerThanNrOfPoints = 20;
            this.removeFacetsFromLargeToSmall = true;
            this.maximumNumberOfFacets = Number.MAX_VALUE;
            this.nrOfTimesToHalveBorderSegments = 2;
            this.resizeImageIfTooLarge = true;
            this.resizeImageWidth = 1024;
            this.resizeImageHeight = 1024;
            this.randomSeed = new Date().getTime();
        }
    }
    exports.Settings = Settings;
});
define("structs/typedarrays", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Uint32Array2D {
        constructor(width, height) {
            this.width = width;
            this.height = height;
            this.arr = new Uint32Array(width * height);
        }
        get(x, y) {
            return this.arr[y * this.width + x];
        }
        set(x, y, value) {
            this.arr[y * this.width + x] = value;
        }
    }
    exports.Uint32Array2D = Uint32Array2D;
    class Uint8Array2D {
        constructor(width, height) {
            this.width = width;
            this.height = height;
            this.arr = new Uint8Array(width * height);
        }
        get(x, y) {
            return this.arr[y * this.width + x];
        }
        set(x, y, value) {
            this.arr[y * this.width + x] = value;
        }
        matchAllAround(x, y, value) {
            const idx = y * this.width + x;
            return (x - 1 >= 0 && this.arr[idx - 1] === value) &&
                (y - 1 >= 0 && this.arr[idx - this.width] === value) &&
                (x + 1 < this.width && this.arr[idx + 1] === value) &&
                (y + 1 < this.height && this.arr[idx + this.width] === value);
        }
    }
    exports.Uint8Array2D = Uint8Array2D;
    class BooleanArray2D {
        constructor(width, height) {
            this.width = width;
            this.height = height;
            this.arr = new Uint8Array(width * height);
        }
        get(x, y) {
            return this.arr[y * this.width + x] !== 0;
        }
        set(x, y, value) {
            this.arr[y * this.width + x] = value ? 1 : 0;
        }
    }
    exports.BooleanArray2D = BooleanArray2D;
});
define("colorreductionmanagement", ["require", "exports", "common", "lib/clustering", "lib/colorconversion", "settings", "structs/typedarrays", "random"], function (require, exports, common_1, clustering_1, colorconversion_1, settings_1, typedarrays_1, random_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ColorMapResult {
    }
    exports.ColorMapResult = ColorMapResult;
    class ColorReducer {
        /**
         *  Creates a map of the various colors used
         */
        static createColorMap(kmeansImgData) {
            const imgColorIndices = new typedarrays_1.Uint8Array2D(kmeansImgData.width, kmeansImgData.height);
            let colorIndex = 0;
            const colors = {};
            const colorsByIndex = [];
            let idx = 0;
            for (let j = 0; j < kmeansImgData.height; j++) {
                for (let i = 0; i < kmeansImgData.width; i++) {
                    const r = kmeansImgData.data[idx++];
                    const g = kmeansImgData.data[idx++];
                    const b = kmeansImgData.data[idx++];
                    const a = kmeansImgData.data[idx++];
                    let currentColorIndex;
                    const color = r + "," + g + "," + b;
                    if (typeof colors[color] === "undefined") {
                        currentColorIndex = colorIndex;
                        colors[color] = colorIndex;
                        colorsByIndex.push([r, g, b]);
                        colorIndex++;
                    }
                    else {
                        currentColorIndex = colors[color];
                    }
                    imgColorIndices.set(i, j, currentColorIndex);
                }
            }
            const result = new ColorMapResult();
            result.imgColorIndices = imgColorIndices;
            result.colorsByIndex = colorsByIndex;
            result.width = kmeansImgData.width;
            result.height = kmeansImgData.height;
            return result;
        }
        /**
         *  Applies K-means clustering on the imgData to reduce the colors to
         *  k clusters and then output the result to the given outputImgData
         */
        static applyKMeansClustering(imgData, outputImgData, ctx, settings, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                const vectors = [];
                let idx = 0;
                let vIdx = 0;
                const bitsToChopOff = 2; // r,g,b gets rounded to every 4 values, 0,4,8,...
                // group by color, add points as 1D index to prevent Point object allocation
                const pointsByColor = {};
                for (let j = 0; j < imgData.height; j++) {
                    for (let i = 0; i < imgData.width; i++) {
                        let r = imgData.data[idx++];
                        let g = imgData.data[idx++];
                        let b = imgData.data[idx++];
                        const a = imgData.data[idx++];
                        // small performance boost: reduce bitness of colors by chopping off the last bits
                        // this will group more colors with only slight variation in color together, reducing the size of the points
                        r = r >> bitsToChopOff << bitsToChopOff;
                        g = g >> bitsToChopOff << bitsToChopOff;
                        b = b >> bitsToChopOff << bitsToChopOff;
                        const color = `${r},${g},${b}`;
                        if (!(color in pointsByColor)) {
                            pointsByColor[color] = [j * imgData.width + i];
                        }
                        else {
                            pointsByColor[color].push(j * imgData.width + i);
                        }
                    }
                }
                for (const color of Object.keys(pointsByColor)) {
                    const rgb = color.split(",").map((v) => parseInt(v));
                    // determine vector data based on color space conversion
                    let data;
                    if (settings.kMeansClusteringColorSpace === settings_1.ClusteringColorSpace.RGB) {
                        data = rgb;
                    }
                    else if (settings.kMeansClusteringColorSpace === settings_1.ClusteringColorSpace.HSL) {
                        data = colorconversion_1.rgbToHsl(rgb[0], rgb[1], rgb[2]);
                    }
                    else if (settings.kMeansClusteringColorSpace === settings_1.ClusteringColorSpace.LAB) {
                        data = colorconversion_1.rgb2lab(rgb);
                    }
                    else {
                        data = rgb;
                    }
                    // determine the weight (#pointsOfColor / #totalpoints) of each color
                    const weight = pointsByColor[color].length / (imgData.width * imgData.height);
                    const vec = new clustering_1.Vector(data, weight);
                    vec.tag = rgb;
                    vectors[vIdx++] = vec;
                }
                const random = new random_1.Random(settings.randomSeed);
                // vectors of all the unique colors are built, time to cluster them
                const kmeans = new clustering_1.KMeans(vectors, settings.kMeansNrOfClusters, random);
                let curTime = new Date().getTime();
                kmeans.step();
                while (kmeans.currentDeltaDistanceDifference > settings.kMeansMinDeltaDifference) {
                    kmeans.step();
                    // update GUI every 500ms
                    if (new Date().getTime() - curTime > 500) {
                        curTime = new Date().getTime();
                        yield common_1.delay(0);
                        if (onUpdate != null) {
                            ColorReducer.updateKmeansOutputImageData(kmeans, settings, pointsByColor, imgData, outputImgData, false);
                            onUpdate(kmeans);
                        }
                    }
                }
                // update the output image data (because it will be used for further processing)
                ColorReducer.updateKmeansOutputImageData(kmeans, settings, pointsByColor, imgData, outputImgData, true);
                if (onUpdate != null) {
                    onUpdate(kmeans);
                }
            });
        }
        /**
         *  Updates the image data from the current kmeans centroids and their respective associated colors (vectors)
         */
        static updateKmeansOutputImageData(kmeans, settings, pointsByColor, imgData, outputImgData, restrictToSpecifiedColors) {
            for (let c = 0; c < kmeans.centroids.length; c++) {
                // for each cluster centroid
                const centroid = kmeans.centroids[c];
                // points per category are the different unique colors belonging to that cluster
                for (const v of kmeans.pointsPerCategory[c]) {
                    // determine the rgb color value of the cluster centroid
                    let rgb;
                    if (settings.kMeansClusteringColorSpace === settings_1.ClusteringColorSpace.RGB) {
                        rgb = centroid.values;
                    }
                    else if (settings.kMeansClusteringColorSpace === settings_1.ClusteringColorSpace.HSL) {
                        const hsl = centroid.values;
                        rgb = colorconversion_1.hslToRgb(hsl[0], hsl[1], hsl[2]);
                    }
                    else if (settings.kMeansClusteringColorSpace === settings_1.ClusteringColorSpace.LAB) {
                        const lab = centroid.values;
                        rgb = colorconversion_1.lab2rgb(lab);
                    }
                    else {
                        rgb = centroid.values;
                    }
                    // remove decimals
                    rgb = rgb.map(v => Math.floor(v));
                    if (restrictToSpecifiedColors) {
                        if (settings.kMeansColorRestrictions.length > 0) {
                            // there are color restrictions, for each centroid find the color from the color restrictions that's the closest
                            let minDistance = Number.MAX_VALUE;
                            let closestRestrictedColor = null;
                            for (const color of settings.kMeansColorRestrictions) {
                                // RGB distance is not very good for the human eye perception, convert both to lab and then calculate the distance
                                const centroidLab = colorconversion_1.rgb2lab(rgb);
                                let restrictionLab;
                                if (typeof color === "string") {
                                    restrictionLab = colorconversion_1.rgb2lab(settings.colorAliases[color]);
                                }
                                else {
                                    restrictionLab = colorconversion_1.rgb2lab(color);
                                }
                                const distance = Math.sqrt((centroidLab[0] - restrictionLab[0]) * (centroidLab[0] - restrictionLab[0]) +
                                    (centroidLab[1] - restrictionLab[1]) * (centroidLab[1] - restrictionLab[1]) +
                                    (centroidLab[2] - restrictionLab[2]) * (centroidLab[2] - restrictionLab[2]));
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestRestrictedColor = color;
                                }
                            }
                            // use this color instead
                            if (closestRestrictedColor !== null) {
                                if (typeof closestRestrictedColor === "string") {
                                    rgb = settings.colorAliases[closestRestrictedColor];
                                }
                                else {
                                    rgb = closestRestrictedColor;
                                }
                            }
                        }
                    }
                    let pointRGB = v.tag;
                    // replace all pixels of the old color by the new centroid color
                    const pointColor = `${Math.floor(pointRGB[0])},${Math.floor(pointRGB[1])},${Math.floor(pointRGB[2])}`;
                    for (const pt of pointsByColor[pointColor]) {
                        const ptx = pt % imgData.width;
                        const pty = Math.floor(pt / imgData.width);
                        let dataOffset = (pty * imgData.width + ptx) * 4;
                        outputImgData.data[dataOffset++] = rgb[0];
                        outputImgData.data[dataOffset++] = rgb[1];
                        outputImgData.data[dataOffset++] = rgb[2];
                    }
                }
            }
        }
        /**
         *  Builds a distance matrix for each color to each other
         */
        static buildColorDistanceMatrix(colorsByIndex) {
            const colorDistances = new Array(colorsByIndex.length);
            for (let j = 0; j < colorsByIndex.length; j++) {
                colorDistances[j] = new Array(colorDistances.length);
            }
            for (let j = 0; j < colorsByIndex.length; j++) {
                for (let i = j; i < colorsByIndex.length; i++) {
                    const c1 = colorsByIndex[j];
                    const c2 = colorsByIndex[i];
                    const distance = Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) +
                        (c1[1] - c2[1]) * (c1[1] - c2[1]) +
                        (c1[2] - c2[2]) * (c1[2] - c2[2]));
                    colorDistances[i][j] = distance;
                    colorDistances[j][i] = distance;
                }
            }
            return colorDistances;
        }
        static processNarrowPixelStripCleanup(colormapResult) {
            return __awaiter(this, void 0, void 0, function* () {
                // build the color distance matrix, which describes the distance of each color to each other
                const colorDistances = ColorReducer.buildColorDistanceMatrix(colormapResult.colorsByIndex);
                let count = 0;
                const imgColorIndices = colormapResult.imgColorIndices;
                for (let j = 1; j < colormapResult.height - 1; j++) {
                    for (let i = 1; i < colormapResult.width - 1; i++) {
                        const top = imgColorIndices.get(i, j - 1);
                        const bottom = imgColorIndices.get(i, j + 1);
                        const left = imgColorIndices.get(i - 1, j);
                        const right = imgColorIndices.get(i + 1, j);
                        const cur = imgColorIndices.get(i, j);
                        if (cur !== top && cur !== bottom && cur !== left && cur !== right) {
                            // single pixel
                        }
                        else if (cur !== top && cur !== bottom) {
                            // check the color distance whether the top or bottom color is closer
                            const topColorDistance = colorDistances[cur][top];
                            const bottomColorDistance = colorDistances[cur][bottom];
                            imgColorIndices.set(i, j, topColorDistance < bottomColorDistance ? top : bottom);
                            count++;
                        }
                        else if (cur !== left && cur !== right) {
                            // check the color distance whether the top or bottom color is closer
                            const leftColorDistance = colorDistances[cur][left];
                            const rightColorDistance = colorDistances[cur][right];
                            imgColorIndices.set(i, j, leftColorDistance < rightColorDistance ? left : right);
                            count++;
                        }
                    }
                }
                console.log(count + " pixels replaced to remove narrow pixel strips");
            });
        }
    }
    exports.ColorReducer = ColorReducer;
});
define("structs/point", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        distanceTo(pt) {
            // don't do euclidean because then neighbours should be diagonally as well
            // because sqrt(2) < 2
            //  return Math.sqrt((pt.x - this.x) * (pt.x - this.x) + (pt.y - this.y) * (pt.y - this.y));
            return Math.abs(pt.x - this.x) + Math.abs(pt.y - this.y);
        }
        distanceToCoord(x, y) {
            // don't do euclidean because then neighbours should be diagonally as well
            // because sqrt(2) < 2
            //  return Math.sqrt((pt.x - this.x) * (pt.x - this.x) + (pt.y - this.y) * (pt.y - this.y));
            return Math.abs(x - this.x) + Math.abs(y - this.y);
        }
    }
    exports.Point = Point;
});
define("structs/boundingbox", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BoundingBox {
        constructor() {
            this.minX = Number.MAX_VALUE;
            this.minY = Number.MAX_VALUE;
            this.maxX = Number.MIN_VALUE;
            this.maxY = Number.MIN_VALUE;
        }
        get width() {
            return this.maxX - this.minX + 1;
        }
        get height() {
            return this.maxY - this.minY + 1;
        }
    }
    exports.BoundingBox = BoundingBox;
});
define("facetmanagement", ["require", "exports", "structs/point"], function (require, exports, point_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OrientationEnum;
    (function (OrientationEnum) {
        OrientationEnum[OrientationEnum["Left"] = 0] = "Left";
        OrientationEnum[OrientationEnum["Top"] = 1] = "Top";
        OrientationEnum[OrientationEnum["Right"] = 2] = "Right";
        OrientationEnum[OrientationEnum["Bottom"] = 3] = "Bottom";
    })(OrientationEnum = exports.OrientationEnum || (exports.OrientationEnum = {}));
    /**
     * PathPoint is a point with an orientation that indicates which wall border is set
     */
    class PathPoint extends point_1.Point {
        constructor(pt, orientation) {
            super(pt.x, pt.y);
            this.orientation = orientation;
        }
        getWallX() {
            let x = this.x;
            if (this.orientation === OrientationEnum.Left) {
                x -= 0.5;
            }
            else if (this.orientation === OrientationEnum.Right) {
                x += 0.5;
            }
            return x;
        }
        getWallY() {
            let y = this.y;
            if (this.orientation === OrientationEnum.Top) {
                y -= 0.5;
            }
            else if (this.orientation === OrientationEnum.Bottom) {
                y += 0.5;
            }
            return y;
        }
        getNeighbour(facetResult) {
            switch (this.orientation) {
                case OrientationEnum.Left:
                    if (this.x - 1 >= 0) {
                        return facetResult.facetMap.get(this.x - 1, this.y);
                    }
                    break;
                case OrientationEnum.Right:
                    if (this.x + 1 < facetResult.width) {
                        return facetResult.facetMap.get(this.x + 1, this.y);
                    }
                    break;
                case OrientationEnum.Top:
                    if (this.y - 1 >= 0) {
                        return facetResult.facetMap.get(this.x, this.y - 1);
                    }
                    break;
                case OrientationEnum.Bottom:
                    if (this.y + 1 < facetResult.height) {
                        return facetResult.facetMap.get(this.x, this.y + 1);
                    }
                    break;
            }
            return -1;
        }
        toString() {
            return this.x + "," + this.y + " " + this.orientation;
        }
    }
    exports.PathPoint = PathPoint;
    /**
     *  A facet that represents an area of pixels of the same color
     */
    class Facet {
        constructor() {
            this.pointCount = 0;
            /**
             * Flag indicating if the neighbourfacets array is dirty. If it is, the neighbourfacets *have* to be rebuild
             * Before it can be used. This is useful to defer the rebuilding of the array until it's actually needed
             * and can remove a lot of duplicate building of the array because multiple facets were hitting the same neighbour
             * (over 50% on test images)
             */
            this.neighbourFacetsIsDirty = false;
        }
        getFullPathFromBorderSegments(useWalls) {
            const newpath = [];
            const addPoint = (pt) => {
                if (useWalls) {
                    newpath.push(new point_1.Point(pt.getWallX(), pt.getWallY()));
                }
                else {
                    newpath.push(new point_1.Point(pt.x, pt.y));
                }
            };
            let lastSegment = null;
            for (const seg of this.borderSegments) {
                // fix for the continuitity of the border segments. If transition points between border segments on the path aren't repeated, the
                // borders of the facets aren't always matching up leaving holes when rendered
                if (lastSegment != null) {
                    if (lastSegment.reverseOrder) {
                        addPoint(lastSegment.originalSegment.points[0]);
                    }
                    else {
                        addPoint(lastSegment.originalSegment.points[lastSegment.originalSegment.points.length - 1]);
                    }
                }
                for (let i = 0; i < seg.originalSegment.points.length; i++) {
                    const idx = seg.reverseOrder ? (seg.originalSegment.points.length - 1 - i) : i;
                    addPoint(seg.originalSegment.points[idx]);
                }
                lastSegment = seg;
            }
            return newpath;
        }
    }
    exports.Facet = Facet;
    /**
     *  Result of the facet construction, both as a map and as an array.
     *  Facets in the array can be null when they've been deleted
     */
    class FacetResult {
    }
    exports.FacetResult = FacetResult;
});
define("facetBorderSegmenter", ["require", "exports", "common", "structs/point", "facetmanagement"], function (require, exports, common_2, point_2, facetmanagement_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *  Path segment is a segment of a border path that is adjacent to a specific neighbour facet
     */
    class PathSegment {
        constructor(points, neighbour) {
            this.points = points;
            this.neighbour = neighbour;
        }
    }
    exports.PathSegment = PathSegment;
    /**
     * Facet boundary segment describes the matched segment that is shared between 2 facets
     * When 2 segments are matched, one will be the original segment and the other one is removed
     * This ensures that all facets share the same segments, but sometimes in reverse order to ensure
     * the correct continuity of its entire oborder path
     */
    class FacetBoundarySegment {
        constructor(originalSegment, neighbour, reverseOrder) {
            this.originalSegment = originalSegment;
            this.neighbour = neighbour;
            this.reverseOrder = reverseOrder;
        }
    }
    exports.FacetBoundarySegment = FacetBoundarySegment;
    class FacetBorderSegmenter {
        /**
         *  Builds border segments that are shared between facets
         *  While border paths are all nice and fancy, they are not linked to neighbour facets
         *  So any change in the paths makes a not so nice gap between the facets, which makes smoothing them out impossible
         */
        static buildFacetBorderSegments(facetResult, nrOfTimesToHalvePoints = 2, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                // first chop up the border path in segments each time the neighbour at that point changes
                // (and sometimes even when it doesn't on that side but does on the neighbour's side)
                const segmentsPerFacet = FacetBorderSegmenter.prepareSegmentsPerFacet(facetResult);
                // now reduce the segment complexity with Haar wavelet reduction to smooth them out and make them
                // more curvy with data points instead of zig zag of a grid
                FacetBorderSegmenter.reduceSegmentComplexity(facetResult, segmentsPerFacet, nrOfTimesToHalvePoints);
                // now see which segments of facets with the prepared segments of the neighbour facets
                // and point them to the same one
                yield FacetBorderSegmenter.matchSegmentsWithNeighbours(facetResult, segmentsPerFacet, onUpdate);
            });
        }
        /**
         *  Chops up the border paths per facet into segments adjacent tothe same neighbour
         */
        static prepareSegmentsPerFacet(facetResult) {
            const segmentsPerFacet = new Array(facetResult.facets.length);
            for (const f of facetResult.facets) {
                if (f != null) {
                    const segments = [];
                    if (f.borderPath.length > 1) {
                        let currentPoints = [];
                        currentPoints.push(f.borderPath[0]);
                        for (let i = 1; i < f.borderPath.length; i++) {
                            const prevBorderPoint = f.borderPath[i - 1];
                            const curBorderPoint = f.borderPath[i];
                            const oldNeighbour = prevBorderPoint.getNeighbour(facetResult);
                            const curNeighbour = curBorderPoint.getNeighbour(facetResult);
                            let isTransitionPoint = false;
                            if (oldNeighbour !== curNeighbour) {
                                isTransitionPoint = true;
                            }
                            else {
                                // it's possible that due to inner facets inside the current facet that the
                                // border is interrupted on that facet's side, but not on the neighbour's side
                                if (oldNeighbour !== -1) {
                                    // check for tight rotations to break path if diagonals contain a different neighbour,
                                    // see https://i.imgur.com/o6Srqwj.png for visual path of the issue
                                    if (prevBorderPoint.x === curBorderPoint.x &&
                                        prevBorderPoint.y === curBorderPoint.y) {
                                        // rotation turn
                                        // check the diagonal neighbour to see if it remains the same
                                        //   +---+---+
                                        //   | dN|   |
                                        //   +---xxxx> (x = wall, dN = diagNeighbour)
                                        //   |   x f |
                                        //   +---v---+
                                        if ((prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Top && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Left) ||
                                            (prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Left && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Top)) {
                                            const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x - 1, curBorderPoint.y - 1);
                                            if (diagNeighbour !== oldNeighbour) {
                                                isTransitionPoint = true;
                                            }
                                        }
                                        else if ((prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Top && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Right) ||
                                            (prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Right && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Top)) {
                                            const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x + 1, curBorderPoint.y - 1);
                                            if (diagNeighbour !== oldNeighbour) {
                                                isTransitionPoint = true;
                                            }
                                        }
                                        else if ((prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Bottom && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Left) ||
                                            (prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Left && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Bottom)) {
                                            const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x - 1, curBorderPoint.y + 1);
                                            if (diagNeighbour !== oldNeighbour) {
                                                isTransitionPoint = true;
                                            }
                                        }
                                        else if ((prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Bottom && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Right) ||
                                            (prevBorderPoint.orientation === facetmanagement_1.OrientationEnum.Right && curBorderPoint.orientation === facetmanagement_1.OrientationEnum.Bottom)) {
                                            const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x + 1, curBorderPoint.y + 1);
                                            if (diagNeighbour !== oldNeighbour) {
                                                isTransitionPoint = true;
                                            }
                                        }
                                    }
                                }
                            }
                            currentPoints.push(curBorderPoint);
                            if (isTransitionPoint) {
                                // aha! a transition point, create the current points as new segment
                                // and start a new list
                                if (currentPoints.length > 1) {
                                    const segment = new PathSegment(currentPoints, oldNeighbour);
                                    segments.push(segment);
                                    currentPoints = [curBorderPoint];
                                }
                            }
                        }
                        // finally check if there is a remainder partial segment and either prepend
                        // the points to the first segment if they have the same neighbour or construct a
                        // new segment
                        if (currentPoints.length > 1) {
                            const oldNeighbour = f.borderPath[f.borderPath.length - 1].getNeighbour(facetResult);
                            if (segments.length > 0 && segments[0].neighbour === oldNeighbour) {
                                // the first segment and the remainder of the last one are the same part
                                // add the current points to the first segment by prefixing it
                                const mergedPoints = currentPoints.concat(segments[0].points);
                                segments[0].points = mergedPoints;
                            }
                            else {
                                // add the remainder as final segment
                                const segment = new PathSegment(currentPoints, oldNeighbour);
                                segments.push(segment);
                                currentPoints = [];
                            }
                        }
                    }
                    segmentsPerFacet[f.id] = segments;
                }
            }
            return segmentsPerFacet;
        }
        /**
         * Reduces each segment border path points
         */
        static reduceSegmentComplexity(facetResult, segmentsPerFacet, nrOfTimesToHalvePoints) {
            for (const f of facetResult.facets) {
                if (f != null) {
                    for (const segment of segmentsPerFacet[f.id]) {
                        for (let i = 0; i < nrOfTimesToHalvePoints; i++) {
                            segment.points = FacetBorderSegmenter.reduceSegmentHaarWavelet(segment.points, true, facetResult.width, facetResult.height);
                        }
                    }
                }
            }
        }
        /**
         *  Remove the points by taking the average per pair and using that as a new point
         *  in the reduced segment. The delta values that create the Haar wavelet are not tracked
         *  because they are unneeded.
         */
        static reduceSegmentHaarWavelet(newpath, skipOutsideBorders, width, height) {
            if (newpath.length <= 5) {
                return newpath;
            }
            const reducedPath = [];
            reducedPath.push(newpath[0]);
            for (let i = 1; i < newpath.length - 2; i += 2) {
                if (!skipOutsideBorders || (skipOutsideBorders && !FacetBorderSegmenter.isOutsideBorderPoint(newpath[i], width, height))) {
                    const cx = (newpath[i].x + newpath[i + 1].x) / 2;
                    const cy = (newpath[i].y + newpath[i + 1].y) / 2;
                    reducedPath.push(new facetmanagement_1.PathPoint(new point_2.Point(cx, cy), facetmanagement_1.OrientationEnum.Left));
                }
                else {
                    reducedPath.push(newpath[i]);
                    reducedPath.push(newpath[i + 1]);
                }
            }
            // close the loop
            reducedPath.push(newpath[newpath.length - 1]);
            return reducedPath;
        }
        static isOutsideBorderPoint(point, width, height) {
            return point.x === 0 || point.y === 0 || point.x === width - 1 || point.y === height - 1;
        }
        static calculateArea(path) {
            let total = 0;
            for (let i = 0; i < path.length; i++) {
                const addX = path[i].x;
                const addY = path[i === path.length - 1 ? 0 : i + 1].y;
                const subX = path[i === path.length - 1 ? 0 : i + 1].x;
                const subY = path[i].y;
                total += (addX * addY * 0.5);
                total -= (subX * subY * 0.5);
            }
            return Math.abs(total);
        }
        /**
         *  Matches all segments with each other between facets and their neighbour
         *  A segment matches when the start and end match or the start matches with the end and vice versa
         *  (then the segment will need to be traversed in reverse order)
         */
        static matchSegmentsWithNeighbours(facetResult, segmentsPerFacet, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                // max distance of the start/end points of the segment that it can be before the segments don't match up
                const MAX_DISTANCE = 4;
                // reserve room
                for (const f of facetResult.facets) {
                    if (f != null) {
                        f.borderSegments = new Array(segmentsPerFacet[f.id].length);
                    }
                }
                let count = 0;
                // and now the fun begins to match segments from 1 facet to its neighbours and vice versa
                for (const f of facetResult.facets) {
                    if (f != null) {
                        const debug = false;
                        for (let s = 0; s < segmentsPerFacet[f.id].length; s++) {
                            const segment = segmentsPerFacet[f.id][s];
                            if (segment != null && f.borderSegments[s] == null) {
                                f.borderSegments[s] = new FacetBoundarySegment(segment, segment.neighbour, false);
                                if (debug) {
                                    console.log("Setting facet " + f.id + " segment " + s + " to " + f.borderSegments[s]);
                                }
                                if (segment.neighbour !== -1) {
                                    const neighbourFacet = facetResult.facets[segment.neighbour];
                                    // see if there is a match to be found
                                    let matchFound = false;
                                    if (neighbourFacet != null) {
                                        const neighbourSegments = segmentsPerFacet[segment.neighbour];
                                        for (let ns = 0; ns < neighbourSegments.length; ns++) {
                                            const neighbourSegment = neighbourSegments[ns];
                                            // only try to match against the segments that aren't processed yet
                                            // and which are adjacent to the boundary of the current facet
                                            if (neighbourSegment != null && neighbourSegment.neighbour === f.id) {
                                                const segStartPoint = segment.points[0];
                                                const segEndPoint = segment.points[segment.points.length - 1];
                                                const nSegStartPoint = neighbourSegment.points[0];
                                                const nSegEndPoint = neighbourSegment.points[neighbourSegment.points.length - 1];
                                                let matchesStraight = (segStartPoint.distanceTo(nSegStartPoint) <= MAX_DISTANCE &&
                                                    segEndPoint.distanceTo(nSegEndPoint) <= MAX_DISTANCE);
                                                let matchesReverse = (segStartPoint.distanceTo(nSegEndPoint) <= MAX_DISTANCE &&
                                                    segEndPoint.distanceTo(nSegStartPoint) <= MAX_DISTANCE);
                                                if (matchesStraight && matchesReverse) {
                                                    // dang it , both match, it must be a tiny segment, but when placed wrongly it'll overlap in the path creating an hourglass 
                                                    //  e.g. https://i.imgur.com/XZQhxRV.png
                                                    // determine which is the closest
                                                    if (segStartPoint.distanceTo(nSegStartPoint) + segEndPoint.distanceTo(nSegEndPoint) <
                                                        segStartPoint.distanceTo(nSegEndPoint) + segEndPoint.distanceTo(nSegStartPoint)) {
                                                        matchesStraight = true;
                                                        matchesReverse = false;
                                                    }
                                                    else {
                                                        matchesStraight = false;
                                                        matchesReverse = true;
                                                    }
                                                }
                                                if (matchesStraight) {
                                                    // start & end points match
                                                    if (debug) {
                                                        console.log("Match found for facet " + f.id + " to neighbour " + neighbourFacet.id);
                                                    }
                                                    neighbourFacet.borderSegments[ns] = new FacetBoundarySegment(segment, f.id, false);
                                                    if (debug) {
                                                        console.log("Setting facet " + neighbourFacet.id + " segment " + ns + " to " + neighbourFacet.borderSegments[ns]);
                                                    }
                                                    segmentsPerFacet[neighbourFacet.id][ns] = null;
                                                    matchFound = true;
                                                    break;
                                                }
                                                else if (matchesReverse) {
                                                    // start & end points match  but in reverse order
                                                    if (debug) {
                                                        console.log("Reverse match found for facet " + f.id + " to neighbour " + neighbourFacet.id);
                                                    }
                                                    neighbourFacet.borderSegments[ns] = new FacetBoundarySegment(segment, f.id, true);
                                                    if (debug) {
                                                        console.log("Setting facet " + neighbourFacet.id + " segment " + ns + " to " + neighbourFacet.borderSegments[ns]);
                                                    }
                                                    segmentsPerFacet[neighbourFacet.id][ns] = null;
                                                    matchFound = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (!matchFound && debug) {
                                        // it's possible that the border is not shared with its neighbour
                                        // this can happen when the segment fully falls inside the other facet
                                        // though the above checks in the preparation of the segments should probably
                                        // cover all cases
                                        console.error("No match found for segment of " + f.id + ": " +
                                            ("siding " + segment.neighbour + " " + segment.points[0] + " -> " + segment.points[segment.points.length - 1]));
                                    }
                                }
                            }
                            // clear the current segment so it can't be processed again when processing the neighbour facet
                            segmentsPerFacet[f.id][s] = null;
                        }
                        if (count % 100 === 0) {
                            yield common_2.delay(0);
                            if (onUpdate != null) {
                                onUpdate(f.id / facetResult.facets.length);
                            }
                        }
                    }
                    count++;
                }
                if (onUpdate != null) {
                    onUpdate(1);
                }
            });
        }
    }
    exports.FacetBorderSegmenter = FacetBorderSegmenter;
});
define("facetBorderTracer", ["require", "exports", "common", "structs/point", "structs/typedarrays", "facetmanagement"], function (require, exports, common_3, point_3, typedarrays_2, facetmanagement_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FacetBorderTracer {
        /**
         *  Traces the border path of the facet from the facet border points.
         *  Imagine placing walls around the outer side of the border points.
         */
        static buildFacetBorderPaths(facetResult, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                let count = 0;
                const borderMask = new typedarrays_2.BooleanArray2D(facetResult.width, facetResult.height);
                // sort by biggest facets first
                const facetProcessingOrder = facetResult.facets.filter((f) => f != null).slice(0).sort((a, b) => b.pointCount > a.pointCount ? 1 : (b.pointCount < a.pointCount ? -1 : 0)).map((f) => f.id);
                for (let fidx = 0; fidx < facetProcessingOrder.length; fidx++) {
                    const f = facetResult.facets[facetProcessingOrder[fidx]];
                    if (f != null) {
                        for (const bp of f.borderPoints) {
                            borderMask.set(bp.x, bp.y, true);
                        }
                        // keep track of which walls are already set on each pixel
                        // e.g. xWall.get(x,y) is the left wall of point x,y
                        // as the left wall of (x+1,y) and right wall of (x,y) is the same
                        // the right wall of x,y can be set with xWall.set(x+1,y).
                        // Analogous for the horizontal walls in yWall
                        const xWall = new typedarrays_2.BooleanArray2D(facetResult.width + 1, facetResult.height + 1);
                        const yWall = new typedarrays_2.BooleanArray2D(facetResult.width + 1, facetResult.height + 1);
                        // the first border point will guaranteed be one of the outer ones because
                        // it will be the first point that is encountered of the facet when building
                        // them in buildFacet with DFS.
                        // --> Or so I thought, which is apparently not the case in rare circumstances
                        // sooooo go look for a border that edges with the bounding box, this is definitely
                        // on the outer side then.
                        let borderStartIndex = -1;
                        for (let i = 0; i < f.borderPoints.length; i++) {
                            if ((f.borderPoints[i].x === f.bbox.minX || f.borderPoints[i].x === f.bbox.maxX) ||
                                (f.borderPoints[i].y === f.bbox.minY || f.borderPoints[i].y === f.bbox.maxY)) {
                                borderStartIndex = i;
                                break;
                            }
                        }
                        // determine the starting point orientation (the outside of facet)
                        const pt = new facetmanagement_2.PathPoint(f.borderPoints[borderStartIndex], facetmanagement_2.OrientationEnum.Left);
                        // L T R B
                        if (pt.x - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y) !== f.id) {
                            pt.orientation = facetmanagement_2.OrientationEnum.Left;
                        }
                        else if (pt.y - 1 < 0 || facetResult.facetMap.get(pt.x, pt.y - 1) !== f.id) {
                            pt.orientation = facetmanagement_2.OrientationEnum.Top;
                        }
                        else if (pt.x + 1 >= facetResult.width || facetResult.facetMap.get(pt.x + 1, pt.y) !== f.id) {
                            pt.orientation = facetmanagement_2.OrientationEnum.Right;
                        }
                        else if (pt.y + 1 >= facetResult.height || facetResult.facetMap.get(pt.x, pt.y + 1) !== f.id) {
                            pt.orientation = facetmanagement_2.OrientationEnum.Bottom;
                        }
                        // build a border path from that point
                        const path = FacetBorderTracer.getPath(pt, facetResult, f, borderMask, xWall, yWall);
                        f.borderPath = path;
                        if (count % 100 === 0) {
                            yield common_3.delay(0);
                            if (onUpdate != null) {
                                onUpdate(fidx / facetProcessingOrder.length);
                            }
                        }
                    }
                    count++;
                }
                if (onUpdate != null) {
                    onUpdate(1);
                }
            });
        }
        /**
         * Returns a border path starting from the given point
         */
        static getPath(pt, facetResult, f, borderMask, xWall, yWall) {
            const debug = false;
            let finished = false;
            const count = 0;
            const path = [];
            FacetBorderTracer.addPointToPath(path, pt, xWall, f, yWall);
            // check rotations first, then straight along the ouside and finally diagonally
            // this ensures that bends are always taken as tight as possible
            // so it doesn't skip border points to later loop back to and get stuck (hopefully)
            while (!finished) {
                if (debug) {
                    console.log(pt.x + " " + pt.y + " " + pt.orientation);
                }
                // yes, technically i could do some trickery to only get the left/top cases
                // by shifting the pixels but that means some more shenanigans in correct order of things
                // so whatever. (And yes I tried it but it wasn't worth the debugging hell that ensued)
                const possibleNextPoints = [];
                //   +---+---+
                //   |  <|   |
                //   +---+---+
                if (pt.orientation === facetmanagement_2.OrientationEnum.Left) {
                    // check rotate to top
                    //   +---+---+
                    //   |   |   |
                    //   +---xnnnn (x = old wall, n = new wall, F = current facet x,y)
                    //   |   x F |
                    //   +---x---+
                    if (((pt.y - 1 >= 0 && facetResult.facetMap.get(pt.x, pt.y - 1) !== f.id) // top exists and is a neighbour facet
                        || pt.y - 1 < 0) // or top doesn't exist, which is the boundary of the image
                        && !yWall.get(pt.x, pt.y)) { // and the wall isn't set yet
                        // can place top _ wall at x,y
                        if (debug) {
                            console.log("can place top _ wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Top);
                        possibleNextPoints.push(nextpt);
                    }
                    // check rotate to bottom
                    //   +---+---+
                    //   |   |   |
                    //   +---x---+ (x = old wall, n = new wall, F = current facet x,y)
                    //   |   x F |
                    //   +---xnnnn
                    if (((pt.y + 1 < facetResult.height && facetResult.facetMap.get(pt.x, pt.y + 1) !== f.id) // bottom exists and is a neighbour facet
                        || pt.y + 1 >= facetResult.height) // or bottom doesn't exist, which is the boundary of the image
                        && !yWall.get(pt.x, pt.y + 1)) { // and the wall isn't set yet
                        // can place bottom  _ wall at x,y
                        if (debug) {
                            console.log("can place bottom _ wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Bottom);
                        possibleNextPoints.push(nextpt);
                    }
                    // check upwards
                    //   +---n---+
                    //   |   n   |
                    //   +---x---+ (x = old wall, n = new wall, F = current facet x,y)
                    //   |   x F |
                    //   +---x---+
                    if (pt.y - 1 >= 0 // top exists
                        && facetResult.facetMap.get(pt.x, pt.y - 1) === f.id // and is part of the same facet
                        && (pt.x - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y - 1) !== f.id) // and
                        && borderMask.get(pt.x, pt.y - 1)
                        && !xWall.get(pt.x, pt.y - 1)) {
                        // can place | wall at x,y-1
                        if (debug) {
                            console.log(`can place left | wall at x,y-1`);
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y - 1), facetmanagement_2.OrientationEnum.Left);
                        possibleNextPoints.push(nextpt);
                    }
                    // check downwards
                    //   +---x---+
                    //   |   x F |
                    //   +---x---+ (x = old wall, n = new wall, F = current facet x,y)
                    //   |   n   |
                    //   +---n---+
                    if (pt.y + 1 < facetResult.height
                        && facetResult.facetMap.get(pt.x, pt.y + 1) === f.id
                        && (pt.x - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y + 1) !== f.id)
                        && borderMask.get(pt.x, pt.y + 1)
                        && !xWall.get(pt.x, pt.y + 1)) {
                        // can place | wall at x,y+1
                        if (debug) {
                            console.log("can place left | wall at x,y+1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y + 1), facetmanagement_2.OrientationEnum.Left);
                        possibleNextPoints.push(nextpt);
                    }
                    // check left upwards
                    //   +---+---+
                    //   |   |   |
                    //   nnnnx---+ (x = old wall, n = new wall, F = current facet x,y)
                    //   |   x F |
                    //   +---x---+
                    if (pt.y - 1 >= 0 && pt.x - 1 >= 0 // there is a left upwards
                        && facetResult.facetMap.get(pt.x - 1, pt.y - 1) === f.id // and it belongs to the same facet
                        && borderMask.get(pt.x - 1, pt.y - 1) // and is on the border
                        && !yWall.get(pt.x - 1, pt.y - 1 + 1) // and the bottom wall isn't set yet
                        && !yWall.get(pt.x, pt.y) // and the path didn't come from the top of the current one to prevent getting a T shaped path (issue: https://i.imgur.com/ggUWuXi.png)
                    ) {
                        // can place bottom _ wall at x-1,y-1
                        if (debug) {
                            console.log("can place bottom _ wall at x-1,y-1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x - 1, pt.y - 1), facetmanagement_2.OrientationEnum.Bottom);
                        possibleNextPoints.push(nextpt);
                    }
                    // check left downwards
                    //   +---x---+
                    //   |   x F |
                    //   nnnnx---+ (x = old wall, n = new wall, F = current facet x,y)
                    //   |   |   |
                    //   +---+---+
                    if (pt.y + 1 < facetResult.height && pt.x - 1 >= 0 // there is a left downwards
                        && facetResult.facetMap.get(pt.x - 1, pt.y + 1) === f.id // and belongs to the same facet
                        && borderMask.get(pt.x - 1, pt.y + 1) // and is on the border
                        && !yWall.get(pt.x - 1, pt.y + 1) // and the top wall isn't set yet
                        && !yWall.get(pt.x, pt.y + 1) // and the path didn't come from the bottom of the current point to prevent T shape
                    ) {
                        // can place top _ wall at x-1,y+1
                        if (debug) {
                            console.log("can place top _ wall at x-1,y+1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x - 1, pt.y + 1), facetmanagement_2.OrientationEnum.Top);
                        possibleNextPoints.push(nextpt);
                    }
                }
                else if (pt.orientation === facetmanagement_2.OrientationEnum.Top) {
                    // check rotate to left
                    if (((pt.x - 1 >= 0
                        && facetResult.facetMap.get(pt.x - 1, pt.y) !== f.id)
                        || pt.x - 1 < 0)
                        && !xWall.get(pt.x, pt.y)) {
                        // can place left | wall at x,y
                        if (debug) {
                            console.log("can place left | wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Left);
                        possibleNextPoints.push(nextpt);
                    }
                    // check rotate to right
                    if (((pt.x + 1 < facetResult.width
                        && facetResult.facetMap.get(pt.x + 1, pt.y) !== f.id)
                        || pt.x + 1 >= facetResult.width)
                        && !xWall.get(pt.x + 1, pt.y)) {
                        // can place right | wall at x,y
                        if (debug) {
                            console.log("can place right | wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Right);
                        possibleNextPoints.push(nextpt);
                    }
                    // check leftwards
                    if (pt.x - 1 >= 0
                        && facetResult.facetMap.get(pt.x - 1, pt.y) === f.id
                        && (pt.y - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y - 1) !== f.id)
                        && borderMask.get(pt.x - 1, pt.y)
                        && !yWall.get(pt.x - 1, pt.y)) {
                        // can place top _ wall at x-1,y
                        if (debug) {
                            console.log(`can place top _ wall at x-1,y`);
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x - 1, pt.y), facetmanagement_2.OrientationEnum.Top);
                        possibleNextPoints.push(nextpt);
                    }
                    // check rightwards
                    if (pt.x + 1 < facetResult.width
                        && facetResult.facetMap.get(pt.x + 1, pt.y) === f.id
                        && (pt.y - 1 < 0 || facetResult.facetMap.get(pt.x + 1, pt.y - 1) !== f.id)
                        && borderMask.get(pt.x + 1, pt.y)
                        && !yWall.get(pt.x + 1, pt.y)) {
                        // can place top _ wall at x+1,y
                        if (debug) {
                            console.log(`can place top _ wall at x+1,y`);
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x + 1, pt.y), facetmanagement_2.OrientationEnum.Top);
                        possibleNextPoints.push(nextpt);
                    }
                    // check left upwards
                    if (pt.y - 1 >= 0 && pt.x - 1 >= 0 // there is a left upwards
                        && facetResult.facetMap.get(pt.x - 1, pt.y - 1) === f.id // and it belongs to the same facet
                        && borderMask.get(pt.x - 1, pt.y - 1) // and it's part of the border
                        && !xWall.get(pt.x - 1 + 1, pt.y - 1) // the right wall isn't set yet
                        && !xWall.get(pt.x, pt.y) // and the left wall of the current point isn't set yet to prevent |- path
                    ) {
                        // can place right | wall at x-1,y-1
                        if (debug) {
                            console.log("can place right | wall at x-1,y-1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x - 1, pt.y - 1), facetmanagement_2.OrientationEnum.Right);
                        possibleNextPoints.push(nextpt);
                    }
                    // check right upwards
                    if (pt.y - 1 >= 0 && pt.x + 1 < facetResult.width // there is a right upwards
                        && facetResult.facetMap.get(pt.x + 1, pt.y - 1) === f.id // and it belongs to the same facet
                        && borderMask.get(pt.x + 1, pt.y - 1) // and it's on the border
                        && !xWall.get(pt.x + 1, pt.y - 1) // and the left wall isn't set yet
                        && !xWall.get(pt.x + 1, pt.y) // and the right wall of the current point isn't set yet to prevent -| path
                    ) {
                        // can place left |  wall at x+1,y-1
                        if (debug) {
                            console.log("can place left |  wall at x+1,y-1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x + 1, pt.y - 1), facetmanagement_2.OrientationEnum.Left);
                        possibleNextPoints.push(nextpt);
                    }
                }
                else if (pt.orientation === facetmanagement_2.OrientationEnum.Right) {
                    // check rotate to top
                    if (((pt.y - 1 >= 0
                        && facetResult.facetMap.get(pt.x, pt.y - 1) !== f.id)
                        || pt.y - 1 < 0)
                        && !yWall.get(pt.x, pt.y)) {
                        // can place top _ wall at x,y
                        if (debug) {
                            console.log("can place top _ wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Top);
                        possibleNextPoints.push(nextpt);
                    }
                    // check rotate to bottom
                    if (((pt.y + 1 < facetResult.height
                        && facetResult.facetMap.get(pt.x, pt.y + 1) !== f.id)
                        || pt.y + 1 >= facetResult.height)
                        && !yWall.get(pt.x, pt.y + 1)) {
                        // can place bottom  _ wall at x,y
                        if (debug) {
                            console.log("can place bottom _ wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Bottom);
                        possibleNextPoints.push(nextpt);
                    }
                    // check upwards
                    if (pt.y - 1 >= 0
                        && facetResult.facetMap.get(pt.x, pt.y - 1) === f.id
                        && (pt.x + 1 >= facetResult.width || facetResult.facetMap.get(pt.x + 1, pt.y - 1) !== f.id)
                        && borderMask.get(pt.x, pt.y - 1)
                        && !xWall.get(pt.x + 1, pt.y - 1)) {
                        // can place right | wall at x,y-1
                        if (debug) {
                            console.log(`can place right | wall at x,y-1`);
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y - 1), facetmanagement_2.OrientationEnum.Right);
                        possibleNextPoints.push(nextpt);
                    }
                    // check downwards
                    if (pt.y + 1 < facetResult.height
                        && facetResult.facetMap.get(pt.x, pt.y + 1) === f.id
                        && (pt.x + 1 >= facetResult.width || facetResult.facetMap.get(pt.x + 1, pt.y + 1) !== f.id)
                        && borderMask.get(pt.x, pt.y + 1)
                        && !xWall.get(pt.x + 1, pt.y + 1)) {
                        // can place right | wall at x,y+1
                        if (debug) {
                            console.log("can place right | wall at x,y+1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y + 1), facetmanagement_2.OrientationEnum.Right);
                        possibleNextPoints.push(nextpt);
                    }
                    // check right upwards
                    if (pt.y - 1 >= 0 && pt.x + 1 < facetResult.width // there is a right upwards
                        && facetResult.facetMap.get(pt.x + 1, pt.y - 1) === f.id // and belongs to the same facet
                        && borderMask.get(pt.x + 1, pt.y - 1) // and is on the border
                        && !yWall.get(pt.x + 1, pt.y - 1 + 1) // and the bottom wall isn't set yet
                        && !yWall.get(pt.x, pt.y) // and the top wall of the current point isn't set to prevent a T shape
                    ) {
                        // can place bottom _ wall at x+1,y-1
                        if (debug) {
                            console.log("can place bottom _ wall at x+1,y-1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x + 1, pt.y - 1), facetmanagement_2.OrientationEnum.Bottom);
                        possibleNextPoints.push(nextpt);
                    }
                    // check right downwards
                    if (pt.y + 1 < facetResult.height && pt.x + 1 < facetResult.width // there is a right downwards
                        && facetResult.facetMap.get(pt.x + 1, pt.y + 1) === f.id // and belongs to the same facet
                        && borderMask.get(pt.x + 1, pt.y + 1) // and is on the border
                        && !yWall.get(pt.x + 1, pt.y + 1) // and the top wall isn't visited yet
                        && !yWall.get(pt.x, pt.y + 1) // and the bottom wall of the current point isn't set to prevent a T shape
                    ) {
                        // can place top _ wall at x+1,y+1
                        if (debug) {
                            console.log("can place top _ wall at x+1,y+1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x + 1, pt.y + 1), facetmanagement_2.OrientationEnum.Top);
                        possibleNextPoints.push(nextpt);
                    }
                }
                else if (pt.orientation === facetmanagement_2.OrientationEnum.Bottom) {
                    // check rotate to left
                    if (((pt.x - 1 >= 0
                        && facetResult.facetMap.get(pt.x - 1, pt.y) !== f.id)
                        || pt.x - 1 < 0)
                        && !xWall.get(pt.x, pt.y)) {
                        // can place left | wall at x,y
                        if (debug) {
                            console.log("can place left | wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Left);
                        possibleNextPoints.push(nextpt);
                    }
                    // check rotate to right
                    if (((pt.x + 1 < facetResult.width
                        && facetResult.facetMap.get(pt.x + 1, pt.y) !== f.id)
                        || pt.x + 1 >= facetResult.width)
                        && !xWall.get(pt.x + 1, pt.y)) {
                        // can place right | wall at x,y
                        if (debug) {
                            console.log("can place right | wall at x,y");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x, pt.y), facetmanagement_2.OrientationEnum.Right);
                        possibleNextPoints.push(nextpt);
                    }
                    // check leftwards
                    if (pt.x - 1 >= 0
                        && facetResult.facetMap.get(pt.x - 1, pt.y) === f.id
                        && (pt.y + 1 >= facetResult.height || facetResult.facetMap.get(pt.x - 1, pt.y + 1) !== f.id)
                        && borderMask.get(pt.x - 1, pt.y)
                        && !yWall.get(pt.x - 1, pt.y + 1)) {
                        // can place bottom _ wall at x-1,y
                        if (debug) {
                            console.log(`can place bottom _ wall at x-1,y`);
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x - 1, pt.y), facetmanagement_2.OrientationEnum.Bottom);
                        possibleNextPoints.push(nextpt);
                    }
                    // check rightwards
                    if (pt.x + 1 < facetResult.width
                        && facetResult.facetMap.get(pt.x + 1, pt.y) === f.id
                        && (pt.y + 1 >= facetResult.height || facetResult.facetMap.get(pt.x + 1, pt.y + 1) !== f.id)
                        && borderMask.get(pt.x + 1, pt.y)
                        && !yWall.get(pt.x + 1, pt.y + 1)) {
                        // can place top _ wall at x+1,y
                        if (debug) {
                            console.log(`can place bottom _ wall at x+1,y`);
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x + 1, pt.y), facetmanagement_2.OrientationEnum.Bottom);
                        possibleNextPoints.push(nextpt);
                    }
                    // check left downwards
                    if (pt.y + 1 < facetResult.height && pt.x - 1 >= 0 // there is a left downwards
                        && facetResult.facetMap.get(pt.x - 1, pt.y + 1) === f.id // and it's the same facet
                        && borderMask.get(pt.x - 1, pt.y + 1) // and it's on the border
                        && !xWall.get(pt.x - 1 + 1, pt.y + 1) // and the right wall isn't set yet
                        && !xWall.get(pt.x, pt.y) // and the left wall of the current point isn't set yet to prevent |- path
                    ) {
                        // can place right | wall at x-1,y-1
                        if (debug) {
                            console.log("can place right | wall at x-1,y+1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x - 1, pt.y + 1), facetmanagement_2.OrientationEnum.Right);
                        possibleNextPoints.push(nextpt);
                    }
                    // check right downwards
                    if (pt.y + 1 < facetResult.height && pt.x + 1 < facetResult.width // there is a right downwards
                        && facetResult.facetMap.get(pt.x + 1, pt.y + 1) === f.id // and it's the same facet
                        && borderMask.get(pt.x + 1, pt.y + 1) // and it's on the border
                        && !xWall.get(pt.x + 1, pt.y + 1) // and the left wall isn't set yet
                        && !xWall.get(pt.x + 1, pt.y) // and the right wall of the current point isn't set yet to prevent -| path
                    ) {
                        // can place left |  wall at x+1,y+1
                        if (debug) {
                            console.log("can place left |  wall at x+1,y+1");
                        }
                        const nextpt = new facetmanagement_2.PathPoint(new point_3.Point(pt.x + 1, pt.y + 1), facetmanagement_2.OrientationEnum.Left);
                        possibleNextPoints.push(nextpt);
                    }
                }
                if (possibleNextPoints.length > 1) {
                    // TODO it's now not necessary anymore to aggregate all possibilities, the first one is going to be the correct
                    // selection to trace the entire border, so the if checks above can include a skip once ssible point is found again
                    pt = possibleNextPoints[0];
                    FacetBorderTracer.addPointToPath(path, pt, xWall, f, yWall);
                }
                else if (possibleNextPoints.length === 1) {
                    pt = possibleNextPoints[0];
                    FacetBorderTracer.addPointToPath(path, pt, xWall, f, yWall);
                }
                else {
                    finished = true;
                }
            }
            // clear up the walls set for the path so the array can be reused
            for (const pathPoint of path) {
                switch (pathPoint.orientation) {
                    case facetmanagement_2.OrientationEnum.Left:
                        xWall.set(pathPoint.x, pathPoint.y, false);
                        break;
                    case facetmanagement_2.OrientationEnum.Top:
                        yWall.set(pathPoint.x, pathPoint.y, false);
                        break;
                    case facetmanagement_2.OrientationEnum.Right:
                        xWall.set(pathPoint.x + 1, pathPoint.y, false);
                        break;
                    case facetmanagement_2.OrientationEnum.Bottom:
                        yWall.set(pathPoint.x, pathPoint.y + 1, false);
                        break;
                }
            }
            return path;
        }
        /**
         * Add a point to the border path and ensure the correct xWall/yWalls is set
         */
        static addPointToPath(path, pt, xWall, f, yWall) {
            path.push(pt);
            switch (pt.orientation) {
                case facetmanagement_2.OrientationEnum.Left:
                    xWall.set(pt.x, pt.y, true);
                    break;
                case facetmanagement_2.OrientationEnum.Top:
                    yWall.set(pt.x, pt.y, true);
                    break;
                case facetmanagement_2.OrientationEnum.Right:
                    xWall.set(pt.x + 1, pt.y, true);
                    break;
                case facetmanagement_2.OrientationEnum.Bottom:
                    yWall.set(pt.x, pt.y + 1, true);
                    break;
            }
        }
    }
    exports.FacetBorderTracer = FacetBorderTracer;
});
// Faster flood fill from
// http://www.adammil.net/blog/v126_A_More_Efficient_Flood_Fill.html
define("lib/fill", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fill(x, y, width, height, visited, setFill) {
        // at this point, we know array[y,x] is clear, and we want to move as far as possible to the upper-left. moving
        // up is much more important than moving left, so we could try to make this smarter by sometimes moving to
        // the right if doing so would allow us to move further up, but it doesn't seem worth the complexit
        let xx = x;
        let yy = y;
        while (true) {
            const ox = xx;
            const oy = yy;
            while (yy !== 0 && !visited(xx, yy - 1)) {
                yy--;
            }
            while (xx !== 0 && !visited(xx - 1, yy)) {
                xx--;
            }
            if (xx === ox && yy === oy) {
                break;
            }
        }
        fillCore(xx, yy, width, height, visited, setFill);
    }
    exports.fill = fill;
    function fillCore(x, y, width, height, visited, setFill) {
        // at this point, we know that array[y,x] is clear, and array[y-1,x] and array[y,x-1] are set.
        // we'll begin scanning down and to the right, attempting to fill an entire rectangular block
        let lastRowLength = 0; // the number of cells that were clear in the last row we scanned
        do {
            let rowLength = 0;
            let sx = x; // keep track of how long this row is. sx is the starting x for the main scan below
            // now we want to handle a case like |***|, where we fill 3 cells in the first row and then after we move to
            // the second row we find the first  | **| cell is filled, ending our rectangular scan. rather than handling
            // this via the recursion below, we'll increase the starting value of 'x' and reduce the last row length to
            // match. then we'll continue trying to set the narrower rectangular block
            if (lastRowLength !== 0 && visited(x, y)) {
                do {
                    if (--lastRowLength === 0) {
                        return;
                    } // shorten the row. if it's full, we're done
                } while (visited(++x, y)); // otherwise, update the starting point of the main scan to match
                sx = x;
            }
            else {
                for (; x !== 0 && !visited(x - 1, y); rowLength++, lastRowLength++) {
                    x--;
                    setFill(x, y); // to avoid scanning the cells twice, we'll fill them and update rowLength here
                    // if there's something above the new starting point, handle that recursively. this deals with cases
                    // like |* **| when we begin filling from (2,0), move down to (2,1), and then move left to (0,1).
                    // the  |****| main scan assumes the portion of the previous row from x to x+lastRowLength has already
                    // been filled. adjusting x and lastRowLength breaks that assumption in this case, so we must fix it
                    if (y !== 0 && !visited(x, y - 1)) {
                        fill(x, y - 1, width, height, visited, setFill);
                    } // use _Fill since there may be more up and left
                }
            }
            // now at this point we can begin to scan the current row in the rectangular block. the span of the previous
            // row from x (inclusive) to x+lastRowLength (exclusive) has already been filled, so we don't need to
            // check it. so scan across to the right in the current row
            for (; sx < width && !visited(sx, y); rowLength++, sx++) {
                setFill(sx, y);
            }
            // now we've scanned this row. if the block is rectangular, then the previous row has already been scanned,
            // so we don't need to look upwards and we're going to scan the next row in the next iteration so we don't
            // need to look downwards. however, if the block is not rectangular, we may need to look upwards or rightwards
            // for some portion of the row. if this row was shorter than the last row, we may need to look rightwards near
            // the end, as in the case of |*****|, where the first row is 5 cells long and the second row is 3 cells long.
            // we must look to the right  |*** *| of the single cell at the end of the second row, i.e. at (4,1)
            if (rowLength < lastRowLength) {
                for (const end = x + lastRowLength; ++sx < end;) { // there. any clear cells would have been connected to the previous
                    if (!visited(sx, y)) {
                        fillCore(sx, y, width, height, visited, setFill);
                    } // row. the cells up and left must be set so use FillCore
                }
            }
            else if (rowLength > lastRowLength && y !== 0) {
                for (let ux = x + lastRowLength; ++ux < sx;) {
                    if (!visited(ux, y - 1)) {
                        fill(ux, y - 1, width, height, visited, setFill);
                    } // since there may be clear cells up and left, use _Fill
                }
            }
            lastRowLength = rowLength; // record the new row length
        } while (lastRowLength !== 0 && ++y < height); // if we get to a full row or to the bottom, we're done
    }
});
define("facetReducer", ["require", "exports", "colorreductionmanagement", "common", "facetCreator", "structs/typedarrays"], function (require, exports, colorreductionmanagement_1, common_4, facetCreator_1, typedarrays_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FacetReducer {
        /**
         *  Remove all facets that have a pointCount smaller than the given number.
         */
        static reduceFacets(smallerThan, removeFacetsFromLargeToSmall, maximumNumberOfFacets, colorsByIndex, facetResult, imgColorIndices, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                const visitedCache = new typedarrays_3.BooleanArray2D(facetResult.width, facetResult.height);
                // build the color distance matrix, which describes the distance of each color to each other
                const colorDistances = colorreductionmanagement_1.ColorReducer.buildColorDistanceMatrix(colorsByIndex);
                // process facets from large to small. This results in better consistency with the original image
                // because the small facets act as boundary for the large merges keeping them mostly in place of where they should remain
                // then afterwards the smaller ones are deleted which will just end up completely isolated and thus entirely replaced
                // with the outer facet. But then again, what do I know, I'm just a comment.
                const facetProcessingOrder = facetResult.facets.filter((f) => f != null).slice(0).sort((a, b) => b.pointCount > a.pointCount ? 1 : (b.pointCount < a.pointCount ? -1 : 0)).map((f) => f.id);
                if (!removeFacetsFromLargeToSmall) {
                    facetProcessingOrder.reverse();
                }
                let curTime = new Date().getTime();
                for (let fidx = 0; fidx < facetProcessingOrder.length; fidx++) {
                    const f = facetResult.facets[facetProcessingOrder[fidx]];
                    // facets can be removed by merging by others due to a previous facet deletion
                    if (f != null && f.pointCount < smallerThan) {
                        FacetReducer.deleteFacet(f.id, facetResult, imgColorIndices, colorDistances, visitedCache);
                        if (new Date().getTime() - curTime > 500) {
                            curTime = new Date().getTime();
                            yield common_4.delay(0);
                            if (onUpdate != null) {
                                onUpdate(0.5 * fidx / facetProcessingOrder.length);
                            }
                        }
                    }
                }
                let facetCount = facetResult.facets.filter(f => f != null).length;
                if (facetCount > maximumNumberOfFacets) {
                    console.log(`There are still ${facetCount} facets, more than the maximum of ${maximumNumberOfFacets}. Removing the smallest facets`);
                }
                const startFacetCount = facetCount;
                while (facetCount > maximumNumberOfFacets) {
                    // because facets can be merged, reevaluate the order of facets to make sure the smallest one is removed 
                    // this is slower but more accurate
                    const facetProcessingOrder = facetResult.facets.filter((f) => f != null).slice(0)
                        .sort((a, b) => b.pointCount > a.pointCount ? 1 : (b.pointCount < a.pointCount ? -1 : 0))
                        .map((f) => f.id)
                        .reverse();
                    const facetToRemove = facetResult.facets[facetProcessingOrder[0]];
                    FacetReducer.deleteFacet(facetToRemove.id, facetResult, imgColorIndices, colorDistances, visitedCache);
                    facetCount = facetResult.facets.filter(f => f != null).length;
                    if (new Date().getTime() - curTime > 500) {
                        curTime = new Date().getTime();
                        yield common_4.delay(0);
                        if (onUpdate != null) {
                            onUpdate(0.5 + 0.5 - (facetCount - maximumNumberOfFacets) / (startFacetCount - maximumNumberOfFacets));
                        }
                    }
                }
                // this.trimFacets(facetResult, imgColorIndices, colorDistances, visitedCache);
                if (onUpdate != null) {
                    onUpdate(1);
                }
            });
        }
        // /**
        //  * Trims facets with narrow paths either horizontally or vertically, potentially splitting the facet into multiple facets
        //  */
        // public static trimFacets(facetResult: FacetResult, imgColorIndices: Uint8Array2D, colorDistances: number[][], visitedArrayCache: BooleanArray2D) {
        //     for (const facet of facetResult.facets) {
        //         if (facet !== null) {
        //             const facetPointsToReallocate: Point[] = [];
        //             for (let y: number = facet.bbox.minY; y <= facet.bbox.maxY; y++) {
        //                 for (let x: number = facet.bbox.minX; x <= facet.bbox.maxX; x++) {
        //                     if (x > 0 && y > 0 && x < facetResult.width - 1 && y < facetResult.height - 1 &&
        //                         facetResult.facetMap.get(x, y) === facet.id) {
        //                         // check if isolated horizontally
        //                         const top = facetResult.facetMap.get(x, y - 1);
        //                         const bottom = facetResult.facetMap.get(x, y + 1);
        //                         if (top !== facet.id && bottom !== facet.id) {
        //                             // . ? .
        //                             // . F .
        //                             // . ? .
        //                             // mark pixel of facet that it should be removed
        //                             facetPointsToReallocate.push(new Point(x, y));
        //                             const closestNeighbour = FacetReducer.getClosestNeighbourForPixel(facet, facetResult, x, y, colorDistances);
        //                             // copy over color of closest neighbour
        //                             imgColorIndices.set(x, y, facetResult.facets[closestNeighbour]!.color);
        //                             console.log("Flagged " + x + "," + y + " to trim");
        //                         }
        //                     }
        //                 }
        //             }
        //             if (facetPointsToReallocate.length > 0) {
        //                 FacetReducer.rebuildForFacetChange(visitedArrayCache, facet, imgColorIndices, facetResult);
        //             }
        //         }
        //     }
        // }
        /**
         * Deletes a facet. All points belonging to the facet are moved to the nearest neighbour facet
         * based on the distance of the neighbour border points. This results in a voronoi like filling in of the
         * void the deletion made
         */
        static deleteFacet(facetIdToRemove, facetResult, imgColorIndices, colorDistances, visitedArrayCache) {
            const facetToRemove = facetResult.facets[facetIdToRemove];
            if (facetToRemove === null) { // already removed
                return;
            }
            if (facetToRemove.neighbourFacetsIsDirty) {
                facetCreator_1.FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
            }
            if (facetToRemove.neighbourFacets.length > 0) {
                // there are many small facets, it's faster to just iterate over all points within its bounding box
                // and seeing which belong to the facet than to keep track of the inner points (along with the border points)
                // per facet, because that generates a lot of extra heap objects that need to be garbage collected each time
                // a facet is rebuilt
                for (let j = facetToRemove.bbox.minY; j <= facetToRemove.bbox.maxY; j++) {
                    for (let i = facetToRemove.bbox.minX; i <= facetToRemove.bbox.maxX; i++) {
                        if (facetResult.facetMap.get(i, j) === facetToRemove.id) {
                            const closestNeighbour = FacetReducer.getClosestNeighbourForPixel(facetToRemove, facetResult, i, j, colorDistances);
                            if (closestNeighbour !== -1) {
                                // copy over color of closest neighbour
                                imgColorIndices.set(i, j, facetResult.facets[closestNeighbour].color);
                            }
                            else {
                                console.warn(`No closest neighbour found for point ${i},${j}`);
                            }
                        }
                    }
                }
            }
            else {
                console.warn(`Facet ${facetToRemove.id} does not have any neighbours`);
            }
            // Rebuild all the neighbour facets that have been changed. While it could probably be faster by just adding the points manually
            // to the facet map and determine if the border points are still valid, it's more complex than that. It's possible that due to the change in points
            // that 2 neighbours of the same colors have become linked and need to merged as well. So it's easier to just rebuild the entire facet
            FacetReducer.rebuildForFacetChange(visitedArrayCache, facetToRemove, imgColorIndices, facetResult);
            // now mark the facet to remove as deleted
            facetResult.facets[facetToRemove.id] = null;
        }
        static rebuildForFacetChange(visitedArrayCache, facet, imgColorIndices, facetResult) {
            FacetReducer.rebuildChangedNeighbourFacets(visitedArrayCache, facet, imgColorIndices, facetResult);
            // sanity check: make sure that all points have been replaced by neighbour facets. It's possible that some points will have
            // been left out because there is no continuity with the neighbour points
            // this occurs for diagonal points to the neighbours and more often when the closest
            // color is chosen when distances are equal.
            // It's probably possible to enforce that this will never happen in the above code but
            // this is a constraint that is expensive to enforce and doesn't happen all that much
            // so instead try and merge if with any of its direct neighbours if possible
            let needsToRebuild = false;
            for (let y = facet.bbox.minY; y <= facet.bbox.maxY; y++) {
                for (let x = facet.bbox.minX; x <= facet.bbox.maxX; x++) {
                    if (facetResult.facetMap.get(x, y) === facet.id) {
                        console.warn(`Point ${x},${y} was reallocated to neighbours for facet ${facet.id}`);
                        needsToRebuild = true;
                        if (x - 1 >= 0 && facetResult.facetMap.get(x - 1, y) !== facet.id && facetResult.facets[facetResult.facetMap.get(x - 1, y)] !== null) {
                            imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x - 1, y)].color);
                        }
                        else if (y - 1 >= 0 && facetResult.facetMap.get(x, y - 1) !== facet.id && facetResult.facets[facetResult.facetMap.get(x, y - 1)] !== null) {
                            imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x, y - 1)].color);
                        }
                        else if (x + 1 < facetResult.width && facetResult.facetMap.get(x + 1, y) !== facet.id && facetResult.facets[facetResult.facetMap.get(x + 1, y)] !== null) {
                            imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x + 1, y)].color);
                        }
                        else if (y + 1 < facetResult.height && facetResult.facetMap.get(x, y + 1) !== facet.id && facetResult.facets[facetResult.facetMap.get(x, y + 1)] !== null) {
                            imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x, y + 1)].color);
                        }
                        else {
                            console.error(`Unable to reallocate point ${x},${y}`);
                        }
                    }
                }
            }
            // now we need to go through the thing again to build facets and update the neighbours
            if (needsToRebuild) {
                FacetReducer.rebuildChangedNeighbourFacets(visitedArrayCache, facet, imgColorIndices, facetResult);
            }
        }
        /**
         * Determines the closest neighbour for a given pixel of a facet, based on the closest distance to the neighbour AND the when tied, the closest color
         */
        static getClosestNeighbourForPixel(facetToRemove, facetResult, x, y, colorDistances) {
            let closestNeighbour = -1;
            let minDistance = Number.MAX_VALUE;
            let minColorDistance = Number.MAX_VALUE;
            // ensure the neighbour facets is up to date if it was marked as dirty
            if (facetToRemove.neighbourFacetsIsDirty) {
                facetCreator_1.FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
            }
            // determine which neighbour will receive the current point based on the distance, and if there are more with the same
            // distance, then take the neighbour with the closes color
            for (const neighbourIdx of facetToRemove.neighbourFacets) {
                const neighbour = facetResult.facets[neighbourIdx];
                if (neighbour != null) {
                    for (const bpt of neighbour.borderPoints) {
                        const distance = bpt.distanceToCoord(x, y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestNeighbour = neighbourIdx;
                            minColorDistance = Number.MAX_VALUE; // reset color distance
                        }
                        else if (distance === minDistance) {
                            // if the distance is equal as the min distance
                            // then see if the neighbour's color is closer to the current color
                            // note: this causes morepoints to be reallocated to different neighbours
                            // in the sanity check later, but still yields a better visual result
                            const colorDistance = colorDistances[facetToRemove.color][neighbour.color];
                            if (colorDistance < minColorDistance) {
                                minColorDistance = colorDistance;
                                closestNeighbour = neighbourIdx;
                            }
                        }
                    }
                }
            }
            return closestNeighbour;
        }
        /**
         *  Rebuilds the given changed facets
         */
        static rebuildChangedNeighbourFacets(visitedArrayCache, facetToRemove, imgColorIndices, facetResult) {
            const changedNeighboursSet = {};
            if (facetToRemove.neighbourFacetsIsDirty) {
                facetCreator_1.FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
            }
            for (const neighbourIdx of facetToRemove.neighbourFacets) {
                const neighbour = facetResult.facets[neighbourIdx];
                if (neighbour != null) {
                    // re-evaluate facet
                    // track all the facets that needs to have their neighbour list updated, which is also going to be all the neighbours of the neighbours that are being updated
                    changedNeighboursSet[neighbourIdx] = true;
                    if (neighbour.neighbourFacetsIsDirty) {
                        facetCreator_1.FacetCreator.buildFacetNeighbour(neighbour, facetResult);
                    }
                    for (const n of neighbour.neighbourFacets) {
                        changedNeighboursSet[n] = true;
                    }
                    // rebuild the neighbour facet
                    const newFacet = facetCreator_1.FacetCreator.buildFacet(neighbourIdx, neighbour.color, neighbour.borderPoints[0].x, neighbour.borderPoints[0].y, visitedArrayCache, imgColorIndices, facetResult);
                    facetResult.facets[neighbourIdx] = newFacet;
                    // it's possible that any of the neighbour facets are now overlapping
                    // because if for example facet Red - Green - Red, Green is removed
                    // then it will become Red - Red and both facets will overlap
                    // this means the facet will have 0 points remaining
                    if (newFacet.pointCount === 0) {
                        // remove the empty facet as well
                        facetResult.facets[neighbourIdx] = null;
                    }
                }
            }
            // reset the visited array for all neighbours
            // while the visited array could be recreated per facet to remove, it's quite big and introduces
            // a lot of allocation / cleanup overhead. Due to the size of the facets it's usually faster
            // to just flag every point of the facet as false again
            if (facetToRemove.neighbourFacetsIsDirty) {
                facetCreator_1.FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
            }
            for (const neighbourIdx of facetToRemove.neighbourFacets) {
                const neighbour = facetResult.facets[neighbourIdx];
                if (neighbour != null) {
                    for (let y = neighbour.bbox.minY; y <= neighbour.bbox.maxY; y++) {
                        for (let x = neighbour.bbox.minX; x <= neighbour.bbox.maxX; x++) {
                            if (facetResult.facetMap.get(x, y) === neighbour.id) {
                                visitedArrayCache.set(x, y, false);
                            }
                        }
                    }
                }
            }
            // rebuild neighbour array for affected neighbours
            for (const k of Object.keys(changedNeighboursSet)) {
                if (changedNeighboursSet.hasOwnProperty(k)) {
                    const neighbourIdx = parseInt(k);
                    const f = facetResult.facets[neighbourIdx];
                    if (f != null) {
                        // it's a lot faster when deferring the neighbour array updates
                        // because a lot of facets that are deleted share the same facet neighbours
                        // and removing the unnecessary neighbour array checks until they it's needed
                        // speeds things up significantly
                        // FacetCreator.buildFacetNeighbour(f, facetResult);
                        f.neighbourFacets = null;
                        f.neighbourFacetsIsDirty = true;
                    }
                }
            }
        }
    }
    exports.FacetReducer = FacetReducer;
});
define("facetCreator", ["require", "exports", "common", "lib/fill", "structs/boundingbox", "structs/point", "structs/typedarrays", "facetmanagement"], function (require, exports, common_5, fill_1, boundingbox_1, point_4, typedarrays_4, facetmanagement_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FacetCreator {
        /**
         *  Constructs the facets with its border points for each area of pixels of the same color
         */
        static getFacets(width, height, imgColorIndices, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = new facetmanagement_3.FacetResult();
                result.width = width;
                result.height = height;
                // setup visited mask
                const visited = new typedarrays_4.BooleanArray2D(result.width, result.height);
                // setup facet map & array
                result.facetMap = new typedarrays_4.Uint32Array2D(result.width, result.height);
                result.facets = [];
                // depth first traversal to find the different facets
                let count = 0;
                for (let j = 0; j < result.height; j++) {
                    for (let i = 0; i < result.width; i++) {
                        const colorIndex = imgColorIndices.get(i, j);
                        if (!visited.get(i, j)) {
                            const facetIndex = result.facets.length;
                            // build a facet starting at point i,j
                            const facet = FacetCreator.buildFacet(facetIndex, colorIndex, i, j, visited, imgColorIndices, result);
                            result.facets.push(facet);
                            if (count % 100 === 0) {
                                yield common_5.delay(0);
                                if (onUpdate != null) {
                                    onUpdate(count / (result.width * result.height));
                                }
                            }
                        }
                        count++;
                    }
                }
                yield common_5.delay(0);
                // fill in the neighbours of all facets by checking the neighbours of the border points
                for (const f of result.facets) {
                    if (f != null) {
                        FacetCreator.buildFacetNeighbour(f, result);
                    }
                }
                if (onUpdate != null) {
                    onUpdate(1);
                }
                return result;
            });
        }
        /**
         *  Builds a facet at given x,y using depth first search to visit all pixels of the same color
         */
        static buildFacet(facetIndex, facetColorIndex, x, y, visited, imgColorIndices, facetResult) {
            const facet = new facetmanagement_3.Facet();
            facet.id = facetIndex;
            facet.color = facetColorIndex;
            facet.bbox = new boundingbox_1.BoundingBox();
            facet.borderPoints = [];
            facet.neighbourFacetsIsDirty = true; // not built neighbours yet
            facet.neighbourFacets = null;
            fill_1.fill(x, y, facetResult.width, facetResult.height, (ptx, pty) => visited.get(ptx, pty) || imgColorIndices.get(ptx, pty) !== facetColorIndex, (ptx, pty) => {
                visited.set(ptx, pty, true);
                facetResult.facetMap.set(ptx, pty, facetIndex);
                facet.pointCount++;
                // determine if the point is a border or not
                /*  const isInnerPoint = (ptx - 1 >= 0 && imgColorIndices.get(ptx - 1, pty) === facetColorIndex) &&
                      (pty - 1 >= 0 && imgColorIndices.get(ptx, pty - 1) === facetColorIndex) &&
                      (ptx + 1 < facetResult.width && imgColorIndices.get(ptx + 1, pty) === facetColorIndex) &&
                      (pty + 1 < facetResult.height && imgColorIndices.get(ptx, pty + 1) === facetColorIndex);
                */
                const isInnerPoint = imgColorIndices.matchAllAround(ptx, pty, facetColorIndex);
                if (!isInnerPoint) {
                    facet.borderPoints.push(new point_4.Point(ptx, pty));
                }
                // update bounding box of facet
                if (ptx > facet.bbox.maxX) {
                    facet.bbox.maxX = ptx;
                }
                if (pty > facet.bbox.maxY) {
                    facet.bbox.maxY = pty;
                }
                if (ptx < facet.bbox.minX) {
                    facet.bbox.minX = ptx;
                }
                if (pty < facet.bbox.minY) {
                    facet.bbox.minY = pty;
                }
            });
            /*
               // using a 1D flattened stack (x*width+y), we can avoid heap allocations of Point objects, which halves the garbage collection time
             let stack: number[] = [];
             stack.push(y * facetResult.width + x);
    
             while (stack.length > 0) {
                 let pt = stack.pop()!;
                 let ptx = pt % facetResult.width;
                 let pty = Math.floor(pt / facetResult.width);
    
                 // if the point wasn't visited before and matches
                 // the same color
                 if (!visited.get(ptx, pty) &&
                     imgColorIndices.get(ptx, pty) == facetColorIndex) {
    
                     visited.set(ptx, pty, true);
                     facetResult.facetMap.set(ptx, pty, facetIndex);
                     facet.pointCount++;
    
                     // determine if the point is a border or not
                     let isInnerPoint = (ptx - 1 >= 0 && imgColorIndices.get(ptx - 1, pty) == facetColorIndex) &&
                         (pty - 1 >= 0 && imgColorIndices.get(ptx, pty - 1) == facetColorIndex) &&
                         (ptx + 1 < facetResult.width && imgColorIndices.get(ptx + 1, pty) == facetColorIndex) &&
                         (pty + 1 < facetResult.height && imgColorIndices.get(ptx, pty + 1) == facetColorIndex);
    
                     if (!isInnerPoint)
                         facet.borderPoints.push(new Point(ptx, pty));
    
                     // update bounding box of facet
                     if (ptx > facet.bbox.maxX) facet.bbox.maxX = ptx;
                     if (pty > facet.bbox.maxY) facet.bbox.maxY = pty;
                     if (ptx < facet.bbox.minX) facet.bbox.minX = ptx;
                     if (pty < facet.bbox.minY) facet.bbox.minY = pty;
    
                     // visit direct adjacent points
                     if (ptx - 1 >= 0 && !visited.get(ptx - 1, pty))
                         stack.push(pty * facetResult.width + (ptx - 1)); //stack.push(new Point(pt.x - 1, pt.y));
                     if (pty - 1 >= 0 && !visited.get(ptx, pty - 1))
                         stack.push((pty - 1) * facetResult.width + ptx); //stack.push(new Point(pt.x, pt.y - 1));
                     if (ptx + 1 < facetResult.width && !visited.get(ptx + 1, pty))
                         stack.push(pty * facetResult.width + (ptx + 1));//stack.push(new Point(pt.x + 1, pt.y));
                     if (pty + 1 < facetResult.height && !visited.get(ptx, pty + 1))
                         stack.push((pty + 1) * facetResult.width + ptx); //stack.push(new Point(pt.x, pt.y + 1));
                 }
             }
             */
            return facet;
        }
        /**
         * Check which neighbour facets the given facet has by checking the neighbour facets at each border point
         */
        static buildFacetNeighbour(facet, facetResult) {
            facet.neighbourFacets = [];
            const uniqueFacets = {}; // poor man's set
            for (const pt of facet.borderPoints) {
                if (pt.x - 1 >= 0) {
                    const leftFacetId = facetResult.facetMap.get(pt.x - 1, pt.y);
                    if (leftFacetId !== facet.id) {
                        uniqueFacets[leftFacetId] = true;
                    }
                }
                if (pt.y - 1 >= 0) {
                    const topFacetId = facetResult.facetMap.get(pt.x, pt.y - 1);
                    if (topFacetId !== facet.id) {
                        uniqueFacets[topFacetId] = true;
                    }
                }
                if (pt.x + 1 < facetResult.width) {
                    const rightFacetId = facetResult.facetMap.get(pt.x + 1, pt.y);
                    if (rightFacetId !== facet.id) {
                        uniqueFacets[rightFacetId] = true;
                    }
                }
                if (pt.y + 1 < facetResult.height) {
                    const bottomFacetId = facetResult.facetMap.get(pt.x, pt.y + 1);
                    if (bottomFacetId !== facet.id) {
                        uniqueFacets[bottomFacetId] = true;
                    }
                }
            }
            for (const k of Object.keys(uniqueFacets)) {
                if (uniqueFacets.hasOwnProperty(k)) {
                    facet.neighbourFacets.push(parseInt(k));
                }
            }
            // the neighbour array is updated so it's not dirty anymore
            facet.neighbourFacetsIsDirty = false;
        }
    }
    exports.FacetCreator = FacetCreator;
});
define("lib/datastructs", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Map {
        constructor() {
            this.obj = {};
        }
        containsKey(key) {
            return key in this.obj;
        }
        getKeys() {
            const keys = [];
            for (const el in this.obj) {
                if (this.obj.hasOwnProperty(el)) {
                    keys.push(el);
                }
            }
            return keys;
        }
        get(key) {
            const o = this.obj[key];
            if (typeof o === "undefined") {
                return null;
            }
            else {
                return o;
            }
        }
        put(key, value) {
            this.obj[key] = value;
        }
        remove(key) {
            delete this.obj[key];
        }
        clone() {
            const m = new Map();
            m.obj = {};
            for (const p in this.obj) {
                m.obj[p] = this.obj[p];
            }
            return m;
        }
    }
    exports.Map = Map;
    class Heap {
        constructor() {
            this.array = [];
            this.keyMap = new Map();
        }
        add(obj) {
            if (this.keyMap.containsKey(obj.getKey())) {
                throw new Error("Item with key " + obj.getKey() + " already exists in the heap");
            }
            this.array.push(obj);
            this.keyMap.put(obj.getKey(), this.array.length - 1);
            this.checkParentRequirement(this.array.length - 1);
        }
        replaceAt(idx, newobj) {
            this.array[idx] = newobj;
            this.keyMap.put(newobj.getKey(), idx);
            this.checkParentRequirement(idx);
            this.checkChildrenRequirement(idx);
        }
        shift() {
            return this.removeAt(0);
        }
        remove(obj) {
            const idx = this.keyMap.get(obj.getKey());
            if (idx === -1) {
                return;
            }
            this.removeAt(idx);
        }
        removeWhere(predicate) {
            const itemsToRemove = [];
            for (let i = this.array.length - 1; i >= 0; i--) {
                if (predicate(this.array[i])) {
                    itemsToRemove.push(this.array[i]);
                }
            }
            for (const el of itemsToRemove) {
                this.remove(el);
            }
            for (const el of this.array) {
                if (predicate(el)) {
                    console.log("Idx of element not removed: " + this.keyMap.get(el.getKey()));
                    throw new Error("element not removed: " + el.getKey());
                }
            }
        }
        removeAt(idx) {
            const obj = this.array[idx];
            this.keyMap.remove(obj.getKey());
            const isLastElement = idx === this.array.length - 1;
            if (this.array.length > 0) {
                const newobj = this.array.pop();
                if (!isLastElement && this.array.length > 0) {
                    this.replaceAt(idx, newobj);
                }
            }
            return obj;
        }
        foreach(func) {
            const arr = this.array.sort((e, e2) => e.compareTo(e2));
            for (const el of arr) {
                func(el);
            }
        }
        peek() {
            return this.array[0];
        }
        contains(key) {
            return this.keyMap.containsKey(key);
        }
        at(key) {
            const obj = this.keyMap.get(key);
            if (typeof obj === "undefined") {
                return null;
            }
            else {
                return this.array[obj];
            }
        }
        size() {
            return this.array.length;
        }
        checkHeapRequirement(item) {
            const idx = this.keyMap.get(item.getKey());
            if (idx != null) {
                this.checkParentRequirement(idx);
                this.checkChildrenRequirement(idx);
            }
        }
        checkChildrenRequirement(idx) {
            let stop = false;
            while (!stop) {
                const left = this.getLeftChildIndex(idx);
                let right = left === -1 ? -1 : left + 1;
                if (left === -1) {
                    return;
                }
                if (right >= this.size()) {
                    right = -1;
                }
                let minIdx;
                if (right === -1) {
                    minIdx = left;
                }
                else {
                    minIdx = (this.array[left].compareTo(this.array[right]) < 0) ? left : right;
                }
                if (this.array[idx].compareTo(this.array[minIdx]) > 0) {
                    this.swap(idx, minIdx);
                    idx = minIdx; // iteratively instead of recursion for this.checkChildrenRequirement(minIdx);
                }
                else {
                    stop = true;
                }
            }
        }
        checkParentRequirement(idx) {
            let curIdx = idx;
            let parentIdx = Heap.getParentIndex(curIdx);
            while (parentIdx >= 0 && this.array[parentIdx].compareTo(this.array[curIdx]) > 0) {
                this.swap(curIdx, parentIdx);
                curIdx = parentIdx;
                parentIdx = Heap.getParentIndex(curIdx);
            }
        }
        dump() {
            if (this.size() === 0) {
                return;
            }
            const idx = 0;
            const leftIdx = this.getLeftChildIndex(idx);
            const rightIdx = leftIdx + 1;
            console.log(this.array);
            console.log("--- keymap ---");
            console.log(this.keyMap);
        }
        swap(i, j) {
            this.keyMap.put(this.array[i].getKey(), j);
            this.keyMap.put(this.array[j].getKey(), i);
            const tmp = this.array[i];
            this.array[i] = this.array[j];
            this.array[j] = tmp;
        }
        getLeftChildIndex(curIdx) {
            const idx = ((curIdx + 1) * 2) - 1;
            if (idx >= this.array.length) {
                return -1;
            }
            else {
                return idx;
            }
        }
        static getParentIndex(curIdx) {
            if (curIdx === 0) {
                return -1;
            }
            return Math.floor((curIdx + 1) / 2) - 1;
        }
        clone() {
            const h = new Heap();
            h.array = this.array.slice(0);
            h.keyMap = this.keyMap.clone();
            return h;
        }
    }
    class PriorityQueue {
        constructor() {
            this.heap = new Heap();
        }
        enqueue(obj) {
            this.heap.add(obj);
        }
        peek() {
            return this.heap.peek();
        }
        updatePriority(key) {
            this.heap.checkHeapRequirement(key);
        }
        get(key) {
            return this.heap.at(key);
        }
        get size() {
            return this.heap.size();
        }
        dequeue() {
            return this.heap.shift();
        }
        dump() {
            this.heap.dump();
        }
        contains(key) {
            return this.heap.contains(key);
        }
        removeWhere(predicate) {
            this.heap.removeWhere(predicate);
        }
        foreach(func) {
            this.heap.foreach(func);
        }
        clone() {
            const p = new PriorityQueue();
            p.heap = this.heap.clone();
            return p;
        }
    }
    exports.PriorityQueue = PriorityQueue;
});
define("lib/polylabel", ["require", "exports", "lib/datastructs"], function (require, exports, datastructs_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function polylabel(polygon, precision = 1.0) {
        // find the bounding box of the outer ring
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxX = Number.MIN_VALUE;
        let maxY = Number.MIN_VALUE;
        for (let i = 0; i < polygon[0].length; i++) {
            const p = polygon[0][i];
            if (p.x < minX) {
                minX = p.x;
            }
            if (p.y < minY) {
                minY = p.y;
            }
            if (p.x > maxX) {
                maxX = p.x;
            }
            if (p.y > maxY) {
                maxY = p.y;
            }
        }
        const width = maxX - minX;
        const height = maxY - minY;
        const cellSize = Math.min(width, height);
        let h = cellSize / 2;
        // a priority queue of cells in order of their "potential" (max distance to polygon)
        const cellQueue = new datastructs_1.PriorityQueue();
        if (cellSize === 0) {
            return { pt: { x: minX, y: minY }, distance: 0 };
        }
        // cover polygon with initial cells
        for (let x = minX; x < maxX; x += cellSize) {
            for (let y = minY; y < maxY; y += cellSize) {
                cellQueue.enqueue(new Cell(x + h, y + h, h, polygon));
            }
        }
        // take centroid as the first best guess
        let bestCell = getCentroidCell(polygon);
        // special case for rectangular polygons
        const bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
        if (bboxCell.d > bestCell.d) {
            bestCell = bboxCell;
        }
        let numProbes = cellQueue.size;
        while (cellQueue.size > 0) {
            // pick the most promising cell from the queue
            const cell = cellQueue.dequeue();
            // update the best cell if we found a better one
            if (cell.d > bestCell.d) {
                bestCell = cell;
            }
            // do not drill down further if there's no chance of a better solution
            if (cell.max - bestCell.d <= precision) {
                continue;
            }
            // split the cell into four cells
            h = cell.h / 2;
            cellQueue.enqueue(new Cell(cell.x - h, cell.y - h, h, polygon));
            cellQueue.enqueue(new Cell(cell.x + h, cell.y - h, h, polygon));
            cellQueue.enqueue(new Cell(cell.x - h, cell.y + h, h, polygon));
            cellQueue.enqueue(new Cell(cell.x + h, cell.y + h, h, polygon));
            numProbes += 4;
        }
        return { pt: { x: bestCell.x, y: bestCell.y }, distance: bestCell.d };
    }
    exports.polylabel = polylabel;
    class Cell {
        constructor(x, y, h, polygon) {
            this.x = x;
            this.y = y;
            this.h = h;
            this.d = pointToPolygonDist(x, y, polygon);
            this.max = this.d + this.h * Math.SQRT2;
        }
        compareTo(other) {
            return other.max - this.max;
        }
        getKey() {
            return this.x + "," + this.y;
        }
    }
    // get squared distance from a point px,py to a segment [a-b]
    function getSegDistSq(px, py, a, b) {
        let x = a.x;
        let y = a.y;
        let dx = b.x - x;
        let dy = b.y - y;
        if (dx !== 0 || dy !== 0) {
            const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
            if (t > 1) {
                x = b.x;
                y = b.y;
            }
            else if (t > 0) {
                x += dx * t;
                y += dy * t;
            }
        }
        dx = px - x;
        dy = py - y;
        return dx * dx + dy * dy;
    }
    /**
     * Signed distance from point to polygon outline (negative if point is outside)
     */
    function pointToPolygonDist(x, y, polygon) {
        let inside = false;
        let minDistSq = Infinity;
        for (let k = 0; k < polygon.length; k++) {
            const ring = polygon[k];
            for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
                const a = ring[i];
                const b = ring[j];
                if ((a.y > y !== b.y > y) &&
                    (x < (b.x - a.x) * (y - a.y) / (b.y - a.y) + a.x)) {
                    inside = !inside;
                }
                minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
            }
        }
        return (inside ? 1 : -1) * Math.sqrt(minDistSq);
    }
    exports.pointToPolygonDist = pointToPolygonDist;
    // get polygon centroid
    function getCentroidCell(polygon) {
        let area = 0;
        let x = 0;
        let y = 0;
        const points = polygon[0];
        for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            const a = points[i];
            const b = points[j];
            const f = a.x * b.y - b.x * a.y;
            x += (a.x + b.x) * f;
            y += (a.y + b.y) * f;
            area += f * 3;
        }
        if (area === 0) {
            return new Cell(points[0].x, points[0].y, 0, polygon);
        }
        return new Cell(x / area, y / area, 0, polygon);
    }
});
define("facetLabelPlacer", ["require", "exports", "common", "lib/polylabel", "structs/boundingbox", "facetCreator"], function (require, exports, common_6, polylabel_1, boundingbox_2, facetCreator_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FacetLabelPlacer {
        /**
         *  Determines where to place the labels for each facet. This is done by calculating where
         *  in the polygon the largest circle can be contained, also called the pole of inaccessibility
         *  That's the spot where there will be the most room for the label.
         *  One tricky gotcha: neighbour facets can lay completely inside other facets and can overlap the label
         *  if only the outer border of the facet is taken in account. This is solved by adding the neighbours facet polygon that fall
         *  within the facet as additional polygon rings (why does everything look so easy to do yet never is under the hood :/)
         */
        static buildFacetLabelBounds(facetResult, onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                let count = 0;
                for (const f of facetResult.facets) {
                    if (f != null) {
                        const polyRings = [];
                        // get the border path from the segments (that can have been reduced compared to facet actual border path)
                        const borderPath = f.getFullPathFromBorderSegments(true);
                        // outer path must be first ring
                        polyRings.push(borderPath);
                        const onlyOuterRing = [borderPath];
                        // now add all the neighbours of the facet as "inner" rings,
                        // regardless if they are inner or not. These are seen as areas where the label
                        // cannot be placed
                        if (f.neighbourFacetsIsDirty) {
                            facetCreator_2.FacetCreator.buildFacetNeighbour(f, facetResult);
                        }
                        for (const neighbourIdx of f.neighbourFacets) {
                            const neighbourPath = facetResult.facets[neighbourIdx].getFullPathFromBorderSegments(true);
                            const fallsInside = FacetLabelPlacer.doesNeighbourFallInsideInCurrentFacet(neighbourPath, f, onlyOuterRing);
                            if (fallsInside) {
                                polyRings.push(neighbourPath);
                            }
                        }
                        const result = polylabel_1.polylabel(polyRings);
                        f.labelBounds = new boundingbox_2.BoundingBox();
                        // determine inner square within the circle
                        const innerPadding = 2 * Math.sqrt(2 * result.distance);
                        f.labelBounds.minX = result.pt.x - innerPadding;
                        f.labelBounds.maxX = result.pt.x + innerPadding;
                        f.labelBounds.minY = result.pt.y - innerPadding;
                        f.labelBounds.maxY = result.pt.y + innerPadding;
                        if (count % 100 === 0) {
                            yield common_6.delay(0);
                            if (onUpdate != null) {
                                onUpdate(f.id / facetResult.facets.length);
                            }
                        }
                    }
                    count++;
                }
                if (onUpdate != null) {
                    onUpdate(1);
                }
            });
        }
        /**
         *  Checks whether a neighbour border path is fully within the current facet border path
         */
        static doesNeighbourFallInsideInCurrentFacet(neighbourPath, f, onlyOuterRing) {
            let fallsInside = true;
            // fast test to see if the neighbour falls inside the bbox of the facet
            for (let i = 0; i < neighbourPath.length && fallsInside; i++) {
                if (neighbourPath[i].x >= f.bbox.minX && neighbourPath[i].x <= f.bbox.maxX &&
                    neighbourPath[i].y >= f.bbox.minY && neighbourPath[i].y <= f.bbox.maxY) {
                    // ok
                }
                else {
                    fallsInside = false;
                }
            }
            if (fallsInside) {
                // do a more fine grained but more expensive check to see if each of the points fall within the polygon
                for (let i = 0; i < neighbourPath.length && fallsInside; i++) {
                    const distance = polylabel_1.pointToPolygonDist(neighbourPath[i].x, neighbourPath[i].y, onlyOuterRing);
                    if (distance < 0) {
                        // falls outside
                        fallsInside = false;
                    }
                }
            }
            return fallsInside;
        }
    }
    exports.FacetLabelPlacer = FacetLabelPlacer;
});
/**
 * Module that manages the GUI when processing
 */
define("guiprocessmanager", ["require", "exports", "colorreductionmanagement", "common", "facetBorderSegmenter", "facetBorderTracer", "facetCreator", "facetLabelPlacer", "facetmanagement", "facetReducer", "gui", "structs/point"], function (require, exports, colorreductionmanagement_2, common_7, facetBorderSegmenter_1, facetBorderTracer_1, facetCreator_3, facetLabelPlacer_1, facetmanagement_4, facetReducer_1, gui_1, point_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ProcessResult {
    }
    exports.ProcessResult = ProcessResult;
    /**
     *  Manages the GUI states & processes the image step by step
     */
    class GUIProcessManager {
        static process(settings, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                const c = document.getElementById("canvas");
                const ctx = c.getContext("2d");
                let imgData = ctx.getImageData(0, 0, c.width, c.height);
                if (settings.resizeImageIfTooLarge && (c.width > settings.resizeImageWidth || c.height > settings.resizeImageHeight)) {
                    let width = c.width;
                    let height = c.height;
                    if (width > settings.resizeImageWidth) {
                        const newWidth = settings.resizeImageWidth;
                        const newHeight = c.height / c.width * settings.resizeImageWidth;
                        width = newWidth;
                        height = newHeight;
                    }
                    if (height > settings.resizeImageHeight) {
                        const newHeight = settings.resizeImageHeight;
                        const newWidth = width / height * newHeight;
                        width = newWidth;
                        height = newHeight;
                    }
                    const tempCanvas = document.createElement("canvas");
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    tempCanvas.getContext("2d").drawImage(c, 0, 0, width, height);
                    c.width = width;
                    c.height = height;
                    ctx.drawImage(tempCanvas, 0, 0, width, height);
                    imgData = ctx.getImageData(0, 0, c.width, c.height);
                }
                // reset progress
                $(".status .progress .determinate").css("width", "0px");
                $(".status").removeClass("complete");
                const tabsOutput = M.Tabs.getInstance(document.getElementById("tabsOutput"));
                // k-means clustering
                const kmeansImgData = yield GUIProcessManager.processKmeansClustering(imgData, tabsOutput, ctx, settings, cancellationToken);
                let facetResult = new facetmanagement_4.FacetResult();
                let colormapResult = new colorreductionmanagement_2.ColorMapResult();
                // build color map
                colormapResult = colorreductionmanagement_2.ColorReducer.createColorMap(kmeansImgData);
                if (settings.narrowPixelStripCleanupRuns === 0) {
                    // facet building
                    facetResult = yield GUIProcessManager.processFacetBuilding(colormapResult, cancellationToken);
                    // facet reduction
                    yield GUIProcessManager.processFacetReduction(facetResult, tabsOutput, settings, colormapResult, cancellationToken);
                }
                else {
                    for (let run = 0; run < settings.narrowPixelStripCleanupRuns; run++) {
                        // clean up narrow pixel strips
                        yield colorreductionmanagement_2.ColorReducer.processNarrowPixelStripCleanup(colormapResult);
                        // facet building
                        facetResult = yield GUIProcessManager.processFacetBuilding(colormapResult, cancellationToken);
                        // facet reduction
                        yield GUIProcessManager.processFacetReduction(facetResult, tabsOutput, settings, colormapResult, cancellationToken);
                        // the colormapResult.imgColorIndices get updated as the facets are reduced, so just do a few runs of pixel cleanup
                    }
                }
                // facet border tracing
                yield GUIProcessManager.processFacetBorderTracing(tabsOutput, facetResult, cancellationToken);
                // facet border segmentation
                const cBorderSegment = yield GUIProcessManager.processFacetBorderSegmentation(facetResult, tabsOutput, settings, cancellationToken);
                // facet label placement
                yield GUIProcessManager.processFacetLabelPlacement(facetResult, cBorderSegment, tabsOutput, cancellationToken);
                // everything is now ready to generate the SVG, return the result
                const processResult = new ProcessResult();
                processResult.facetResult = facetResult;
                processResult.colorsByIndex = colormapResult.colorsByIndex;
                return processResult;
            });
        }
        static processKmeansClustering(imgData, tabsOutput, ctx, settings, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                gui_1.time("K-means clustering");
                const cKmeans = document.getElementById("cKMeans");
                cKmeans.width = imgData.width;
                cKmeans.height = imgData.height;
                const ctxKmeans = cKmeans.getContext("2d");
                ctxKmeans.fillStyle = "white";
                ctxKmeans.fillRect(0, 0, cKmeans.width, cKmeans.height);
                const kmeansImgData = ctxKmeans.getImageData(0, 0, cKmeans.width, cKmeans.height);
                tabsOutput.select("kmeans-pane");
                $(".status.kMeans").addClass("active");
                yield colorreductionmanagement_2.ColorReducer.applyKMeansClustering(imgData, kmeansImgData, ctx, settings, (kmeans) => {
                    const progress = (100 - (kmeans.currentDeltaDistanceDifference > 100 ? 100 : kmeans.currentDeltaDistanceDifference)) / 100;
                    $("#statusKMeans").css("width", Math.round(progress * 100) + "%");
                    ctxKmeans.putImageData(kmeansImgData, 0, 0);
                    console.log(kmeans.currentDeltaDistanceDifference);
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                });
                $(".status").removeClass("active");
                $(".status.kMeans").addClass("complete");
                gui_1.timeEnd("K-means clustering");
                return kmeansImgData;
            });
        }
        static processFacetBuilding(colormapResult, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                gui_1.time("Facet building");
                $(".status.facetBuilding").addClass("active");
                const facetResult = yield facetCreator_3.FacetCreator.getFacets(colormapResult.width, colormapResult.height, colormapResult.imgColorIndices, (progress) => {
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                    $("#statusFacetBuilding").css("width", Math.round(progress * 100) + "%");
                });
                $(".status").removeClass("active");
                $(".status.facetBuilding").addClass("complete");
                gui_1.timeEnd("Facet building");
                return facetResult;
            });
        }
        static processFacetReduction(facetResult, tabsOutput, settings, colormapResult, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                gui_1.time("Facet reduction");
                const cReduction = document.getElementById("cReduction");
                cReduction.width = facetResult.width;
                cReduction.height = facetResult.height;
                const ctxReduction = cReduction.getContext("2d");
                ctxReduction.fillStyle = "white";
                ctxReduction.fillRect(0, 0, cReduction.width, cReduction.height);
                const reductionImgData = ctxReduction.getImageData(0, 0, cReduction.width, cReduction.height);
                tabsOutput.select("reduction-pane");
                $(".status.facetReduction").addClass("active");
                yield facetReducer_1.FacetReducer.reduceFacets(settings.removeFacetsSmallerThanNrOfPoints, settings.removeFacetsFromLargeToSmall, settings.maximumNumberOfFacets, colormapResult.colorsByIndex, facetResult, colormapResult.imgColorIndices, (progress) => {
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                    // update status & image
                    $("#statusFacetReduction").css("width", Math.round(progress * 100) + "%");
                    let idx = 0;
                    for (let j = 0; j < facetResult.height; j++) {
                        for (let i = 0; i < facetResult.width; i++) {
                            const facet = facetResult.facets[facetResult.facetMap.get(i, j)];
                            const rgb = colormapResult.colorsByIndex[facet.color];
                            reductionImgData.data[idx++] = rgb[0];
                            reductionImgData.data[idx++] = rgb[1];
                            reductionImgData.data[idx++] = rgb[2];
                            idx++;
                        }
                    }
                    ctxReduction.putImageData(reductionImgData, 0, 0);
                });
                $(".status").removeClass("active");
                $(".status.facetReduction").addClass("complete");
                gui_1.timeEnd("Facet reduction");
            });
        }
        static processFacetBorderTracing(tabsOutput, facetResult, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                gui_1.time("Facet border tracing");
                tabsOutput.select("borderpath-pane");
                const cBorderPath = document.getElementById("cBorderPath");
                cBorderPath.width = facetResult.width;
                cBorderPath.height = facetResult.height;
                const ctxBorderPath = cBorderPath.getContext("2d");
                $(".status.facetBorderPath").addClass("active");
                yield facetBorderTracer_1.FacetBorderTracer.buildFacetBorderPaths(facetResult, (progress) => {
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                    // update status & image
                    $("#statusFacetBorderPath").css("width", Math.round(progress * 100) + "%");
                    ctxBorderPath.fillStyle = "white";
                    ctxBorderPath.fillRect(0, 0, cBorderPath.width, cBorderPath.height);
                    for (const f of facetResult.facets) {
                        if (f != null && f.borderPath != null) {
                            ctxBorderPath.beginPath();
                            ctxBorderPath.moveTo(f.borderPath[0].getWallX(), f.borderPath[0].getWallY());
                            for (let i = 1; i < f.borderPath.length; i++) {
                                ctxBorderPath.lineTo(f.borderPath[i].getWallX(), f.borderPath[i].getWallY());
                            }
                            ctxBorderPath.stroke();
                        }
                    }
                });
                $(".status").removeClass("active");
                $(".status.facetBorderPath").addClass("complete");
                gui_1.timeEnd("Facet border tracing");
            });
        }
        static processFacetBorderSegmentation(facetResult, tabsOutput, settings, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                gui_1.time("Facet border segmentation");
                const cBorderSegment = document.getElementById("cBorderSegmentation");
                cBorderSegment.width = facetResult.width;
                cBorderSegment.height = facetResult.height;
                const ctxBorderSegment = cBorderSegment.getContext("2d");
                tabsOutput.select("bordersegmentation-pane");
                $(".status.facetBorderSegmentation").addClass("active");
                yield facetBorderSegmenter_1.FacetBorderSegmenter.buildFacetBorderSegments(facetResult, settings.nrOfTimesToHalveBorderSegments, (progress) => {
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                    // update status & image
                    $("#statusFacetBorderSegmentation").css("width", Math.round(progress * 100) + "%");
                    ctxBorderSegment.fillStyle = "white";
                    ctxBorderSegment.fillRect(0, 0, cBorderSegment.width, cBorderSegment.height);
                    for (const f of facetResult.facets) {
                        if (f != null && progress > f.id / facetResult.facets.length) {
                            ctxBorderSegment.beginPath();
                            const path = f.getFullPathFromBorderSegments(false);
                            ctxBorderSegment.moveTo(path[0].x, path[0].y);
                            for (let i = 1; i < path.length; i++) {
                                ctxBorderSegment.lineTo(path[i].x, path[i].y);
                            }
                            ctxBorderSegment.stroke();
                        }
                    }
                });
                $(".status").removeClass("active");
                $(".status.facetBorderSegmentation").addClass("complete");
                gui_1.timeEnd("Facet border segmentation");
                return cBorderSegment;
            });
        }
        static processFacetLabelPlacement(facetResult, cBorderSegment, tabsOutput, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                gui_1.time("Facet label placement");
                const cLabelPlacement = document.getElementById("cLabelPlacement");
                cLabelPlacement.width = facetResult.width;
                cLabelPlacement.height = facetResult.height;
                const ctxLabelPlacement = cLabelPlacement.getContext("2d");
                ctxLabelPlacement.fillStyle = "white";
                ctxLabelPlacement.fillRect(0, 0, cBorderSegment.width, cBorderSegment.height);
                ctxLabelPlacement.drawImage(cBorderSegment, 0, 0);
                tabsOutput.select("labelplacement-pane");
                $(".status.facetLabelPlacement").addClass("active");
                yield facetLabelPlacer_1.FacetLabelPlacer.buildFacetLabelBounds(facetResult, (progress) => {
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                    // update status & image
                    $("#statusFacetLabelPlacement").css("width", Math.round(progress * 100) + "%");
                    for (const f of facetResult.facets) {
                        if (f != null && f.labelBounds != null) {
                            ctxLabelPlacement.fillStyle = "red";
                            ctxLabelPlacement.fillRect(f.labelBounds.minX, f.labelBounds.minY, f.labelBounds.width, f.labelBounds.height);
                        }
                    }
                });
                $(".status").removeClass("active");
                $(".status.facetLabelPlacement").addClass("complete");
                gui_1.timeEnd("Facet label placement");
            });
        }
        /**
         *  Creates a vector based SVG image of the facets with the given configuration
         */
        static createSVG(facetResult, colorsByIndex, sizeMultiplier, fill, stroke, addColorLabels, fontSize = 50, fontColor = "black", onUpdate = null) {
            return __awaiter(this, void 0, void 0, function* () {
                const xmlns = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(xmlns, "svg");
                svg.setAttribute("width", sizeMultiplier * facetResult.width + "");
                svg.setAttribute("height", sizeMultiplier * facetResult.height + "");
                let count = 0;
                for (const f of facetResult.facets) {
                    if (f != null && f.borderSegments.length > 0) {
                        let newpath = [];
                        const useSegments = true;
                        if (useSegments) {
                            newpath = f.getFullPathFromBorderSegments(false);
                            // shift from wall coordinates to pixel centers
                            /*for (const p of newpath) {
                                p.x+=0.5;
                                p.y+=0.5;
                            }*/
                        }
                        else {
                            for (let i = 0; i < f.borderPath.length; i++) {
                                newpath.push(new point_5.Point(f.borderPath[i].getWallX() + 0.5, f.borderPath[i].getWallY() + 0.5));
                            }
                        }
                        if (newpath[0].x !== newpath[newpath.length - 1].x || newpath[0].y !== newpath[newpath.length - 1].y) {
                            newpath.push(newpath[0]);
                        } // close loop if necessary
                        // Create a path in SVG's namespace
                        // using quadratic curve absolute positions
                        const svgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        let data = "M ";
                        data += newpath[0].x * sizeMultiplier + " " + newpath[0].y * sizeMultiplier + " ";
                        for (let i = 1; i < newpath.length; i++) {
                            const midpointX = (newpath[i].x + newpath[i - 1].x) / 2;
                            const midpointY = (newpath[i].y + newpath[i - 1].y) / 2;
                            data += "Q " + (midpointX * sizeMultiplier) + " " + (midpointY * sizeMultiplier) + " " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
                            // data += "L " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
                        }
                        data += "Z";
                        svgPath.setAttribute("data-facetId", f.id + "");
                        // Set path's data
                        svgPath.setAttribute("d", data);
                        if (stroke) {
                            svgPath.style.stroke = "#000";
                        }
                        else {
                            // make the border the same color as the fill color if there is no border stroke
                            // to not have gaps in between facets
                            if (fill) {
                                svgPath.style.stroke = `rgb(${colorsByIndex[f.color][0]},${colorsByIndex[f.color][1]},${colorsByIndex[f.color][2]})`;
                            }
                        }
                        svgPath.style.strokeWidth = "1px"; // Set stroke width
                        if (fill) {
                            svgPath.style.fill = `rgb(${colorsByIndex[f.color][0]},${colorsByIndex[f.color][1]},${colorsByIndex[f.color][2]})`;
                        }
                        else {
                            svgPath.style.fill = "none";
                        }
                        svg.appendChild(svgPath);
                        /*  for (const seg of f.borderSegments) {
                              const svgSegPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                              let segData = "M ";
                              const segPoints = seg.originalSegment.points;
                              segData += segPoints[0].x * sizeMultiplier + " " + segPoints[0].y * sizeMultiplier + " ";
                              for (let i: number = 1; i < segPoints.length; i++) {
                                  const midpointX = (segPoints[i].x + segPoints[i - 1].x) / 2;
                                  const midpointY = (segPoints[i].y + segPoints[i - 1].y) / 2;
                                  //data += "Q " + (midpointX * sizeMultiplier) + " " + (midpointY * sizeMultiplier) + " " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
                                  segData += "L " + (segPoints[i].x * sizeMultiplier) + " " + (segPoints[i].y * sizeMultiplier) + " ";
                              }
        
                              console.log("Facet " + f.id + ", segment " + segPoints[0].x + "," + segPoints[0].y + " -> " + segPoints[segPoints.length-1].x + "," +  segPoints[segPoints.length-1].y);
        
                              svgSegPath.setAttribute("data-segmentFacet", f.id + "");
                              // Set path's data
                              svgSegPath.setAttribute("d", segData);
                              svgSegPath.style.stroke = "#FF0";
                              svgSegPath.style.fill = "none";
                              svg.appendChild(svgSegPath);
                          }
                          */
                        // add the color labels if necessary. I mean, this is the whole idea behind the paint by numbers part
                        // so I don't know why you would hide them
                        if (addColorLabels) {
                            const txt = document.createElementNS(xmlns, "text");
                            txt.setAttribute("font-family", "Tahoma");
                            const nrOfDigits = (f.color + "").length;
                            txt.setAttribute("font-size", (fontSize / nrOfDigits) + "");
                            txt.setAttribute("dominant-baseline", "middle");
                            txt.setAttribute("text-anchor", "middle");
                            txt.setAttribute("fill", fontColor);
                            txt.textContent = f.color + "";
                            const subsvg = document.createElementNS(xmlns, "svg");
                            subsvg.setAttribute("width", f.labelBounds.width * sizeMultiplier + "");
                            subsvg.setAttribute("height", f.labelBounds.height * sizeMultiplier + "");
                            subsvg.setAttribute("overflow", "visible");
                            subsvg.setAttribute("viewBox", "-50 -50 100 100");
                            subsvg.setAttribute("preserveAspectRatio", "xMidYMid meet");
                            subsvg.appendChild(txt);
                            const g = document.createElementNS(xmlns, "g");
                            g.setAttribute("class", "label");
                            g.setAttribute("transform", "translate(" + f.labelBounds.minX * sizeMultiplier + "," + f.labelBounds.minY * sizeMultiplier + ")");
                            g.appendChild(subsvg);
                            svg.appendChild(g);
                        }
                        if (count % 100 === 0) {
                            yield common_7.delay(0);
                            if (onUpdate != null) {
                                onUpdate(f.id / facetResult.facets.length);
                            }
                        }
                    }
                    count++;
                }
                if (onUpdate != null) {
                    onUpdate(1);
                }
                return svg;
            });
        }
    }
    exports.GUIProcessManager = GUIProcessManager;
});
/**
 * Module that provides function the GUI uses and updates the DOM accordingly
 */
define("gui", ["require", "exports", "common", "guiprocessmanager", "settings"], function (require, exports, common_8, guiprocessmanager_1, settings_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let processResult = null;
    let cancellationToken = new common_8.CancellationToken();
    const timers = {};
    function time(name) {
        console.time(name);
        timers[name] = new Date();
    }
    exports.time = time;
    function timeEnd(name) {
        console.timeEnd(name);
        const ms = new Date().getTime() - timers[name].getTime();
        log(name + ": " + ms + "ms");
        delete timers[name];
    }
    exports.timeEnd = timeEnd;
    function log(str) {
        $("#log").append("<br/><span>" + str + "</span>");
    }
    exports.log = log;
    function parseSettings() {
        const settings = new settings_2.Settings();
        if ($("#optColorSpaceRGB").prop("checked")) {
            settings.kMeansClusteringColorSpace = settings_2.ClusteringColorSpace.RGB;
        }
        else if ($("#optColorSpaceHSL").prop("checked")) {
            settings.kMeansClusteringColorSpace = settings_2.ClusteringColorSpace.HSL;
        }
        else if ($("#optColorSpaceRGB").prop("checked")) {
            settings.kMeansClusteringColorSpace = settings_2.ClusteringColorSpace.LAB;
        }
        if ($("#optFacetRemovalLargestToSmallest").prop("checked")) {
            settings.removeFacetsFromLargeToSmall = true;
        }
        else {
            settings.removeFacetsFromLargeToSmall = false;
        }
        settings.randomSeed = parseInt($("#txtRandomSeed").val() + "");
        settings.kMeansNrOfClusters = parseInt($("#txtNrOfClusters").val() + "");
        settings.kMeansMinDeltaDifference = parseFloat($("#txtClusterPrecision").val() + "");
        settings.removeFacetsSmallerThanNrOfPoints = parseInt($("#txtRemoveFacetsSmallerThan").val() + "");
        settings.maximumNumberOfFacets = parseInt($("#txtMaximumNumberOfFacets").val() + "");
        settings.nrOfTimesToHalveBorderSegments = parseInt($("#txtNrOfTimesToHalveBorderSegments").val() + "");
        settings.narrowPixelStripCleanupRuns = parseInt($("#txtNarrowPixelStripCleanupRuns").val() + "");
        settings.resizeImageIfTooLarge = $("#chkResizeImage").prop("checked");
        settings.resizeImageWidth = parseInt($("#txtResizeWidth").val() + "");
        settings.resizeImageHeight = parseInt($("#txtResizeHeight").val() + "");
        const restrictedColorLines = ($("#txtKMeansColorRestrictions").val() + "").split("\n");
        for (const line of restrictedColorLines) {
            const tline = line.trim();
            if (tline.indexOf("//") === 0) {
                // comment, skip
            }
            else {
                const rgbparts = tline.split(",");
                if (rgbparts.length === 3) {
                    let red = parseInt(rgbparts[0]);
                    let green = parseInt(rgbparts[1]);
                    let blue = parseInt(rgbparts[2]);
                    if (red < 0)
                        red = 0;
                    if (red > 255)
                        red = 255;
                    if (green < 0)
                        green = 0;
                    if (green > 255)
                        green = 255;
                    if (blue < 0)
                        blue = 0;
                    if (blue > 255)
                        blue = 255;
                    if (!isNaN(red) && !isNaN(green) && !isNaN(blue)) {
                        settings.kMeansColorRestrictions.push([red, green, blue]);
                    }
                }
            }
        }
        return settings;
    }
    exports.parseSettings = parseSettings;
    function process() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const settings = parseSettings();
                // cancel old process & create new
                cancellationToken.isCancelled = true;
                cancellationToken = new common_8.CancellationToken();
                processResult = yield guiprocessmanager_1.GUIProcessManager.process(settings, cancellationToken);
                yield updateOutput();
                const tabsOutput = M.Tabs.getInstance(document.getElementById("tabsOutput"));
                tabsOutput.select("output-pane");
            }
            catch (e) {
                log("Error: " + e.message + " at " + e.stack);
            }
        });
    }
    exports.process = process;
    function updateOutput() {
        return __awaiter(this, void 0, void 0, function* () {
            if (processResult != null) {
                const showLabels = $("#chkShowLabels").prop("checked");
                const fill = $("#chkFillFacets").prop("checked");
                const stroke = $("#chkShowBorders").prop("checked");
                const sizeMultiplier = parseInt($("#txtSizeMultiplier").val() + "");
                const fontSize = parseInt($("#txtLabelFontSize").val() + "");
                const fontColor = $("#txtLabelFontColor").val() + "";
                $("#statusSVGGenerate").css("width", "0%");
                $(".status.SVGGenerate").removeClass("complete");
                $(".status.SVGGenerate").addClass("active");
                const svg = yield guiprocessmanager_1.GUIProcessManager.createSVG(processResult.facetResult, processResult.colorsByIndex, sizeMultiplier, fill, stroke, showLabels, fontSize, fontColor, (progress) => {
                    if (cancellationToken.isCancelled) {
                        throw new Error("Cancelled");
                    }
                    $("#statusSVGGenerate").css("width", Math.round(progress * 100) + "%");
                });
                $("#svgContainer").empty().append(svg);
                $("#palette").empty().append(createPaletteHtml(processResult.colorsByIndex));
                $("#palette .color").tooltip();
                $(".status").removeClass("active");
                $(".status.SVGGenerate").addClass("complete");
            }
        });
    }
    exports.updateOutput = updateOutput;
    function createPaletteHtml(colorsByIndex) {
        let html = "";
        for (let c = 0; c < colorsByIndex.length; c++) {
            const style = "background-color: " + `rgb(${colorsByIndex[c][0]},${colorsByIndex[c][1]},${colorsByIndex[c][2]})`;
            html += `<div class="color" class="tooltipped" style="${style}" data-tooltip="${colorsByIndex[c][0]},${colorsByIndex[c][1]},${colorsByIndex[c][2]}">${c}</div>`;
        }
        return $(html);
    }
    function downloadPalettePng() {
        if (processResult == null) {
            return;
        }
        const colorsByIndex = processResult.colorsByIndex;
        const canvas = document.createElement("canvas");
        const nrOfItemsPerRow = 10;
        const nrRows = Math.ceil(colorsByIndex.length / nrOfItemsPerRow);
        const margin = 10;
        const cellWidth = 80;
        const cellHeight = 70;
        canvas.width = margin + nrOfItemsPerRow * (cellWidth + margin);
        canvas.height = margin + nrRows * (cellHeight + margin);
        const ctx = canvas.getContext("2d");
        ctx.translate(0.5, 0.5);
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < colorsByIndex.length; i++) {
            const color = colorsByIndex[i];
            const x = margin + (i % nrOfItemsPerRow) * (cellWidth + margin);
            const y = margin + Math.floor(i / nrOfItemsPerRow) * (cellHeight + margin);
            ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            ctx.fillRect(x, y, cellWidth, cellHeight - 20);
            ctx.strokeStyle = "#888";
            ctx.strokeRect(x, y, cellWidth, cellHeight - 20);
            const nrText = i + "";
            ctx.fillStyle = "black";
            ctx.strokeStyle = "#CCC";
            ctx.font = "20px Tahoma";
            const nrTextSize = ctx.measureText(nrText);
            ctx.lineWidth = 2;
            ctx.strokeText(nrText, x + cellWidth / 2 - nrTextSize.width / 2, y + cellHeight / 2 - 5);
            ctx.fillText(nrText, x + cellWidth / 2 - nrTextSize.width / 2, y + cellHeight / 2 - 5);
            ctx.lineWidth = 1;
            ctx.font = "10px Tahoma";
            const rgbText = "RGB: " + Math.floor(color[0]) + "," + Math.floor(color[1]) + "," + Math.floor(color[2]);
            const rgbTextSize = ctx.measureText(rgbText);
            ctx.fillStyle = "black";
            ctx.fillText(rgbText, x + cellWidth / 2 - rgbTextSize.width / 2, y + cellHeight - 10);
        }
        const dataURL = canvas.toDataURL("image/png");
        const dl = document.createElement("a");
        document.body.appendChild(dl);
        dl.setAttribute("href", dataURL);
        dl.setAttribute("download", "palette.png");
        dl.click();
    }
    exports.downloadPalettePng = downloadPalettePng;
    function downloadPNG() {
        if ($("#svgContainer svg").length > 0) {
            saveSvgAsPng($("#svgContainer svg").get(0), "paintbynumbers.png");
        }
    }
    exports.downloadPNG = downloadPNG;
    function downloadSVG() {
        if ($("#svgContainer svg").length > 0) {
            const svgEl = $("#svgContainer svg").get(0);
            svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            const svgData = svgEl.outerHTML;
            const preface = '<?xml version="1.0" standalone="no"?>\r\n';
            const svgBlob = new Blob([preface, svgData], { type: "image/svg+xml;charset=utf-8" });
            const svgUrl = URL.createObjectURL(svgBlob);
            const downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "paintbynumbers.svg";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            /*
            var svgAsXML = (new XMLSerializer).serializeToString(<any>$("#svgContainer svg").get(0));
            let dataURL = "data:image/svg+xml," + encodeURIComponent(svgAsXML);
            var dl = document.createElement("a");
            document.body.appendChild(dl);
            dl.setAttribute("href", dataURL);
            dl.setAttribute("download", "paintbynumbers.svg");
            dl.click();
            */
        }
    }
    exports.downloadSVG = downloadSVG;
    function loadExample(imgId) {
        // load image
        const img = document.getElementById(imgId);
        const c = document.getElementById("canvas");
        const ctx = c.getContext("2d");
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        ctx.drawImage(img, 0, 0);
    }
    exports.loadExample = loadExample;
});
define("lib/clipboard", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // From https://stackoverflow.com/a/35576409/694640
    /**
     * image pasting into canvas
     *
     * @param {string} canvas_id - canvas id
     * @param {boolean} autoresize - if canvas will be resized
     */
    class Clipboard {
        constructor(canvas_id, autoresize) {
            this.ctrl_pressed = false;
            this.command_pressed = false;
            this.paste_event_support = false;
            const _self = this;
            this.canvas = document.getElementById(canvas_id);
            this.ctx = this.canvas.getContext("2d");
            this.autoresize = autoresize;
            // handlers
            // document.addEventListener("keydown", function (e) {
            //     _self.on_keyboard_action(e);
            // }, false); // firefox fix
            // document.addEventListener("keyup", function (e) {
            //     _self.on_keyboardup_action(e);
            // }, false); // firefox fix
            document.addEventListener("paste", function (e) {
                _self.paste_auto(e);
            }, false); // official paste handler
            this.init();
        }
        // constructor - we ignore security checks here
        init() {
            this.pasteCatcher = document.createElement("div");
            this.pasteCatcher.setAttribute("id", "paste_ff");
            this.pasteCatcher.setAttribute("contenteditable", "");
            this.pasteCatcher.style.cssText = "opacity:0;position:fixed;top:0px;left:0px;width:10px;margin-left:-20px;";
            document.body.appendChild(this.pasteCatcher);
            const _self = this;
            // create an observer instance
            const observer = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (_self.paste_event_support === true || _self.ctrl_pressed === false || mutation.type !== "childList") {
                        // we already got data in paste_auto()
                        return true;
                    }
                    // if paste handle failed - capture pasted object manually
                    if (mutation.addedNodes.length === 1) {
                        if (mutation.addedNodes[0].src !== undefined) {
                            // image
                            _self.paste_createImage(mutation.addedNodes[0].src);
                        }
                        // register cleanup after some time.
                        setTimeout(function () {
                            _self.pasteCatcher.innerHTML = "";
                        }, 20);
                    }
                    return false;
                });
            });
            const target = document.getElementById("paste_ff");
            const config = { attributes: true, childList: true, characterData: true };
            observer.observe(target, config);
        }
        // default paste action
        paste_auto(e) {
            this.paste_event_support = false;
            if (this.pasteCatcher !== undefined) {
                this.pasteCatcher.innerHTML = "";
            }
            if (e.clipboardData) {
                const items = e.clipboardData.items;
                if (items) {
                    this.paste_event_support = true;
                    // access data directly
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf("image") !== -1) {
                            // image
                            const blob = items[i].getAsFile();
                            const URLObj = window.URL || window.webkitURL;
                            const source = URLObj.createObjectURL(blob);
                            this.paste_createImage(source);
                            e.preventDefault();
                            return false;
                        }
                    }
                }
                else {
                    // wait for DOMSubtreeModified event
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=891247
                }
            }
            return true;
        }
        // on keyboard press
        on_keyboard_action(event) {
            const k = event.keyCode;
            // ctrl
            if (k === 17 || event.metaKey || event.ctrlKey) {
                if (this.ctrl_pressed === false) {
                    this.ctrl_pressed = true;
                }
            }
            // v
            if (k === 86) {
                if (document.activeElement !== undefined && document.activeElement.type === "text") {
                    // let user paste into some input
                    return false;
                }
                if (this.ctrl_pressed === true && this.pasteCatcher !== undefined) {
                    this.pasteCatcher.focus();
                }
            }
            return true;
        }
        // on keyboard release
        on_keyboardup_action(event) {
            // ctrl
            if (event.ctrlKey === false && this.ctrl_pressed === true) {
                this.ctrl_pressed = false;
            }
            else if (event.metaKey === false && this.command_pressed === true) {
                this.command_pressed = false;
                this.ctrl_pressed = false;
            }
        }
        // draw pasted image to canvas
        paste_createImage(source) {
            const pastedImage = new Image();
            const self = this;
            pastedImage.onload = function () {
                if (self.autoresize === true) {
                    // resize
                    self.canvas.width = pastedImage.width;
                    self.canvas.height = pastedImage.height;
                }
                else {
                    // clear canvas
                    self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);
                }
                self.ctx.drawImage(pastedImage, 0, 0);
            };
            pastedImage.src = source;
        }
    }
    exports.Clipboard = Clipboard;
});
define("main", ["require", "exports", "gui", "lib/clipboard"], function (require, exports, gui_2, clipboard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    $(document).ready(function () {
        $(".tabs").tabs();
        $(".tooltipped").tooltip();
        const clip = new clipboard_1.Clipboard("canvas", true);
        $("#file").change(function (ev) {
            const files = $("#file").get(0).files;
            if (files !== null && files.length > 0) {
                const reader = new FileReader();
                reader.onloadend = function () {
                    const img = document.createElement("img");
                    img.onload = () => {
                        const c = document.getElementById("canvas");
                        const ctx = c.getContext("2d");
                        c.width = img.naturalWidth;
                        c.height = img.naturalHeight;
                        ctx.drawImage(img, 0, 0);
                    };
                    img.onerror = () => {
                        alert("Unable to load image");
                    };
                    img.src = reader.result;
                };
                reader.readAsDataURL(files[0]);
            }
        });
        gui_2.loadExample("imgSmall");
        $("#btnProcess").click(function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield gui_2.process();
                }
                catch (err) {
                    alert("Error: " + err);
                }
            });
        });
        $("#chkShowLabels, #chkFillFacets, #chkShowBorders, #txtSizeMultiplier, #txtLabelFontSize, #txtLabelFontColor").change(() => __awaiter(this, void 0, void 0, function* () {
            yield gui_2.updateOutput();
        }));
        $("#btnDownloadSVG").click(function () {
            gui_2.downloadSVG();
        });
        $("#btnDownloadPNG").click(function () {
            gui_2.downloadPNG();
        });
        $("#btnDownloadPalettePNG").click(function () {
            gui_2.downloadPalettePng();
        });
        $("#lnkTrivial").click(() => { gui_2.loadExample("imgTrivial"); return false; });
        $("#lnkSmall").click(() => { gui_2.loadExample("imgSmall"); return false; });
        $("#lnkMedium").click(() => { gui_2.loadExample("imgMedium"); return false; });
    });
});

--- END FILE: .\scripts\main.js ---


--- START FILE: .\scripts\lib\jquery-1.11.0.min.js ---
/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k="".trim,l={},m="1.11.0",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray||function(a){return"array"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return a-parseFloat(a)>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(l.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:k&&!k.call("\ufeff\xa0")?function(a){return null==a?"":k.call(a)}:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||n.guid++,e):void 0},now:function(){return+new Date},support:l}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s="sizzle"+-new Date,t=a.document,u=0,v=0,w=eb(),x=eb(),y=eb(),z=function(a,b){return a===b&&(j=!0),0},A="undefined",B=1<<31,C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=D.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",M=L.replace("w","w#"),N="\\["+K+"*("+L+")"+K+"*(?:([*^$|!~]?=)"+K+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+M+")|)|)"+K+"*\\]",O=":("+L+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+N.replace(3,8)+")*)|.*)\\)|)",P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(O),U=new RegExp("^"+M+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L.replace("w","w*")+")"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=/'|\\/g,ab=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),bb=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{G.apply(D=H.call(t.childNodes),t.childNodes),D[t.childNodes.length].nodeType}catch(cb){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function db(a,b,d,e){var f,g,h,i,j,m,p,q,u,v;if((b?b.ownerDocument||b:t)!==l&&k(b),b=b||l,d=d||[],!a||"string"!=typeof a)return d;if(1!==(i=b.nodeType)&&9!==i)return[];if(n&&!e){if(f=Z.exec(a))if(h=f[1]){if(9===i){if(g=b.getElementById(h),!g||!g.parentNode)return d;if(g.id===h)return d.push(g),d}else if(b.ownerDocument&&(g=b.ownerDocument.getElementById(h))&&r(b,g)&&g.id===h)return d.push(g),d}else{if(f[2])return G.apply(d,b.getElementsByTagName(a)),d;if((h=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(h)),d}if(c.qsa&&(!o||!o.test(a))){if(q=p=s,u=b,v=9===i&&a,1===i&&"object"!==b.nodeName.toLowerCase()){m=ob(a),(p=b.getAttribute("id"))?q=p.replace(_,"\\$&"):b.setAttribute("id",q),q="[id='"+q+"'] ",j=m.length;while(j--)m[j]=q+pb(m[j]);u=$.test(a)&&mb(b.parentNode)||b,v=m.join(",")}if(v)try{return G.apply(d,u.querySelectorAll(v)),d}catch(w){}finally{p||b.removeAttribute("id")}}}return xb(a.replace(P,"$1"),b,d,e)}function eb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function fb(a){return a[s]=!0,a}function gb(a){var b=l.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function hb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function ib(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||B)-(~a.sourceIndex||B);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function jb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function kb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function lb(a){return fb(function(b){return b=+b,fb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function mb(a){return a&&typeof a.getElementsByTagName!==A&&a}c=db.support={},f=db.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},k=db.setDocument=function(a){var b,e=a?a.ownerDocument||a:t,g=e.defaultView;return e!==l&&9===e.nodeType&&e.documentElement?(l=e,m=e.documentElement,n=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){k()},!1):g.attachEvent&&g.attachEvent("onunload",function(){k()})),c.attributes=gb(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=gb(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(e.getElementsByClassName)&&gb(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=gb(function(a){return m.appendChild(a).id=s,!e.getElementsByName||!e.getElementsByName(s).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==A&&n){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){var c=typeof a.getAttributeNode!==A&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==A?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==A&&n?b.getElementsByClassName(a):void 0},p=[],o=[],(c.qsa=Y.test(e.querySelectorAll))&&(gb(function(a){a.innerHTML="<select t=''><option selected=''></option></select>",a.querySelectorAll("[t^='']").length&&o.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||o.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll(":checked").length||o.push(":checked")}),gb(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&o.push("name"+K+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||o.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),o.push(",.*:")})),(c.matchesSelector=Y.test(q=m.webkitMatchesSelector||m.mozMatchesSelector||m.oMatchesSelector||m.msMatchesSelector))&&gb(function(a){c.disconnectedMatch=q.call(a,"div"),q.call(a,"[s!='']:x"),p.push("!=",O)}),o=o.length&&new RegExp(o.join("|")),p=p.length&&new RegExp(p.join("|")),b=Y.test(m.compareDocumentPosition),r=b||Y.test(m.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},z=b?function(a,b){if(a===b)return j=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===t&&r(t,a)?-1:b===e||b.ownerDocument===t&&r(t,b)?1:i?I.call(i,a)-I.call(i,b):0:4&d?-1:1)}:function(a,b){if(a===b)return j=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],k=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:i?I.call(i,a)-I.call(i,b):0;if(f===g)return ib(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)k.unshift(c);while(h[d]===k[d])d++;return d?ib(h[d],k[d]):h[d]===t?-1:k[d]===t?1:0},e):l},db.matches=function(a,b){return db(a,null,null,b)},db.matchesSelector=function(a,b){if((a.ownerDocument||a)!==l&&k(a),b=b.replace(S,"='$1']"),!(!c.matchesSelector||!n||p&&p.test(b)||o&&o.test(b)))try{var d=q.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return db(b,l,null,[a]).length>0},db.contains=function(a,b){return(a.ownerDocument||a)!==l&&k(a),r(a,b)},db.attr=function(a,b){(a.ownerDocument||a)!==l&&k(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!n):void 0;return void 0!==f?f:c.attributes||!n?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},db.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},db.uniqueSort=function(a){var b,d=[],e=0,f=0;if(j=!c.detectDuplicates,i=!c.sortStable&&a.slice(0),a.sort(z),j){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return i=null,a},e=db.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=db.selectors={cacheLength:50,createPseudo:fb,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ab,bb),a[3]=(a[4]||a[5]||"").replace(ab,bb),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||db.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&db.error(a[0]),a},PSEUDO:function(a){var b,c=!a[5]&&a[2];return V.CHILD.test(a[0])?null:(a[3]&&void 0!==a[4]?a[2]=a[4]:c&&T.test(c)&&(b=ob(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ab,bb).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=w[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&w(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==A&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=db.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),t=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&t){k=q[s]||(q[s]={}),j=k[a]||[],n=j[0]===u&&j[1],m=j[0]===u&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[u,n,m];break}}else if(t&&(j=(b[s]||(b[s]={}))[a])&&j[0]===u)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(t&&((l[s]||(l[s]={}))[a]=[u,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||db.error("unsupported pseudo: "+a);return e[s]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?fb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:fb(function(a){var b=[],c=[],d=g(a.replace(P,"$1"));return d[s]?fb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:fb(function(a){return function(b){return db(a,b).length>0}}),contains:fb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:fb(function(a){return U.test(a||"")||db.error("unsupported lang: "+a),a=a.replace(ab,bb).toLowerCase(),function(b){var c;do if(c=n?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===m},focus:function(a){return a===l.activeElement&&(!l.hasFocus||l.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:lb(function(){return[0]}),last:lb(function(a,b){return[b-1]}),eq:lb(function(a,b,c){return[0>c?c+b:c]}),even:lb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:lb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:lb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:lb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=jb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=kb(b);function nb(){}nb.prototype=d.filters=d.pseudos,d.setFilters=new nb;function ob(a,b){var c,e,f,g,h,i,j,k=x[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=Q.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?db.error(a):x(a,i).slice(0)}function pb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function qb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=v++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[u,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[s]||(b[s]={}),(h=i[d])&&h[0]===u&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function rb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function sb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function tb(a,b,c,d,e,f){return d&&!d[s]&&(d=tb(d)),e&&!e[s]&&(e=tb(e,f)),fb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||wb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:sb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=sb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=sb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ub(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],i=g||d.relative[" "],j=g?1:0,k=qb(function(a){return a===b},i,!0),l=qb(function(a){return I.call(b,a)>-1},i,!0),m=[function(a,c,d){return!g&&(d||c!==h)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>j;j++)if(c=d.relative[a[j].type])m=[qb(rb(m),c)];else{if(c=d.filter[a[j].type].apply(null,a[j].matches),c[s]){for(e=++j;f>e;e++)if(d.relative[a[e].type])break;return tb(j>1&&rb(m),j>1&&pb(a.slice(0,j-1).concat({value:" "===a[j-2].type?"*":""})).replace(P,"$1"),c,e>j&&ub(a.slice(j,e)),f>e&&ub(a=a.slice(e)),f>e&&pb(a))}m.push(c)}return rb(m)}function vb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,i,j,k){var m,n,o,p=0,q="0",r=f&&[],s=[],t=h,v=f||e&&d.find.TAG("*",k),w=u+=null==t?1:Math.random()||.1,x=v.length;for(k&&(h=g!==l&&g);q!==x&&null!=(m=v[q]);q++){if(e&&m){n=0;while(o=a[n++])if(o(m,g,i)){j.push(m);break}k&&(u=w)}c&&((m=!o&&m)&&p--,f&&r.push(m))}if(p+=q,c&&q!==p){n=0;while(o=b[n++])o(r,s,g,i);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=E.call(j));s=sb(s)}G.apply(j,s),k&&!f&&s.length>0&&p+b.length>1&&db.uniqueSort(j)}return k&&(u=w,h=t),r};return c?fb(f):f}g=db.compile=function(a,b){var c,d=[],e=[],f=y[a+" "];if(!f){b||(b=ob(a)),c=b.length;while(c--)f=ub(b[c]),f[s]?d.push(f):e.push(f);f=y(a,vb(e,d))}return f};function wb(a,b,c){for(var d=0,e=b.length;e>d;d++)db(a,b[d],c);return c}function xb(a,b,e,f){var h,i,j,k,l,m=ob(a);if(!f&&1===m.length){if(i=m[0]=m[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&c.getById&&9===b.nodeType&&n&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(ab,bb),b)||[])[0],!b)return e;a=a.slice(i.shift().value.length)}h=V.needsContext.test(a)?0:i.length;while(h--){if(j=i[h],d.relative[k=j.type])break;if((l=d.find[k])&&(f=l(j.matches[0].replace(ab,bb),$.test(i[0].type)&&mb(b.parentNode)||b))){if(i.splice(h,1),a=f.length&&pb(i),!a)return G.apply(e,f),e;break}}}return g(a,m)(f,b,!n,e,$.test(a)&&mb(b.parentNode)||b),e}return c.sortStable=s.split("").sort(z).join("")===s,c.detectDuplicates=!!j,k(),c.sortDetached=gb(function(a){return 1&a.compareDocumentPosition(l.createElement("div"))}),gb(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||hb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&gb(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||hb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),gb(function(a){return null==a.getAttribute("disabled")})||hb(J,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),db}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return n.inArray(a,b)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;e>b;b++)if(n.contains(d[b],this))return!0}));for(b=0;e>b;b++)n.find(a,d[b],c);return c=this.pushStack(e>1?n.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=a.document,A=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,B=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:A.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:z,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=z.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return y.find(a);this.length=1,this[0]=d}return this.context=z,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};B.prototype=n.fn,y=n(z);var C=/^(?:parents|prev(?:Until|All))/,D={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!n(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b,c=n(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(n.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?n.inArray(this[0],n(a)):n.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function E(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return E(a,"nextSibling")},prev:function(a){return E(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return n.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(D[a]||(e=n.unique(e)),C.test(a)&&(e=e.reverse())),this.pushStack(e)}});var F=/\S+/g,G={};function H(a){var b=G[a]={};return n.each(a.match(F)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?G[a]||H(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&n.each(arguments,function(a,c){var d;while((d=n.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){if(a===!0?!--n.readyWait:!n.isReady){if(!z.body)return setTimeout(n.ready);n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(z,[n]),n.fn.trigger&&n(z).trigger("ready").off("ready"))}}});function J(){z.addEventListener?(z.removeEventListener("DOMContentLoaded",K,!1),a.removeEventListener("load",K,!1)):(z.detachEvent("onreadystatechange",K),a.detachEvent("onload",K))}function K(){(z.addEventListener||"load"===event.type||"complete"===z.readyState)&&(J(),n.ready())}n.ready.promise=function(b){if(!I)if(I=n.Deferred(),"complete"===z.readyState)setTimeout(n.ready);else if(z.addEventListener)z.addEventListener("DOMContentLoaded",K,!1),a.addEventListener("load",K,!1);else{z.attachEvent("onreadystatechange",K),a.attachEvent("onload",K);var c=!1;try{c=null==a.frameElement&&z.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!n.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}J(),n.ready()}}()}return I.promise(b)};var L="undefined",M;for(M in n(l))break;l.ownLast="0"!==M,l.inlineBlockNeedsLayout=!1,n(function(){var a,b,c=z.getElementsByTagName("body")[0];c&&(a=z.createElement("div"),a.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",b=z.createElement("div"),c.appendChild(a).appendChild(b),typeof b.style.zoom!==L&&(b.style.cssText="border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1",(l.inlineBlockNeedsLayout=3===b.offsetWidth)&&(c.style.zoom=1)),c.removeChild(a),a=b=null)}),function(){var a=z.createElement("div");if(null==l.deleteExpando){l.deleteExpando=!0;try{delete a.test}catch(b){l.deleteExpando=!1}}a=null}(),n.acceptData=function(a){var b=n.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(O,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}n.data(a,b,c)}else c=void 0}return c}function Q(a){var b;for(b in a)if(("data"!==b||!n.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;return!0}function R(a,b,d,e){if(n.acceptData(a)){var f,g,h=n.expando,i=a.nodeType,j=i?n.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||n.guid++:h),j[k]||(j[k]=i?{}:{toJSON:n.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=n.extend(j[k],b):j[k].data=n.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[n.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[n.camelCase(b)])):f=g,f
}}function S(a,b,c){if(n.acceptData(a)){var d,e,f=a.nodeType,g=f?n.cache:a,h=f?a[n.expando]:n.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){n.isArray(b)?b=b.concat(n.map(b,n.camelCase)):b in d?b=[b]:(b=n.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!Q(d):!n.isEmptyObject(d))return}(c||(delete g[h].data,Q(g[h])))&&(f?n.cleanData([a],!0):l.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}n.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?n.cache[a[n.expando]]:a[n.expando],!!a&&!Q(a)},data:function(a,b,c){return R(a,b,c)},removeData:function(a,b){return S(a,b)},_data:function(a,b,c){return R(a,b,c,!0)},_removeData:function(a,b){return S(a,b,!0)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=n.data(f),1===f.nodeType&&!n._data(f,"parsedAttrs"))){c=g.length;while(c--)d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d]));n._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){n.data(this,a)}):arguments.length>1?this.each(function(){n.data(this,a,b)}):f?P(f,a,n.data(f,a)):void 0},removeData:function(a){return this.each(function(){n.removeData(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=n._data(a,b),c&&(!d||n.isArray(c)?d=n._data(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return n._data(a,c)||n._data(a,c,{empty:n.Callbacks("once memory").add(function(){n._removeData(a,b+"queue"),n._removeData(a,c)})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=n._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var T=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,U=["Top","Right","Bottom","Left"],V=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},W=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},X=/^(?:checkbox|radio)$/i;!function(){var a=z.createDocumentFragment(),b=z.createElement("div"),c=z.createElement("input");if(b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a>",l.leadingWhitespace=3===b.firstChild.nodeType,l.tbody=!b.getElementsByTagName("tbody").length,l.htmlSerialize=!!b.getElementsByTagName("link").length,l.html5Clone="<:nav></:nav>"!==z.createElement("nav").cloneNode(!0).outerHTML,c.type="checkbox",c.checked=!0,a.appendChild(c),l.appendChecked=c.checked,b.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,a.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",l.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,l.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){l.noCloneEvent=!1}),b.cloneNode(!0).click()),null==l.deleteExpando){l.deleteExpando=!0;try{delete b.test}catch(d){l.deleteExpando=!1}}a=b=c=null}(),function(){var b,c,d=z.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(l[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),l[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var Y=/^(?:input|select|textarea)$/i,Z=/^key/,$=/^(?:mouse|contextmenu)|click/,_=/^(?:focusinfocus|focusoutblur)$/,ab=/^([^.]*)(?:\.(.+)|)$/;function bb(){return!0}function cb(){return!1}function db(){try{return z.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=n.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof n===L||a&&n.event.triggered===a.type?void 0:n.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(F)||[""],h=b.length;while(h--)f=ab.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=n.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=n.event.special[o]||{},l=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},i),(m=g[o])||(m=g[o]=[],m.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,l):m.push(l),n.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n.hasData(a)&&n._data(a);if(r&&(k=r.events)){b=(b||"").match(F)||[""],j=b.length;while(j--)if(h=ab.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=m.length;while(f--)g=m[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(m.splice(f,1),g.selector&&m.delegateCount--,l.remove&&l.remove.call(a,g));i&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(k)&&(delete r.handle,n._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,m,o=[d||z],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||z,3!==d.nodeType&&8!==d.nodeType&&!_.test(p+n.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[n.expando]?b:new n.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),k=n.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!n.isWindow(d)){for(i=k.delegateType||p,_.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||z)&&o.push(l.defaultView||l.parentWindow||a)}m=0;while((h=o[m++])&&!b.isPropagationStopped())b.type=m>1?i:k.bindType||p,f=(n._data(h,"events")||{})[b.type]&&n._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&n.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&n.acceptData(d)&&g&&d[p]&&!n.isWindow(d)){l=d[g],l&&(d[g]=null),n.event.triggered=p;try{d[p]()}catch(r){}n.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(n._data(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((n.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?n(c,this).index(i)>=0:n.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=$.test(e)?this.mouseHooks:Z.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||z),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||z,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==db()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===db()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return n.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=z.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===L&&(a[d]=null),a.detachEvent(d,c))},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&(a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault())?bb:cb):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:cb,isPropagationStopped:cb,isImmediatePropagationStopped:cb,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=bb,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=bb,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=bb,this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.submitBubbles||(n.event.special.submit={setup:function(){return n.nodeName(this,"form")?!1:void n.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=n.nodeName(b,"input")||n.nodeName(b,"button")?b.form:void 0;c&&!n._data(c,"submitBubbles")&&(n.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),n._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&n.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return n.nodeName(this,"form")?!1:void n.event.remove(this,"._submit")}}),l.changeBubbles||(n.event.special.change={setup:function(){return Y.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(n.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),n.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),n.event.simulate("change",this,a,!0)})),!1):void n.event.add(this,"beforeactivate._change",function(a){var b=a.target;Y.test(b.nodeName)&&!n._data(b,"changeBubbles")&&(n.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||n.event.simulate("change",this.parentNode,a,!0)}),n._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return n.event.remove(this,"._change"),!Y.test(this.nodeName)}}),l.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=n._data(d,b);e||d.addEventListener(a,c,!0),n._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=n._data(d,b)-1;e?n._data(d,b,e):(d.removeEventListener(a,c,!0),n._removeData(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=cb;else if(!d)return this;return 1===e&&(g=d,d=function(a){return n().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=cb),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});function eb(a){var b=fb.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var fb="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gb=/ jQuery\d+="(?:null|\d+)"/g,hb=new RegExp("<(?:"+fb+")[\\s/>]","i"),ib=/^\s+/,jb=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,kb=/<([\w:]+)/,lb=/<tbody/i,mb=/<|&#?\w+;/,nb=/<(?:script|style|link)/i,ob=/checked\s*(?:[^=]|=\s*.checked.)/i,pb=/^$|\/(?:java|ecma)script/i,qb=/^true\/(.*)/,rb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,sb={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:l.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},tb=eb(z),ub=tb.appendChild(z.createElement("div"));sb.optgroup=sb.option,sb.tbody=sb.tfoot=sb.colgroup=sb.caption=sb.thead,sb.th=sb.td;function vb(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==L?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==L?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||n.nodeName(d,b)?f.push(d):n.merge(f,vb(d,b));return void 0===b||b&&n.nodeName(a,b)?n.merge([a],f):f}function wb(a){X.test(a.type)&&(a.defaultChecked=a.checked)}function xb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function yb(a){return a.type=(null!==n.find.attr(a,"type"))+"/"+a.type,a}function zb(a){var b=qb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ab(a,b){for(var c,d=0;null!=(c=a[d]);d++)n._data(c,"globalEval",!b||n._data(b[d],"globalEval"))}function Bb(a,b){if(1===b.nodeType&&n.hasData(a)){var c,d,e,f=n._data(a),g=n._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)n.event.add(b,c,h[c][d])}g.data&&(g.data=n.extend({},g.data))}}function Cb(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!l.noCloneEvent&&b[n.expando]){e=n._data(b);for(d in e.events)n.removeEvent(b,d,e.handle);b.removeAttribute(n.expando)}"script"===c&&b.text!==a.text?(yb(b).text=a.text,zb(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),l.html5Clone&&a.innerHTML&&!n.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&X.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}n.extend({clone:function(a,b,c){var d,e,f,g,h,i=n.contains(a.ownerDocument,a);if(l.html5Clone||n.isXMLDoc(a)||!hb.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ub.innerHTML=a.outerHTML,ub.removeChild(f=ub.firstChild)),!(l.noCloneEvent&&l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(d=vb(f),h=vb(a),g=0;null!=(e=h[g]);++g)d[g]&&Cb(e,d[g]);if(b)if(c)for(h=h||vb(a),d=d||vb(f),g=0;null!=(e=h[g]);g++)Bb(e,d[g]);else Bb(a,f);return d=vb(f,"script"),d.length>0&&Ab(d,!i&&vb(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k,m=a.length,o=eb(b),p=[],q=0;m>q;q++)if(f=a[q],f||0===f)if("object"===n.type(f))n.merge(p,f.nodeType?[f]:f);else if(mb.test(f)){h=h||o.appendChild(b.createElement("div")),i=(kb.exec(f)||["",""])[1].toLowerCase(),k=sb[i]||sb._default,h.innerHTML=k[1]+f.replace(jb,"<$1></$2>")+k[2],e=k[0];while(e--)h=h.lastChild;if(!l.leadingWhitespace&&ib.test(f)&&p.push(b.createTextNode(ib.exec(f)[0])),!l.tbody){f="table"!==i||lb.test(f)?"<table>"!==k[1]||lb.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)n.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}n.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),l.appendChecked||n.grep(vb(p,"input"),wb),q=0;while(f=p[q++])if((!d||-1===n.inArray(f,d))&&(g=n.contains(f.ownerDocument,f),h=vb(o.appendChild(f),"script"),g&&Ab(h),c)){e=0;while(f=h[e++])pb.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=n.expando,j=n.cache,k=l.deleteExpando,m=n.event.special;null!=(d=a[h]);h++)if((b||n.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)m[e]?n.event.remove(d,e):n.removeEvent(d,e,g.handle);j[f]&&(delete j[f],k?delete d[i]:typeof d.removeAttribute!==L?d.removeAttribute(i):d[i]=null,c.push(f))}}}),n.fn.extend({text:function(a){return W(this,function(a){return void 0===a?n.text(this):this.empty().append((this[0]&&this[0].ownerDocument||z).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=xb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=xb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(vb(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&Ab(vb(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&n.cleanData(vb(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&n.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return W(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(gb,""):void 0;if(!("string"!=typeof a||nb.test(a)||!l.htmlSerialize&&hb.test(a)||!l.leadingWhitespace&&ib.test(a)||sb[(kb.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(jb,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(vb(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(vb(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,k=this.length,m=this,o=k-1,p=a[0],q=n.isFunction(p);if(q||k>1&&"string"==typeof p&&!l.checkClone&&ob.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(k&&(i=n.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=n.map(vb(i,"script"),yb),f=g.length;k>j;j++)d=i,j!==o&&(d=n.clone(d,!0,!0),f&&n.merge(g,vb(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,n.map(g,zb),j=0;f>j;j++)d=g[j],pb.test(d.type||"")&&!n._data(d,"globalEval")&&n.contains(h,d)&&(d.src?n._evalUrl&&n._evalUrl(d.src):n.globalEval((d.text||d.textContent||d.innerHTML||"").replace(rb,"")));i=c=null}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=0,e=[],g=n(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),n(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Db,Eb={};function Fb(b,c){var d=n(c.createElement(b)).appendTo(c.body),e=a.getDefaultComputedStyle?a.getDefaultComputedStyle(d[0]).display:n.css(d[0],"display");return d.detach(),e}function Gb(a){var b=z,c=Eb[a];return c||(c=Fb(a,b),"none"!==c&&c||(Db=(Db||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Db[0].contentWindow||Db[0].contentDocument).document,b.write(),b.close(),c=Fb(a,b),Db.detach()),Eb[a]=c),c}!function(){var a,b,c=z.createElement("div"),d="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";c.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=c.getElementsByTagName("a")[0],a.style.cssText="float:left;opacity:.5",l.opacity=/^0.5/.test(a.style.opacity),l.cssFloat=!!a.style.cssFloat,c.style.backgroundClip="content-box",c.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===c.style.backgroundClip,a=c=null,l.shrinkWrapBlocks=function(){var a,c,e,f;if(null==b){if(a=z.getElementsByTagName("body")[0],!a)return;f="border:0;width:0;height:0;position:absolute;top:0;left:-9999px",c=z.createElement("div"),e=z.createElement("div"),a.appendChild(c).appendChild(e),b=!1,typeof e.style.zoom!==L&&(e.style.cssText=d+";width:1px;padding:1px;zoom:1",e.innerHTML="<div></div>",e.firstChild.style.width="5px",b=3!==e.offsetWidth),a.removeChild(c),a=c=e=null}return b}}();var Hb=/^margin/,Ib=new RegExp("^("+T+")(?!px)[a-z%]+$","i"),Jb,Kb,Lb=/^(top|right|bottom|left)$/;a.getComputedStyle?(Jb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)},Kb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Jb(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),Ib.test(g)&&Hb.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):z.documentElement.currentStyle&&(Jb=function(a){return a.currentStyle},Kb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Jb(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ib.test(g)&&!Lb.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function Mb(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h=z.createElement("div"),i="border:0;width:0;height:0;position:absolute;top:0;left:-9999px",j="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";h.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",b=h.getElementsByTagName("a")[0],b.style.cssText="float:left;opacity:.5",l.opacity=/^0.5/.test(b.style.opacity),l.cssFloat=!!b.style.cssFloat,h.style.backgroundClip="content-box",h.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===h.style.backgroundClip,b=h=null,n.extend(l,{reliableHiddenOffsets:function(){if(null!=c)return c;var a,b,d,e=z.createElement("div"),f=z.getElementsByTagName("body")[0];if(f)return e.setAttribute("className","t"),e.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=z.createElement("div"),a.style.cssText=i,f.appendChild(a).appendChild(e),e.innerHTML="<table><tr><td></td><td>t</td></tr></table>",b=e.getElementsByTagName("td"),b[0].style.cssText="padding:0;margin:0;border:0;display:none",d=0===b[0].offsetHeight,b[0].style.display="",b[1].style.display="none",c=d&&0===b[0].offsetHeight,f.removeChild(a),e=f=null,c},boxSizing:function(){return null==d&&k(),d},boxSizingReliable:function(){return null==e&&k(),e},pixelPosition:function(){return null==f&&k(),f},reliableMarginRight:function(){var b,c,d,e;if(null==g&&a.getComputedStyle){if(b=z.getElementsByTagName("body")[0],!b)return;c=z.createElement("div"),d=z.createElement("div"),c.style.cssText=i,b.appendChild(c).appendChild(d),e=d.appendChild(z.createElement("div")),e.style.cssText=d.style.cssText=j,e.style.marginRight=e.style.width="0",d.style.width="1px",g=!parseFloat((a.getComputedStyle(e,null)||{}).marginRight),b.removeChild(c)}return g}});function k(){var b,c,h=z.getElementsByTagName("body")[0];h&&(b=z.createElement("div"),c=z.createElement("div"),b.style.cssText=i,h.appendChild(b).appendChild(c),c.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%",n.swap(h,null!=h.style.zoom?{zoom:1}:{},function(){d=4===c.offsetWidth}),e=!0,f=!1,g=!0,a.getComputedStyle&&(f="1%"!==(a.getComputedStyle(c,null)||{}).top,e="4px"===(a.getComputedStyle(c,null)||{width:"4px"}).width),h.removeChild(b),c=h=null)}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Nb=/alpha\([^)]*\)/i,Ob=/opacity\s*=\s*([^)]*)/,Pb=/^(none|table(?!-c[ea]).+)/,Qb=new RegExp("^("+T+")(.*)$","i"),Rb=new RegExp("^([+-])=("+T+")","i"),Sb={position:"absolute",visibility:"hidden",display:"block"},Tb={letterSpacing:0,fontWeight:400},Ub=["Webkit","O","Moz","ms"];function Vb(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ub.length;while(e--)if(b=Ub[e]+c,b in a)return b;return d}function Wb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=n._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&V(d)&&(f[g]=n._data(d,"olddisplay",Gb(d.nodeName)))):f[g]||(e=V(d),(c&&"none"!==c||!e)&&n._data(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Xb(a,b,c){var d=Qb.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Yb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+U[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+U[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+U[f]+"Width",!0,e))):(g+=n.css(a,"padding"+U[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+U[f]+"Width",!0,e)));return g}function Zb(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Jb(a),g=l.boxSizing()&&"border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Kb(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ib.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Yb(a,b,c||(g?"border":"content"),d,f)+"px"}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Kb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":l.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;if(b=n.cssProps[h]||(n.cssProps[h]=Vb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Rb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]="",i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Vb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Kb(a,b,d)),"normal"===f&&b in Tb&&(f=Tb[b]),""===c||c?(e=parseFloat(f),c===!0||n.isNumeric(e)?e||0:f):f}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?0===a.offsetWidth&&Pb.test(n.css(a,"display"))?n.swap(a,Sb,function(){return Zb(a,b,d)}):Zb(a,b,d):void 0},set:function(a,c,d){var e=d&&Jb(a);return Xb(a,c,d?Yb(a,b,d,l.boxSizing()&&"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),l.opacity||(n.cssHooks.opacity={get:function(a,b){return Ob.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=n.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===n.trim(f.replace(Nb,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Nb.test(f)?f.replace(Nb,e):f+" "+e)}}),n.cssHooks.marginRight=Mb(l.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},Kb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+U[d]+b]=f[d]||f[d-2]||f[0];return e}},Hb.test(a)||(n.cssHooks[a+b].set=Xb)}),n.fn.extend({css:function(a,b){return W(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Jb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)
},a,b,arguments.length>1)},show:function(){return Wb(this,!0)},hide:function(){return Wb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){V(this)?n(this).show():n(this).hide()})}});function $b(a,b,c,d,e){return new $b.prototype.init(a,b,c,d,e)}n.Tween=$b,$b.prototype={constructor:$b,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=$b.propHooks[this.prop];return a&&a.get?a.get(this):$b.propHooks._default.get(this)},run:function(a){var b,c=$b.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):$b.propHooks._default.set(this),this}},$b.prototype.init.prototype=$b.prototype,$b.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},$b.propHooks.scrollTop=$b.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=$b.prototype.init,n.fx.step={};var _b,ac,bc=/^(?:toggle|show|hide)$/,cc=new RegExp("^(?:([+-])=|)("+T+")([a-z%]*)$","i"),dc=/queueHooks$/,ec=[jc],fc={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=cc.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&cc.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function gc(){return setTimeout(function(){_b=void 0}),_b=n.now()}function hc(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=U[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function ic(a,b,c){for(var d,e=(fc[b]||[]).concat(fc["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function jc(a,b,c){var d,e,f,g,h,i,j,k,m=this,o={},p=a.style,q=a.nodeType&&V(a),r=n._data(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,m.always(function(){m.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=n.css(a,"display"),k=Gb(a.nodeName),"none"===j&&(j=k),"inline"===j&&"none"===n.css(a,"float")&&(l.inlineBlockNeedsLayout&&"inline"!==k?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",l.shrinkWrapBlocks()||m.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],bc.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||n.style(a,d)}if(!n.isEmptyObject(o)){r?"hidden"in r&&(q=r.hidden):r=n._data(a,"fxshow",{}),f&&(r.hidden=!q),q?n(a).show():m.done(function(){n(a).hide()}),m.done(function(){var b;n._removeData(a,"fxshow");for(b in o)n.style(a,b,o[b])});for(d in o)g=ic(q?r[d]:0,d,m),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function kc(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function lc(a,b,c){var d,e,f=0,g=ec.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=_b||gc(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:_b||gc(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(kc(k,j.opts.specialEasing);g>f;f++)if(d=ec[f].call(j,a,k,j.opts))return d;return n.map(k,ic,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(lc,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],fc[c]=fc[c]||[],fc[c].unshift(b)},prefilter:function(a,b){b?ec.unshift(a):ec.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(V).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=lc(this,n.extend({},a),f);(e||n._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=n._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&dc.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=n._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(hc(b,!0),a,d,e)}}),n.each({slideDown:hc("show"),slideUp:hc("hide"),slideToggle:hc("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=n.timers,c=0;for(_b=n.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||n.fx.stop(),_b=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){ac||(ac=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(ac),ac=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e=z.createElement("div");e.setAttribute("className","t"),e.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=e.getElementsByTagName("a")[0],c=z.createElement("select"),d=c.appendChild(z.createElement("option")),b=e.getElementsByTagName("input")[0],a.style.cssText="top:1px",l.getSetAttribute="t"!==e.className,l.style=/top/.test(a.getAttribute("style")),l.hrefNormalized="/a"===a.getAttribute("href"),l.checkOn=!!b.value,l.optSelected=d.selected,l.enctype=!!z.createElement("form").enctype,c.disabled=!0,l.optDisabled=!d.disabled,b=z.createElement("input"),b.setAttribute("value",""),l.input=""===b.getAttribute("value"),b.value="t",b.setAttribute("type","radio"),l.radioValue="t"===b.value,a=b=c=d=e=null}();var mc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(mc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.text(a)}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(l.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)if(d=e[g],n.inArray(n.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var nc,oc,pc=n.expr.attrHandle,qc=/^(?:checked|selected)$/i,rc=l.getSetAttribute,sc=l.input;n.fn.extend({attr:function(a,b){return W(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===L?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?oc:nc)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(F);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)?sc&&rc||!qc.test(c)?a[d]=!1:a[n.camelCase("default-"+c)]=a[d]=!1:n.attr(a,c,""),a.removeAttribute(rc?c:d)},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),oc={set:function(a,b,c){return b===!1?n.removeAttr(a,c):sc&&rc||!qc.test(c)?a.setAttribute(!rc&&n.propFix[c]||c,c):a[n.camelCase("default-"+c)]=a[c]=!0,c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=pc[b]||n.find.attr;pc[b]=sc&&rc||!qc.test(b)?function(a,b,d){var e,f;return d||(f=pc[b],pc[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,pc[b]=f),e}:function(a,b,c){return c?void 0:a[n.camelCase("default-"+b)]?b.toLowerCase():null}}),sc&&rc||(n.attrHooks.value={set:function(a,b,c){return n.nodeName(a,"input")?void(a.defaultValue=b):nc&&nc.set(a,b,c)}}),rc||(nc={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},pc.id=pc.name=pc.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},n.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:nc.set},n.attrHooks.contenteditable={set:function(a,b,c){nc.set(a,""===b?!1:b,c)}},n.each(["width","height"],function(a,b){n.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),l.style||(n.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var tc=/^(?:input|select|textarea|button|object)$/i,uc=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return W(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return a=n.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):tc.test(a.nodeName)||uc.test(a.nodeName)&&a.href?0:-1}}}}),l.hrefNormalized||n.each(["href","src"],function(a,b){n.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this}),l.enctype||(n.propFix.enctype="encoding");var vc=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(F)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(vc," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(F)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(vc," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(F)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===L||"boolean"===c)&&(this.className&&n._data(this,"__className__",this.className),this.className=this.className||a===!1?"":n._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(vc," ").indexOf(b)>=0)return!0;return!1}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var wc=n.now(),xc=/\?/,yc=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;n.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=n.trim(b+"");return e&&!n.trim(e.replace(yc,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():n.error("Invalid JSON: "+b)},n.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var zc,Ac,Bc=/#.*$/,Cc=/([?&])_=[^&]*/,Dc=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Ec=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Fc=/^(?:GET|HEAD)$/,Gc=/^\/\//,Hc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Ic={},Jc={},Kc="*/".concat("*");try{Ac=location.href}catch(Lc){Ac=z.createElement("a"),Ac.href="",Ac=Ac.href}zc=Hc.exec(Ac.toLowerCase())||[];function Mc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(F)||[];if(n.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nc(a,b,c,d){var e={},f=a===Jc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Oc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&n.extend(!0,a,c),a}function Pc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Qc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ac,type:"GET",isLocal:Ec.test(zc[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Oc(Oc(a,n.ajaxSettings),b):Oc(n.ajaxSettings,a)},ajaxPrefilter:Mc(Ic),ajaxTransport:Mc(Jc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Dc.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||Ac)+"").replace(Bc,"").replace(Gc,zc[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(F)||[""],null==k.crossDomain&&(c=Hc.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===zc[1]&&c[2]===zc[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(zc[3]||("http:"===zc[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),Nc(Ic,k,b,v),2===t)return v;h=k.global,h&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Fc.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(xc.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Cc.test(e)?e.replace(Cc,"$1_="+wc++):e+(xc.test(e)?"&":"?")+"_="+wc++)),k.ifModified&&(n.lastModified[e]&&v.setRequestHeader("If-Modified-Since",n.lastModified[e]),n.etag[e]&&v.setRequestHeader("If-None-Match",n.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Kc+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Nc(Jc,k,b,v)){v.readyState=1,h&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Pc(k,v,c)),u=Qc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(n.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){if(n.isFunction(a))return this.each(function(b){n(this).wrapAll(a.call(this,b))});if(this[0]){var b=n(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!l.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||n.css(a,"display"))},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var Rc=/%20/g,Sc=/\[\]$/,Tc=/\r?\n/g,Uc=/^(?:submit|button|image|reset|file)$/i,Vc=/^(?:input|select|textarea|keygen)/i;function Wc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||Sc.test(a)?d(a,e):Wc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Wc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Wc(c,a[c],b,e);return d.join("&").replace(Rc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Vc.test(this.nodeName)&&!Uc.test(a)&&(this.checked||!X.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(Tc,"\r\n")}}):{name:b.name,value:c.replace(Tc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&$c()||_c()}:$c;var Xc=0,Yc={},Zc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on("unload",function(){for(var a in Yc)Yc[a](void 0,!0)}),l.cors=!!Zc&&"withCredentials"in Zc,Zc=l.ajax=!!Zc,Zc&&n.ajaxTransport(function(a){if(!a.crossDomain||l.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Xc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Yc[g],b=void 0,f.onreadystatechange=n.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Yc[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function $c(){try{return new a.XMLHttpRequest}catch(b){}}function _c(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=z.head||n("head")[0]||z.documentElement;return{send:function(d,e){b=z.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var ad=[],bd=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=ad.pop()||n.expando+"_"+wc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(bd.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&bd.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(bd,"$1"+e):b.jsonp!==!1&&(b.url+=(xc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,ad.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||z;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var cd=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&cd)return cd.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=a.slice(h,a.length),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&n.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var dd=a.document.documentElement;function ed(a){return n.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&n.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,n.contains(b,e)?(typeof e.getBoundingClientRect!==L&&(d=e.getBoundingClientRect()),c=ed(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===n.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(c=a.offset()),c.top+=n.css(a[0],"borderTopWidth",!0),c.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-n.css(d,"marginTop",!0),left:b.left-c.left-n.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||dd;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||dd})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);n.fn[a]=function(d){return W(this,function(a,d,e){var f=ed(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?n(f).scrollLeft():e,c?e:n(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=Mb(l.pixelPosition,function(a,c){return c?(c=Kb(a,b),Ib.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return W(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var fd=a.jQuery,gd=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=gd),b&&a.jQuery===n&&(a.jQuery=fd),n},typeof b===L&&(a.jQuery=a.$=n),n});

--- END FILE: .\scripts\lib\jquery-1.11.0.min.js ---


--- START FILE: .\scripts\lib\materialize.min.js ---
/*!
 * Materialize v1.0.0-beta (http://materializecss.com)
 * Copyright 2014-2017 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */
function _possibleConstructorReturn(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var _get=function t(e,i,n){null===e&&(e=Function.prototype);var s=Object.getOwnPropertyDescriptor(e,i);if(void 0===s){var o=Object.getPrototypeOf(e);return null===o?void 0:t(o,i,n)}if("value"in s)return s.value;var a=s.get;if(void 0!==a)return a.call(n)},_createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){window.cash=t()}(function(){function t(t,e){return e=e||O,H.test(t)?e.getElementsByClassName(t.slice(1)):W.test(t)?e.getElementsByTagName(t):e.querySelectorAll(t)}function e(t){if(!x){var e=(x=O.implementation.createHTMLDocument(null)).createElement("base");e.href=O.location.href,x.head.appendChild(e)}return x.body.innerHTML=t,x.body.childNodes}function i(t){"loading"!==O.readyState?t():O.addEventListener("DOMContentLoaded",t)}function n(n,s){if(!n)return this;if(n.cash&&n!==T)return n;var o,a=n,r=0;if(A(n))a=R.test(n)?O.getElementById(n.slice(1)):P.test(n)?e(n):t(n,s);else if(I(n))return i(n),this;if(!a)return this;if(a.nodeType||a===T)this[0]=a,this.length=1;else for(o=this.length=a.length;r<o;r++)this[r]=a[r];return this}function s(t,e){return new n(t,e)}function o(t,e){for(var i=t.length,n=0;n<i&&!1!==e.call(t[n],t[n],n,t);n++);}function a(t,e){var i=t&&(t.matches||t.webkitMatchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector);return!!i&&i.call(t,e)}function r(t){return A(t)?a:t.cash?function(e){return t.is(e)}:function(t,e){return t===e}}function l(t){return s($.call(t).filter(function(t,e,i){return i.indexOf(t)===e}))}function h(t){return t[F]=t[F]||{}}function d(t,e,i){return h(t)[e]=i}function u(t,e){var i=h(t);return void 0===i[e]&&(i[e]=t.dataset?t.dataset[e]:s(t).attr("data-"+e)),i[e]}function c(t,e){var i=h(t);i?delete i[e]:t.dataset?delete t.dataset[e]:s(t).removeAttr("data-"+name)}function p(t){return A(t)&&t.match(q)}function v(t,e){return t.classList?t.classList.contains(e):new RegExp("(^| )"+e+"( |$)","gi").test(t.className)}function f(t,e,i){t.classList?t.classList.add(e):i.indexOf(" "+e+" ")&&(t.className+=" "+e)}function m(t,e){t.classList?t.classList.remove(e):t.className=t.className.replace(e,"")}function g(t,e){return parseInt(T.getComputedStyle(t[0],null)[e],10)||0}function _(t,e,i){var n=u(t,"_cashEvents")||d(t,"_cashEvents",{});n[e]=n[e]||[],n[e].push(i),t.addEventListener(e,i)}function y(t,e,i){var n,s=u(t,"_cashEvents"),a=s&&s[e];a&&(i?(t.removeEventListener(e,i),(n=a.indexOf(i))>=0&&a.splice(n,1)):(o(a,function(i){t.removeEventListener(e,i)}),a=[]))}function k(t,e){return"&"+encodeURIComponent(t)+"="+encodeURIComponent(e).replace(/%20/g,"+")}function b(t){var e=[];return o(t.options,function(t){t.selected&&e.push(t.value)}),e.length?e:null}function w(t){var e=t.selectedIndex;return e>=0?t.options[e].value:null}function C(t){var e=t.type;if(!e)return null;switch(e.toLowerCase()){case"select-one":return w(t);case"select-multiple":return b(t);case"radio":case"checkbox":return t.checked?t.value:null;default:return t.value?t.value:null}}function E(t,e,i){if(i){var n=t.childNodes[0];t.insertBefore(e,n)}else t.appendChild(e)}function M(t,e,i){var n=A(e);n||!e.length?o(t,n?function(t){return t.insertAdjacentHTML(i?"afterbegin":"beforeend",e)}:function(t,n){return E(t,0===n?e:e.cloneNode(!0),i)}):o(e,function(e){return M(t,e,i)})}var x,O=document,T=window,L=Array.prototype,$=L.slice,B=L.filter,D=L.push,S=function(){},I=function(t){return typeof t==typeof S&&t.call},A=function(t){return"string"==typeof t},R=/^#[\w-]*$/,H=/^\.[\w-]*$/,P=/<.+>/,W=/^\w+$/,j=s.fn=s.prototype=n.prototype={cash:!0,length:0,push:D,splice:L.splice,map:L.map,init:n};Object.defineProperty(j,"constructor",{value:s}),s.parseHTML=e,s.noop=S,s.isFunction=I,s.isString=A,s.extend=j.extend=function(t){t=t||{};var e=$.call(arguments),i=e.length,n=1;for(1===e.length&&(t=this,n=0);n<i;n++)if(e[n])for(var s in e[n])e[n].hasOwnProperty(s)&&(t[s]=e[n][s]);return t},s.extend({merge:function(t,e){for(var i=+e.length,n=t.length,s=0;s<i;n++,s++)t[n]=e[s];return t.length=n,t},each:o,matches:a,unique:l,isArray:Array.isArray,isNumeric:function(t){return!isNaN(parseFloat(t))&&isFinite(t)}});var F=s.uid="_cash"+Date.now();j.extend({data:function(t,e){if(A(t))return void 0===e?u(this[0],t):this.each(function(i){return d(i,t,e)});for(var i in t)this.data(i,t[i]);return this},removeData:function(t){return this.each(function(e){return c(e,t)})}});var q=/\S+/g;j.extend({addClass:function(t){var e=p(t);return e?this.each(function(t){var i=" "+t.className+" ";o(e,function(e){f(t,e,i)})}):this},attr:function(t,e){if(t){if(A(t))return void 0===e?this[0]?this[0].getAttribute?this[0].getAttribute(t):this[0][t]:void 0:this.each(function(i){i.setAttribute?i.setAttribute(t,e):i[t]=e});for(var i in t)this.attr(i,t[i]);return this}},hasClass:function(t){var e=!1,i=p(t);return i&&i.length&&this.each(function(t){return!(e=v(t,i[0]))}),e},prop:function(t,e){if(A(t))return void 0===e?this[0][t]:this.each(function(i){i[t]=e});for(var i in t)this.prop(i,t[i]);return this},removeAttr:function(t){return this.each(function(e){e.removeAttribute?e.removeAttribute(t):delete e[t]})},removeClass:function(t){if(!arguments.length)return this.attr("class","");var e=p(t);return e?this.each(function(t){o(e,function(e){m(t,e)})}):this},removeProp:function(t){return this.each(function(e){delete e[t]})},toggleClass:function(t,e){if(void 0!==e)return this[e?"addClass":"removeClass"](t);var i=p(t);return i?this.each(function(t){var e=" "+t.className+" ";o(i,function(i){v(t,i)?m(t,i):f(t,i,e)})}):this}}),j.extend({add:function(t,e){return l(s.merge(this,s(t,e)))},each:function(t){return o(this,t),this},eq:function(t){return s(this.get(t))},filter:function(t){if(!t)return this;var e=I(t)?t:r(t);return s(B.call(this,function(i){return e(i,t)}))},first:function(){return this.eq(0)},get:function(t){return void 0===t?$.call(this):t<0?this[t+this.length]:this[t]},index:function(t){var e=t?s(t)[0]:this[0],i=t?this:s(e).parent().children();return $.call(i).indexOf(e)},last:function(){return this.eq(-1)}});var z=function(){var t=/(?:^\w|[A-Z]|\b\w)/g,e=/[\s-_]+/g;return function(i){return i.replace(t,function(t,e){return t[0===e?"toLowerCase":"toUpperCase"]()}).replace(e,"")}}(),N=function(){var t={},e=document.createElement("div").style;return function(i){if(i=z(i),t[i])return t[i];var n=i.charAt(0).toUpperCase()+i.slice(1);return o((i+" "+["webkit","moz","ms","o"].join(n+" ")+n).split(" "),function(n){if(n in e)return t[n]=i=t[i]=n,!1}),t[i]}}();s.prefixedProp=N,s.camelCase=z,j.extend({css:function(t,e){if(A(t))return t=N(t),arguments.length>1?this.each(function(i){return i.style[t]=e}):T.getComputedStyle(this[0])[t];for(var i in t)this.css(i,t[i]);return this}}),o(["Width","Height"],function(t){var e=t.toLowerCase();j[e]=function(){return this[0].getBoundingClientRect()[e]},j["inner"+t]=function(){return this[0]["client"+t]},j["outer"+t]=function(e){return this[0]["offset"+t]+(e?g(this,"margin"+("Width"===t?"Left":"Top"))+g(this,"margin"+("Width"===t?"Right":"Bottom")):0)}}),j.extend({off:function(t,e){return this.each(function(i){return y(i,t,e)})},on:function(t,e,n,s){var o;if(!A(t)){for(var r in t)this.on(r,e,t[r]);return this}return I(e)&&(n=e,e=null),"ready"===t?(i(n),this):(e&&(o=n,n=function(t){for(var i=t.target;!a(i,e);){if(i===this||null===i)return i=!1;i=i.parentNode}i&&o.call(i,t)}),this.each(function(e){var i=n;s&&(i=function(){n.apply(this,arguments),y(e,t,i)}),_(e,t,i)}))},one:function(t,e,i){return this.on(t,e,i,!0)},ready:i,trigger:function(t,e){if(document.createEvent){var i=document.createEvent("HTMLEvents");return i.initEvent(t,!0,!1),i=this.extend(i,e),this.each(function(t){return t.dispatchEvent(i)})}}}),j.extend({serialize:function(){var t="";return o(this[0].elements||this,function(e){if(!e.disabled&&"FIELDSET"!==e.tagName){var i=e.name;switch(e.type.toLowerCase()){case"file":case"reset":case"submit":case"button":break;case"select-multiple":var n=C(e);null!==n&&o(n,function(e){t+=k(i,e)});break;default:var s=C(e);null!==s&&(t+=k(i,s))}}}),t.substr(1)},val:function(t){return void 0===t?C(this[0]):this.each(function(e){return e.value=t})}}),j.extend({after:function(t){return s(t).insertAfter(this),this},append:function(t){return M(this,t),this},appendTo:function(t){return M(s(t),this),this},before:function(t){return s(t).insertBefore(this),this},clone:function(){return s(this.map(function(t){return t.cloneNode(!0)}))},empty:function(){return this.html(""),this},html:function(t){if(void 0===t)return this[0].innerHTML;var e=t.nodeType?t[0].outerHTML:t;return this.each(function(t){return t.innerHTML=e})},insertAfter:function(t){var e=this;return s(t).each(function(t,i){var n=t.parentNode,s=t.nextSibling;e.each(function(t){n.insertBefore(0===i?t:t.cloneNode(!0),s)})}),this},insertBefore:function(t){var e=this;return s(t).each(function(t,i){var n=t.parentNode;e.each(function(e){n.insertBefore(0===i?e:e.cloneNode(!0),t)})}),this},prepend:function(t){return M(this,t,!0),this},prependTo:function(t){return M(s(t),this,!0),this},remove:function(){return this.each(function(t){if(t.parentNode)return t.parentNode.removeChild(t)})},text:function(t){return void 0===t?this[0].textContent:this.each(function(e){return e.textContent=t})}});var V=O.documentElement;return j.extend({position:function(){var t=this[0];return{left:t.offsetLeft,top:t.offsetTop}},offset:function(){var t=this[0].getBoundingClientRect();return{top:t.top+T.pageYOffset-V.clientTop,left:t.left+T.pageXOffset-V.clientLeft}},offsetParent:function(){return s(this[0].offsetParent)}}),j.extend({children:function(t){var e=[];return this.each(function(t){D.apply(e,t.children)}),e=l(e),t?e.filter(function(e){return a(e,t)}):e},closest:function(t){return!t||this.length<1?s():this.is(t)?this.filter(t):this.parent().closest(t)},is:function(t){if(!t)return!1;var e=!1,i=r(t);return this.each(function(n){return!(e=i(n,t))}),e},find:function(e){if(!e||e.nodeType)return s(e&&this.has(e).length?e:null);var i=[];return this.each(function(n){D.apply(i,t(e,n))}),l(i)},has:function(e){var i=A(e)?function(i){return 0!==t(e,i).length}:function(t){return t.contains(e)};return this.filter(i)},next:function(){return s(this[0].nextElementSibling)},not:function(t){if(!t)return this;var e=r(t);return this.filter(function(i){return!e(i,t)})},parent:function(){var t=[];return this.each(function(e){e&&e.parentNode&&t.push(e.parentNode)}),l(t)},parents:function(t){var e,i=[];return this.each(function(n){for(e=n;e&&e.parentNode&&e!==O.body.parentNode;)e=e.parentNode,(!t||t&&a(e,t))&&i.push(e)}),l(i)},prev:function(){return s(this[0].previousElementSibling)},siblings:function(t){var e=this.parent().children(t),i=this[0];return e.filter(function(t){return t!==i})}}),s});var Component=function(){function t(e,i,n){_classCallCheck(this,t),i instanceof Element||console.error(Error(i+" is not an HTML Element"));var s=e.getInstance(i);s&&s.destroy(),this.el=i,this.$el=cash(i)}return _createClass(t,null,[{key:"init",value:function(t,e,i){var n=null;if(e instanceof Element)n=new t(e,i);else if(e&&(e.jquery||e.cash||e instanceof NodeList)){for(var s=[],o=0;o<e.length;o++)s.push(new t(e[o],i));n=s}return n}}]),t}();!function(t){t.Package?M={}:t.M={},M.jQueryLoaded=!!t.jQuery}(window),"function"==typeof define&&define.amd?define("M",[],function(){return M}):"undefined"==typeof exports||exports.nodeType||("undefined"!=typeof module&&!module.nodeType&&module.exports&&(exports=module.exports=M),exports.default=M),M.keys={TAB:9,ENTER:13,ESC:27,ARROW_UP:38,ARROW_DOWN:40},M.tabPressed=!1;var docHandleKeydown=function(t){t.which===M.keys.TAB&&(M.tabPressed=!0)},docHandleKeyup=function(t){t.which===M.keys.TAB&&(M.tabPressed=!1)};document.addEventListener("keydown",docHandleKeydown),document.addEventListener("keyup",docHandleKeyup),M.initializeJqueryWrapper=function(t,e,i){jQuery.fn[e]=function(n){if(t.prototype[n]){var s=Array.prototype.slice.call(arguments,1);if("get"===n.slice(0,3)){var o=this.first()[0][i];return o[n].apply(o,s)}return this.each(function(){var t=this[i];t[n].apply(t,s)})}if("object"==typeof n||!n)return t.init(this,arguments[0]),this;jQuery.error("Method "+n+" does not exist on jQuery."+e)}},M.AutoInit=function(t){var e=t||document.body,i={Autocomplete:e.querySelectorAll(".autocomplete:not(.no-autoinit)"),Carousel:e.querySelectorAll(".carousel:not(.no-autoinit)"),Chips:e.querySelectorAll(".chips:not(.no-autoinit)"),Collapsible:e.querySelectorAll(".collapsible:not(.no-autoinit)"),Datepicker:e.querySelectorAll(".datepicker:not(.no-autoinit)"),Dropdown:e.querySelectorAll(".dropdown-trigger:not(.no-autoinit)"),Materialbox:e.querySelectorAll(".materialboxed:not(.no-autoinit)"),Modal:e.querySelectorAll(".modal:not(.no-autoinit)"),Parallax:e.querySelectorAll(".parallax:not(.no-autoinit)"),Pushpin:e.querySelectorAll(".pushpin:not(.no-autoinit)"),ScrollSpy:e.querySelectorAll(".scrollspy:not(.no-autoinit)"),FormSelect:e.querySelectorAll("select:not(.no-autoinit)"),Sidenav:e.querySelectorAll(".sidenav:not(.no-autoinit)"),Tabs:e.querySelectorAll(".tabs:not(.no-autoinit)"),TapTarget:e.querySelectorAll(".tap-target:not(.no-autoinit)"),Timepicker:e.querySelectorAll(".timepicker:not(.no-autoinit)"),Tooltip:e.querySelectorAll(".tooltipped:not(.no-autoinit)"),FloatingActionButton:e.querySelectorAll(".fixed-action-btn:not(.no-autoinit)")};for(var n in i)M[n].init(i[n])},M.objectSelectorString=function(t){return((t.prop("tagName")||"")+(t.attr("id")||"")+(t.attr("class")||"")).replace(/\s/g,"")},M.guid=function(){function t(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return function(){return t()+t()+"-"+t()+"-"+t()+"-"+t()+"-"+t()+t()+t()}}(),M.escapeHash=function(t){return t.replace(/(:|\.|\[|\]|,|=|\/)/g,"\\$1")},M.elementOrParentIsFixed=function(t){var e=$(t),i=!1;return e.add(e.parents()).each(function(){if("fixed"===$(this).css("position"))return i=!0,!1}),i},M.checkWithinContainer=function(t,e,i){var n={top:!1,right:!1,bottom:!1,left:!1},s=t.getBoundingClientRect(),o=t.scrollLeft,a=t.scrollTop,r=e.left-o,l=e.top-a;return(r<s.left+i||r<i)&&(n.left=!0),(r+e.width>s.right-i||r+e.width>window.innerWidth-i)&&(n.right=!0),(l<s.top+i||l<i)&&(n.top=!0),(l+e.height>s.bottom-i||l+e.height>window.innerHeight-i)&&(n.bottom=!0),n},M.checkPossibleAlignments=function(t,e,i,n){var s={top:!0,right:!0,bottom:!0,left:!0,spaceOnTop:null,spaceOnRight:null,spaceOnBottom:null,spaceOnLeft:null},o="visible"===getComputedStyle(e).overflow,a=e.getBoundingClientRect(),r=Math.min(a.height,window.innerHeight),l=Math.min(a.width,window.innerWidth),h=t.getBoundingClientRect(),d=e.scrollLeft,u=e.scrollTop,c=i.left-d,p=i.top-u,v=i.top+h.height-u;return s.spaceOnRight=o?window.innerWidth-(h.left+i.width):l-(c+i.width),s.spaceOnRight<0&&(s.left=!1),s.spaceOnLeft=o?h.right-i.width:c-i.width+h.width,s.spaceOnLeft<0&&(s.right=!1),s.spaceOnBottom=o?window.innerHeight-(h.top+i.height+n):r-(p+i.height+n),s.spaceOnBottom<0&&(s.top=!1),s.spaceOnTop=o?h.bottom-(i.height+n):v-(i.height-n),s.spaceOnTop<0&&(s.bottom=!1),s},M.getOverflowParent=function(t){return null==t?null:t===document.body||"visible"!==getComputedStyle(t).overflow?t:M.getOverflowParent(t.parentElement)},M.getIdFromTrigger=function(t){var e=t.getAttribute("data-target");return e||(e=(e=t.getAttribute("href"))?e.slice(1):""),e},M.getDocumentScrollTop=function(){return window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0},M.getDocumentScrollLeft=function(){return window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0};var getTime=Date.now||function(){return(new Date).getTime()};M.throttle=function(t,e,i){var n=void 0,s=void 0,o=void 0,a=null,r=0;i||(i={});var l=function(){r=!1===i.leading?0:getTime(),a=null,o=t.apply(n,s),n=s=null};return function(){var h=getTime();r||!1!==i.leading||(r=h);var d=e-(h-r);return n=this,s=arguments,d<=0?(clearTimeout(a),a=null,r=h,o=t.apply(n,s),n=s=null):a||!1===i.trailing||(a=setTimeout(l,d)),o}};var $jscomp={scope:{}};$jscomp.defineProperty="function"==typeof Object.defineProperties?Object.defineProperty:function(t,e,i){if(i.get||i.set)throw new TypeError("ES3 does not support getters and setters.");t!=Array.prototype&&t!=Object.prototype&&(t[e]=i.value)},$jscomp.getGlobal=function(t){return"undefined"!=typeof window&&window===t?t:"undefined"!=typeof global&&null!=global?global:t},$jscomp.global=$jscomp.getGlobal(this),$jscomp.SYMBOL_PREFIX="jscomp_symbol_",$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){},$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)},$jscomp.symbolCounter_=0,$jscomp.Symbol=function(t){return $jscomp.SYMBOL_PREFIX+(t||"")+$jscomp.symbolCounter_++},$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var t=$jscomp.global.Symbol.iterator;t||(t=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator")),"function"!=typeof Array.prototype[t]&&$jscomp.defineProperty(Array.prototype,t,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}}),$jscomp.initSymbolIterator=function(){}},$jscomp.arrayIterator=function(t){var e=0;return $jscomp.iteratorPrototype(function(){return e<t.length?{done:!1,value:t[e++]}:{done:!0}})},$jscomp.iteratorPrototype=function(t){return $jscomp.initSymbolIterator(),t={next:t},t[$jscomp.global.Symbol.iterator]=function(){return this},t},$jscomp.array=$jscomp.array||{},$jscomp.iteratorFromArray=function(t,e){$jscomp.initSymbolIterator(),t instanceof String&&(t+="");var i=0,n={next:function(){if(i<t.length){var s=i++;return{value:e(s,t[s]),done:!1}}return n.next=function(){return{done:!0,value:void 0}},n.next()}};return n[Symbol.iterator]=function(){return n},n},$jscomp.polyfill=function(t,e,i,n){if(e){for(i=$jscomp.global,t=t.split("."),n=0;n<t.length-1;n++){var s=t[n];s in i||(i[s]={}),i=i[s]}(e=e(n=i[t=t[t.length-1]]))!=n&&null!=e&&$jscomp.defineProperty(i,t,{configurable:!0,writable:!0,value:e})}},$jscomp.polyfill("Array.prototype.keys",function(t){return t||function(){return $jscomp.iteratorFromArray(this,function(t){return t})}},"es6-impl","es3");var $jscomp$this=this;!function(t){M.anime=t()}(function(){function t(t){if(!H.col(t))try{return document.querySelectorAll(t)}catch(t){}}function e(t,e){for(var i=t.length,n=2<=arguments.length?arguments[1]:void 0,s=[],o=0;o<i;o++)if(o in t){var a=t[o];e.call(n,a,o,t)&&s.push(a)}return s}function i(t){return t.reduce(function(t,e){return t.concat(H.arr(e)?i(e):e)},[])}function n(e){return H.arr(e)?e:(H.str(e)&&(e=t(e)||e),e instanceof NodeList||e instanceof HTMLCollection?[].slice.call(e):[e])}function s(t,e){return t.some(function(t){return t===e})}function o(t){var e,i={};for(e in t)i[e]=t[e];return i}function a(t,e){var i,n=o(t);for(i in t)n[i]=e.hasOwnProperty(i)?e[i]:t[i];return n}function r(t,e){var i,n=o(t);for(i in e)n[i]=H.und(t[i])?e[i]:t[i];return n}function l(t){t=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,function(t,e,i,n){return e+e+i+i+n+n});var e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return"rgba("+(t=parseInt(e[1],16))+","+parseInt(e[2],16)+","+(e=parseInt(e[3],16))+",1)"}function h(t){function e(t,e,i){return 0>i&&(i+=1),1<i&&--i,i<1/6?t+6*(e-t)*i:.5>i?e:i<2/3?t+(e-t)*(2/3-i)*6:t}s=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t)||/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(t);t=parseInt(s[1])/360;var i=parseInt(s[2])/100,n=parseInt(s[3])/100,s=s[4]||1;if(0==i)n=i=t=n;else{var o=.5>n?n*(1+i):n+i-n*i,a=2*n-o,n=e(a,o,t+1/3),i=e(a,o,t);t=e(a,o,t-1/3)}return"rgba("+255*n+","+255*i+","+255*t+","+s+")"}function d(t){if(t=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(t))return t[2]}function u(t){return-1<t.indexOf("translate")||"perspective"===t?"px":-1<t.indexOf("rotate")||-1<t.indexOf("skew")?"deg":void 0}function c(t,e){return H.fnc(t)?t(e.target,e.id,e.total):t}function p(t,e){if(e in t.style)return getComputedStyle(t).getPropertyValue(e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase())||"0"}function v(t,e){return H.dom(t)&&s(R,e)?"transform":H.dom(t)&&(t.getAttribute(e)||H.svg(t)&&t[e])?"attribute":H.dom(t)&&"transform"!==e&&p(t,e)?"css":null!=t[e]?"object":void 0}function f(t,i){var n=u(i),n=-1<i.indexOf("scale")?1:0+n;if(!(t=t.style.transform))return n;for(var s=[],o=[],a=[],r=/(\w+)\((.+?)\)/g;s=r.exec(t);)o.push(s[1]),a.push(s[2]);return(t=e(a,function(t,e){return o[e]===i})).length?t[0]:n}function m(t,e){switch(v(t,e)){case"transform":return f(t,e);case"css":return p(t,e);case"attribute":return t.getAttribute(e)}return t[e]||0}function g(t,e){var i=/^(\*=|\+=|-=)/.exec(t);if(!i)return t;var n=d(t)||0;switch(e=parseFloat(e),t=parseFloat(t.replace(i[0],"")),i[0][0]){case"+":return e+t+n;case"-":return e-t+n;case"*":return e*t+n}}function _(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function y(t){t=t.points;for(var e,i=0,n=0;n<t.numberOfItems;n++){var s=t.getItem(n);0<n&&(i+=_(e,s)),e=s}return i}function k(t){if(t.getTotalLength)return t.getTotalLength();switch(t.tagName.toLowerCase()){case"circle":return 2*Math.PI*t.getAttribute("r");case"rect":return 2*t.getAttribute("width")+2*t.getAttribute("height");case"line":return _({x:t.getAttribute("x1"),y:t.getAttribute("y1")},{x:t.getAttribute("x2"),y:t.getAttribute("y2")});case"polyline":return y(t);case"polygon":var e=t.points;return y(t)+_(e.getItem(e.numberOfItems-1),e.getItem(0))}}function b(t,e){function i(i){return i=void 0===i?0:i,t.el.getPointAtLength(1<=e+i?e+i:0)}var n=i(),s=i(-1),o=i(1);switch(t.property){case"x":return n.x;case"y":return n.y;case"angle":return 180*Math.atan2(o.y-s.y,o.x-s.x)/Math.PI}}function w(t,e){var i,n=/-?\d*\.?\d+/g;if(i=H.pth(t)?t.totalLength:t,H.col(i))if(H.rgb(i)){var s=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(i);i=s?"rgba("+s[1]+",1)":i}else i=H.hex(i)?l(i):H.hsl(i)?h(i):void 0;else s=(s=d(i))?i.substr(0,i.length-s.length):i,i=e&&!/\s/g.test(i)?s+e:s;return i+="",{original:i,numbers:i.match(n)?i.match(n).map(Number):[0],strings:H.str(t)||e?i.split(n):[]}}function C(t){return t=t?i(H.arr(t)?t.map(n):n(t)):[],e(t,function(t,e,i){return i.indexOf(t)===e})}function E(t){var e=C(t);return e.map(function(t,i){return{target:t,id:i,total:e.length}})}function M(t,e){var i=o(e);if(H.arr(t)){var s=t.length;2!==s||H.obj(t[0])?H.fnc(e.duration)||(i.duration=e.duration/s):t={value:t}}return n(t).map(function(t,i){return i=i?0:e.delay,t=H.obj(t)&&!H.pth(t)?t:{value:t},H.und(t.delay)&&(t.delay=i),t}).map(function(t){return r(t,i)})}function x(t,e){var i,n={};for(i in t){var s=c(t[i],e);H.arr(s)&&1===(s=s.map(function(t){return c(t,e)})).length&&(s=s[0]),n[i]=s}return n.duration=parseFloat(n.duration),n.delay=parseFloat(n.delay),n}function O(t){return H.arr(t)?P.apply(this,t):W[t]}function T(t,e){var i;return t.tweens.map(function(n){var s=(n=x(n,e)).value,o=m(e.target,t.name),a=i?i.to.original:o,a=H.arr(s)?s[0]:a,r=g(H.arr(s)?s[1]:s,a),o=d(r)||d(a)||d(o);return n.from=w(a,o),n.to=w(r,o),n.start=i?i.end:t.offset,n.end=n.start+n.delay+n.duration,n.easing=O(n.easing),n.elasticity=(1e3-Math.min(Math.max(n.elasticity,1),999))/1e3,n.isPath=H.pth(s),n.isColor=H.col(n.from.original),n.isColor&&(n.round=1),i=n})}function L(t,n){return e(i(t.map(function(t){return n.map(function(e){var i=v(t.target,e.name);if(i){var n=T(e,t);e={type:i,property:e.name,animatable:t,tweens:n,duration:n[n.length-1].end,delay:n[0].delay}}else e=void 0;return e})})),function(t){return!H.und(t)})}function $(t,e,i,n){var s="delay"===t;return e.length?(s?Math.min:Math.max).apply(Math,e.map(function(e){return e[t]})):s?n.delay:i.offset+n.delay+n.duration}function B(t){var e,i=a(I,t),n=a(A,t),s=E(t.targets),o=[],l=r(i,n);for(e in t)l.hasOwnProperty(e)||"targets"===e||o.push({name:e,offset:l.offset,tweens:M(t[e],n)});return t=L(s,o),r(i,{children:[],animatables:s,animations:t,duration:$("duration",t,i,n),delay:$("delay",t,i,n)})}function D(t){function i(){return window.Promise&&new Promise(function(t){return u=t})}function n(t){return v.reversed?v.duration-t:t}function s(t){for(var i=0,n={},s=v.animations,o=s.length;i<o;){var a=s[i],r=a.animatable,l=(h=a.tweens)[c=h.length-1];c&&(l=e(h,function(e){return t<e.end})[0]||l);for(var h=Math.min(Math.max(t-l.start-l.delay,0),l.duration)/l.duration,d=isNaN(h)?1:l.easing(h,l.elasticity),h=l.to.strings,u=l.round,c=[],f=void 0,f=l.to.numbers.length,m=0;m<f;m++){var g=void 0,g=l.to.numbers[m],_=l.from.numbers[m],g=l.isPath?b(l.value,d*g):_+d*(g-_);u&&(l.isColor&&2<m||(g=Math.round(g*u)/u)),c.push(g)}if(l=h.length)for(f=h[0],d=0;d<l;d++)u=h[d+1],m=c[d],isNaN(m)||(f=u?f+(m+u):f+(m+" "));else f=c[0];j[a.type](r.target,a.property,f,n,r.id),a.currentValue=f,i++}if(i=Object.keys(n).length)for(s=0;s<i;s++)S||(S=p(document.body,"transform")?"transform":"-webkit-transform"),v.animatables[s].target.style[S]=n[s].join(" ");v.currentTime=t,v.progress=t/v.duration*100}function o(t){v[t]&&v[t](v)}function a(){v.remaining&&!0!==v.remaining&&v.remaining--}function r(t){var e=v.duration,r=v.offset,p=r+v.delay,f=v.currentTime,m=v.reversed,g=n(t);if(v.children.length){var _=v.children,y=_.length;if(g>=v.currentTime)for(var k=0;k<y;k++)_[k].seek(g);else for(;y--;)_[y].seek(g)}(g>=p||!e)&&(v.began||(v.began=!0,o("begin")),o("run")),g>r&&g<e?s(g):(g<=r&&0!==f&&(s(0),m&&a()),(g>=e&&f!==e||!e)&&(s(e),m||a())),o("update"),t>=e&&(v.remaining?(h=l,"alternate"===v.direction&&(v.reversed=!v.reversed)):(v.pause(),v.completed||(v.completed=!0,o("complete"),"Promise"in window&&(u(),c=i()))),d=0)}t=void 0===t?{}:t;var l,h,d=0,u=null,c=i(),v=B(t);return v.reset=function(){var t=v.direction,e=v.loop;for(v.currentTime=0,v.progress=0,v.paused=!0,v.began=!1,v.completed=!1,v.reversed="reverse"===t,v.remaining="alternate"===t&&1===e?2:e,s(0),t=v.children.length;t--;)v.children[t].reset()},v.tick=function(t){l=t,h||(h=l),r((d+l-h)*D.speed)},v.seek=function(t){r(n(t))},v.pause=function(){var t=F.indexOf(v);-1<t&&F.splice(t,1),v.paused=!0},v.play=function(){v.paused&&(v.paused=!1,h=0,d=n(v.currentTime),F.push(v),q||z())},v.reverse=function(){v.reversed=!v.reversed,h=0,d=n(v.currentTime)},v.restart=function(){v.pause(),v.reset(),v.play()},v.finished=c,v.reset(),v.autoplay&&v.play(),v}var S,I={update:void 0,begin:void 0,run:void 0,complete:void 0,loop:1,direction:"normal",autoplay:!0,offset:0},A={duration:1e3,delay:0,easing:"easeOutElastic",elasticity:500,round:0},R="translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(" "),H={arr:function(t){return Array.isArray(t)},obj:function(t){return-1<Object.prototype.toString.call(t).indexOf("Object")},pth:function(t){return H.obj(t)&&t.hasOwnProperty("totalLength")},svg:function(t){return t instanceof SVGElement},dom:function(t){return t.nodeType||H.svg(t)},str:function(t){return"string"==typeof t},fnc:function(t){return"function"==typeof t},und:function(t){return void 0===t},hex:function(t){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t)},rgb:function(t){return/^rgb/.test(t)},hsl:function(t){return/^hsl/.test(t)},col:function(t){return H.hex(t)||H.rgb(t)||H.hsl(t)}},P=function(){function t(t,e,i){return(((1-3*i+3*e)*t+(3*i-6*e))*t+3*e)*t}return function(e,i,n,s){if(0<=e&&1>=e&&0<=n&&1>=n){var o=new Float32Array(11);if(e!==i||n!==s)for(var a=0;11>a;++a)o[a]=t(.1*a,e,n);return function(a){if(e===i&&n===s)return a;if(0===a)return 0;if(1===a)return 1;for(var r=0,l=1;10!==l&&o[l]<=a;++l)r+=.1;var l=r+(a-o[--l])/(o[l+1]-o[l])*.1,h=3*(1-3*n+3*e)*l*l+2*(3*n-6*e)*l+3*e;if(.001<=h){for(r=0;4>r&&0!=(h=3*(1-3*n+3*e)*l*l+2*(3*n-6*e)*l+3*e);++r)var d=t(l,e,n)-a,l=l-d/h;a=l}else if(0===h)a=l;else{var l=r,r=r+.1,u=0;do{0<(h=t(d=l+(r-l)/2,e,n)-a)?r=d:l=d}while(1e-7<Math.abs(h)&&10>++u);a=d}return t(a,i,s)}}}}(),W=function(){function t(t,e){return 0===t||1===t?t:-Math.pow(2,10*(t-1))*Math.sin(2*(t-1-e/(2*Math.PI)*Math.asin(1))*Math.PI/e)}var e,i="Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "),n={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],t],Out:[[.25,.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(e,i){return 1-t(1-e,i)}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(e,i){return.5>e?t(2*e,i)/2:1-t(-2*e+2,i)/2}]},s={linear:P(.25,.25,.75,.75)},o={};for(e in n)o.type=e,n[o.type].forEach(function(t){return function(e,n){s["ease"+t.type+i[n]]=H.fnc(e)?e:P.apply($jscomp$this,e)}}(o)),o={type:o.type};return s}(),j={css:function(t,e,i){return t.style[e]=i},attribute:function(t,e,i){return t.setAttribute(e,i)},object:function(t,e,i){return t[e]=i},transform:function(t,e,i,n,s){n[s]||(n[s]=[]),n[s].push(e+"("+i+")")}},F=[],q=0,z=function(){function t(){q=requestAnimationFrame(e)}function e(e){var i=F.length;if(i){for(var n=0;n<i;)F[n]&&F[n].tick(e),n++;t()}else cancelAnimationFrame(q),q=0}return t}();return D.version="2.2.0",D.speed=1,D.running=F,D.remove=function(t){t=C(t);for(var e=F.length;e--;)for(var i=F[e],n=i.animations,o=n.length;o--;)s(t,n[o].animatable.target)&&(n.splice(o,1),n.length||i.pause())},D.getValue=m,D.path=function(e,i){var n=H.str(e)?t(e)[0]:e,s=i||100;return function(t){return{el:n,property:t,totalLength:k(n)*(s/100)}}},D.setDashoffset=function(t){var e=k(t);return t.setAttribute("stroke-dasharray",e),e},D.bezier=P,D.easings=W,D.timeline=function(t){var e=D(t);return e.pause(),e.duration=0,e.add=function(i){return e.children.forEach(function(t){t.began=!0,t.completed=!0}),n(i).forEach(function(i){var n=r(i,a(A,t||{}));n.targets=n.targets||t.targets,i=e.duration;var s=n.offset;n.autoplay=!1,n.direction=e.direction,n.offset=H.und(s)?i:g(s,i),e.began=!0,e.completed=!0,e.seek(n.offset),(n=D(n)).began=!0,n.completed=!0,n.duration>i&&(e.duration=n.duration),e.children.push(n)}),e.seek(0),e.reset(),e.autoplay&&e.restart(),e},e},D.random=function(t,e){return Math.floor(Math.random()*(e-t+1))+t},D}),function(t,e){"use strict";var i={accordion:!0,onOpenStart:void 0,onOpenEnd:void 0,onCloseStart:void 0,onCloseEnd:void 0,inDuration:300,outDuration:300},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));n.el.M_Collapsible=n,n.options=t.extend({},s.defaults,i),n.$headers=n.$el.children("li").children(".collapsible-header"),n.$headers.attr("tabindex",0),n._setupEventHandlers();var o=n.$el.children("li.active").children(".collapsible-body");return n.options.accordion?o.first().css("display","block"):o.css("display","block"),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._removeEventHandlers(),this.el.M_Collapsible=void 0}},{key:"_setupEventHandlers",value:function(){var t=this;this._handleCollapsibleClickBound=this._handleCollapsibleClick.bind(this),this._handleCollapsibleKeydownBound=this._handleCollapsibleKeydown.bind(this),this.el.addEventListener("click",this._handleCollapsibleClickBound),this.$headers.each(function(e){e.addEventListener("keydown",t._handleCollapsibleKeydownBound)})}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("click",this._handleCollapsibleClickBound)}},{key:"_handleCollapsibleClick",value:function(e){var i=t(e.target).closest(".collapsible-header");if(e.target&&i.length){var n=i.closest(".collapsible");if(n[0]===this.el){var s=i.closest("li"),o=n.children("li"),a=s[0].classList.contains("active"),r=o.index(s);a?this.close(r):this.open(r)}}}},{key:"_handleCollapsibleKeydown",value:function(t){13===t.keyCode&&this._handleCollapsibleClickBound(t)}},{key:"_animateIn",value:function(t){var i=this,n=this.$el.children("li").eq(t);if(n.length){var s=n.children(".collapsible-body");e.remove(s[0]),s.css({display:"block",overflow:"hidden",height:0,paddingTop:"",paddingBottom:""});var o=s.css("padding-top"),a=s.css("padding-bottom"),r=s[0].scrollHeight;s.css({paddingTop:0,paddingBottom:0}),e({targets:s[0],height:r,paddingTop:o,paddingBottom:a,duration:this.options.inDuration,easing:"easeInOutCubic",complete:function(t){s.css({overflow:"",paddingTop:"",paddingBottom:"",height:""}),"function"==typeof i.options.onOpenEnd&&i.options.onOpenEnd.call(i,n[0])}})}}},{key:"_animateOut",value:function(t){var i=this,n=this.$el.children("li").eq(t);if(n.length){var s=n.children(".collapsible-body");e.remove(s[0]),s.css("overflow","hidden"),e({targets:s[0],height:0,paddingTop:0,paddingBottom:0,duration:this.options.outDuration,easing:"easeInOutCubic",complete:function(){s.css({height:"",overflow:"",padding:"",display:""}),"function"==typeof i.options.onCloseEnd&&i.options.onCloseEnd.call(i,n[0])}})}}},{key:"open",value:function(e){var i=this,n=this.$el.children("li").eq(e);if(n.length&&!n[0].classList.contains("active")){if("function"==typeof this.options.onOpenStart&&this.options.onOpenStart.call(this,n[0]),this.options.accordion){var s=this.$el.children("li");this.$el.children("li.active").each(function(e){var n=s.index(t(e));i.close(n)})}n[0].classList.add("active"),this._animateIn(e)}}},{key:"close",value:function(t){var e=this.$el.children("li").eq(t);e.length&&e[0].classList.contains("active")&&("function"==typeof this.options.onCloseStart&&this.options.onCloseStart.call(this,e[0]),e[0].classList.remove("active"),this._animateOut(t))}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Collapsible}},{key:"defaults",get:function(){return i}}]),s}();M.Collapsible=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"collapsible","M_Collapsible")}(cash,M.anime),function(t,e){"use strict";var i={alignment:"left",autoFocus:!0,constrainWidth:!0,container:null,coverTrigger:!0,closeOnClick:!0,hover:!1,inDuration:150,outDuration:250,onOpenStart:null,onOpenEnd:null,onCloseStart:null,onCloseEnd:null},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Dropdown=n,s._dropdowns.push(n),n.id=M.getIdFromTrigger(e),n.dropdownEl=document.getElementById(n.id),n.$dropdownEl=t(n.dropdownEl),n.options=t.extend({},s.defaults,i),n.isOpen=!1,n.isScrollable=!1,n.isTouchMoving=!1,n.focusedIndex=-1,n.filterQuery=[],n.options.container?t(n.options.container).append(n.dropdownEl):n.$el.after(n.dropdownEl),n._makeDropdownFocusable(),n._resetFilterQueryBound=n._resetFilterQuery.bind(n),n._handleDocumentClickBound=n._handleDocumentClick.bind(n),n._handleDocumentTouchmoveBound=n._handleDocumentTouchmove.bind(n),n._handleDropdownKeydownBound=n._handleDropdownKeydown.bind(n),n._handleTriggerKeydownBound=n._handleTriggerKeydown.bind(n),n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._resetDropdownStyles(),this._removeEventHandlers(),s._dropdowns.splice(s._dropdowns.indexOf(this),1),this.el.M_Dropdown=void 0}},{key:"_setupEventHandlers",value:function(){this.el.addEventListener("keydown",this._handleTriggerKeydownBound),this.options.hover?(this._handleMouseEnterBound=this._handleMouseEnter.bind(this),this.el.addEventListener("mouseenter",this._handleMouseEnterBound),this._handleMouseLeaveBound=this._handleMouseLeave.bind(this),this.el.addEventListener("mouseleave",this._handleMouseLeaveBound),this.dropdownEl.addEventListener("mouseleave",this._handleMouseLeaveBound)):(this._handleClickBound=this._handleClick.bind(this),this.el.addEventListener("click",this._handleClickBound))}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("keydown",this._handleTriggerKeydownBound),this.options.hover?(this.el.removeEventHandlers("mouseenter",this._handleMouseEnterBound),this.el.removeEventHandlers("mouseleave",this._handleMouseLeaveBound),this.dropdownEl.removeEventHandlers("mouseleave",this._handleMouseLeaveBound)):this.el.removeEventListener("click",this._handleClickBound)}},{key:"_setupTemporaryEventHandlers",value:function(){document.body.addEventListener("click",this._handleDocumentClickBound,!0),document.body.addEventListener("touchend",this._handleDocumentClickBound),document.body.addEventListener("touchmove",this._handleDocumentTouchmoveBound),this.dropdownEl.addEventListener("keydown",this._handleDropdownKeydownBound)}},{key:"_removeTemporaryEventHandlers",value:function(){document.body.removeEventListener("click",this._handleDocumentClickBound,!0),document.body.removeEventListener("touchend",this._handleDocumentClickBound),document.body.removeEventListener("touchmove",this._handleDocumentTouchmoveBound),this.dropdownEl.removeEventListener("keydown",this._handleDropdownKeydownBound)}},{key:"_handleClick",value:function(t){t.preventDefault(),this.open()}},{key:"_handleMouseEnter",value:function(){this.open()}},{key:"_handleMouseLeave",value:function(e){var i=e.toElement||e.relatedTarget,n=!!t(i).closest(".dropdown-content").length,s=!1,o=t(i).closest(".dropdown-trigger");o.length&&o[0].M_Dropdown&&o[0].M_Dropdown.isOpen&&(s=!0),s||n||this.close()}},{key:"_handleDocumentClick",value:function(e){var i=this,n=t(e.target);this.options.closeOnClick&&n.closest(".dropdown-content").length&&!this.isTouchMoving?setTimeout(function(){i.close()},0):!n.closest(".dropdown-trigger").length&&n.closest(".dropdown-content").length||setTimeout(function(){i.close()},0),this.isTouchMoving=!1}},{key:"_handleTriggerKeydown",value:function(t){t.which!==M.keys.ARROW_DOWN&&t.which!==M.keys.ENTER||this.isOpen||(t.preventDefault(),this.open())}},{key:"_handleDocumentTouchmove",value:function(e){t(e.target).closest(".dropdown-content").length&&(this.isTouchMoving=!0)}},{key:"_handleDropdownKeydown",value:function(e){if(e.which===M.keys.TAB)e.preventDefault(),this.close();else if(e.which!==M.keys.ARROW_DOWN&&e.which!==M.keys.ARROW_UP||!this.isOpen)if(e.which===M.keys.ENTER&&this.isOpen){var i=this.dropdownEl.children[this.focusedIndex],n=t(i).find("a, button").first();n.length?n[0].click():i.click()}else e.which===M.keys.ESC&&this.isOpen&&(e.preventDefault(),this.close());else{e.preventDefault();var s=e.which===M.keys.ARROW_DOWN?1:-1,o=this.focusedIndex,a=!1;do{if(o+=s,this.dropdownEl.children[o]&&-1!==this.dropdownEl.children[o].tabIndex){a=!0;break}}while(o<this.dropdownEl.children.length&&o>=0);a&&(this.focusedIndex=o,this._focusFocusedItem())}var r=String.fromCharCode(e.which).toLowerCase(),l=[9,13,27,38,40];if(r&&-1===l.indexOf(e.which)){this.filterQuery.push(r);var h=this.filterQuery.join(""),d=t(this.dropdownEl).find("li").filter(function(e){return 0===t(e).text().toLowerCase().indexOf(h)})[0];d&&(this.focusedIndex=t(d).index(),this._focusFocusedItem())}this.filterTimeout=setTimeout(this._resetFilterQueryBound,1e3)}},{key:"_resetFilterQuery",value:function(){this.filterQuery=[]}},{key:"_resetDropdownStyles",value:function(){this.$dropdownEl.css({display:"",width:"",height:"",left:"",top:"","transform-origin":"",transform:"",opacity:""})}},{key:"_makeDropdownFocusable",value:function(){this.dropdownEl.tabIndex=0,t(this.dropdownEl).children().each(function(t){t.getAttribute("tabindex")||t.setAttribute("tabindex",0)})}},{key:"_focusFocusedItem",value:function(){this.focusedIndex>=0&&this.focusedIndex<this.dropdownEl.children.length&&this.options.autoFocus&&this.dropdownEl.children[this.focusedIndex].focus()}},{key:"_getDropdownPosition",value:function(){this.el.offsetParent.getBoundingClientRect();var t=this.el.getBoundingClientRect(),e=this.dropdownEl.getBoundingClientRect(),i=e.height,n=e.width,s=t.left-e.left,o=t.top-e.top,a={left:s,top:o,height:i,width:n},r=this.dropdownEl.offsetParent,l=M.checkPossibleAlignments(this.el,r,a,this.options.coverTrigger?0:t.height),h="top",d=this.options.alignment;if(o+=this.options.coverTrigger?0:t.height,this.isScrollable=!1,l.top||(l.bottom?h="bottom":(this.isScrollable=!0,l.spaceOnTop>l.spaceOnBottom?(h="bottom",i+=l.spaceOnTop,o-=l.spaceOnTop):i+=l.spaceOnBottom)),!l[d]){var u="left"===d?"right":"left";l[u]?d=u:l.spaceOnLeft>l.spaceOnRight?(d="right",n+=l.spaceOnLeft,s-=l.spaceOnLeft):(d="left",n+=l.spaceOnRight)}return"bottom"===h&&(o=o-e.height+(this.options.coverTrigger?t.height:0)),"right"===d&&(s=s-e.width+t.width),{x:s,y:o,verticalAlignment:h,horizontalAlignment:d,height:i,width:n}}},{key:"_animateIn",value:function(){var t=this;e.remove(this.dropdownEl),e({targets:this.dropdownEl,opacity:{value:[0,1],easing:"easeOutQuad"},scaleX:[.3,1],scaleY:[.3,1],duration:this.options.inDuration,easing:"easeOutQuint",complete:function(e){if(t.options.autoFocus&&t.dropdownEl.focus(),"function"==typeof t.options.onOpenEnd){var i=e.animatables[0].target;t.options.onOpenEnd.call(i,t.el)}}})}},{key:"_animateOut",value:function(){var t=this;e.remove(this.dropdownEl),e({targets:this.dropdownEl,opacity:{value:0,easing:"easeOutQuint"},scaleX:.3,scaleY:.3,duration:this.options.outDuration,easing:"easeOutQuint",complete:function(e){if(t._resetDropdownStyles(),"function"==typeof t.options.onCloseEnd){e.animatables[0].target;t.options.onCloseEnd.call(t,t.el)}}})}},{key:"_placeDropdown",value:function(){var t=this.options.constrainWidth?this.el.getBoundingClientRect().width:this.dropdownEl.getBoundingClientRect().width;this.dropdownEl.style.width=t+"px";var e=this._getDropdownPosition();this.dropdownEl.style.left=e.x+"px",this.dropdownEl.style.top=e.y+"px",this.dropdownEl.style.height=e.height+"px",this.dropdownEl.style.width=e.width+"px",this.dropdownEl.style.transformOrigin=("left"===e.horizontalAlignment?"0":"100%")+" "+("top"===e.verticalAlignment?"0":"100%")}},{key:"open",value:function(){this.isOpen||(this.isOpen=!0,"function"==typeof this.options.onOpenStart&&this.options.onOpenStart.call(this,this.el),this._resetDropdownStyles(),this.dropdownEl.style.display="block",this._placeDropdown(),this._animateIn(),this._setupTemporaryEventHandlers())}},{key:"close",value:function(){this.isOpen&&(this.isOpen=!1,this.focusedIndex=-1,"function"==typeof this.options.onCloseStart&&this.options.onCloseStart.call(this,this.el),this._animateOut(),this._removeTemporaryEventHandlers(),this.options.autoFocus&&this.el.focus())}},{key:"recalculateDimensions",value:function(){this.isOpen&&(this.$dropdownEl.css({width:"",height:"",left:"",top:"","transform-origin":""}),this._placeDropdown())}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Dropdown}},{key:"defaults",get:function(){return i}}]),s}();n._dropdowns=[],window.M.Dropdown=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"dropdown","M_Dropdown")}(cash,M.anime),function(t,e){"use strict";var i={opacity:.5,inDuration:250,outDuration:250,onOpenStart:null,onOpenEnd:null,onCloseStart:null,onCloseEnd:null,preventScrolling:!0,dismissible:!0,startingTop:"4%",endingTop:"10%"},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Modal=n,n.options=t.extend({},s.defaults,i),n.isOpen=!1,n.id=n.$el.attr("id"),n._openingTrigger=void 0,n.$overlay=t('<div class="modal-overlay"></div>'),n.el.tabIndex=0,s._count++,n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){s._count--,this._removeEventHandlers(),this.el.removeAttribute("style"),this.$overlay.remove(),this.el.M_Modal=void 0}},{key:"_setupEventHandlers",value:function(){this._handleOverlayClickBound=this._handleOverlayClick.bind(this),this._handleModalCloseClickBound=this._handleModalCloseClick.bind(this),1===s._count&&document.body.addEventListener("click",this._handleTriggerClick),this.$overlay[0].addEventListener("click",this._handleOverlayClickBound),this.el.addEventListener("click",this._handleModalCloseClickBound)}},{key:"_removeEventHandlers",value:function(){0===s._count&&document.body.removeEventListener("click",this._handleTriggerClick),this.$overlay[0].removeEventListener("click",this._handleOverlayClickBound),this.el.removeEventListener("click",this._handleModalCloseClickBound)}},{key:"_handleTriggerClick",value:function(e){var i=t(e.target).closest(".modal-trigger");if(i.length){var n=M.getIdFromTrigger(i[0]),s=document.getElementById(n).M_Modal;s&&s.open(i),e.preventDefault()}}},{key:"_handleOverlayClick",value:function(){this.options.dismissible&&this.close()}},{key:"_handleModalCloseClick",value:function(e){t(e.target).closest(".modal-close").length&&this.close()}},{key:"_handleKeydown",value:function(t){27===t.keyCode&&this.options.dismissible&&this.close()}},{key:"_handleFocus",value:function(t){this.el.contains(t.target)||this.el.focus()}},{key:"_animateIn",value:function(){var i=this;t.extend(this.el.style,{display:"block",opacity:0}),t.extend(this.$overlay[0].style,{display:"block",opacity:0}),e({targets:this.$overlay[0],opacity:this.options.opacity,duration:this.options.inDuration,easing:"easeOutQuad"});var n={targets:this.el,duration:this.options.inDuration,easing:"easeOutCubic",complete:function(){"function"==typeof i.options.onOpenEnd&&i.options.onOpenEnd.call(i,i.el,i._openingTrigger)}};this.el.classList.contains("bottom-sheet")?(t.extend(n,{bottom:0,opacity:1}),e(n)):(t.extend(n,{top:[this.options.startingTop,this.options.endingTop],opacity:1,scaleX:[.8,1],scaleY:[.8,1]}),e(n))}},{key:"_animateOut",value:function(){var i=this;e({targets:this.$overlay[0],opacity:0,duration:this.options.outDuration,easing:"easeOutQuart"});var n={targets:this.el,duration:this.options.outDuration,easing:"easeOutCubic",complete:function(){i.el.style.display="none",i.$overlay.remove(),"function"==typeof i.options.onCloseEnd&&i.options.onCloseEnd.call(i,i.el)}};this.el.classList.contains("bottom-sheet")?(t.extend(n,{bottom:"-100%",opacity:0}),e(n)):(t.extend(n,{top:[this.options.endingTop,this.options.startingTop],opacity:0,scaleX:.8,scaleY:.8}),e(n))}},{key:"open",value:function(t){if(!this.isOpen)return this.isOpen=!0,s._modalsOpen++,this.$overlay[0].style.zIndex=1e3+2*s._modalsOpen,this.el.style.zIndex=1e3+2*s._modalsOpen+1,this._openingTrigger=t?t[0]:void 0,"function"==typeof this.options.onOpenStart&&this.options.onOpenStart.call(this,this.el,this._openingTrigger),this.options.preventScrolling&&(document.body.style.overflow="hidden"),this.el.classList.add("open"),this.el.insertAdjacentElement("afterend",this.$overlay[0]),this.options.dismissible&&(this._handleKeydownBound=this._handleKeydown.bind(this),this._handleFocusBound=this._handleFocus.bind(this),document.addEventListener("keydown",this._handleKeydownBound),document.addEventListener("focus",this._handleFocusBound,!0)),e.remove(this.el),e.remove(this.$overlay[0]),this._animateIn(),this.el.focus(),this}},{key:"close",value:function(){if(this.isOpen)return this.isOpen=!1,s._modalsOpen--,"function"==typeof this.options.onCloseStart&&this.options.onCloseStart.call(this,this.el),this.el.classList.remove("open"),0===s._modalsOpen&&(document.body.style.overflow=""),this.options.dismissible&&(document.removeEventListener("keydown",this._handleKeydownBound),document.removeEventListener("focus",this._handleFocusBound)),e.remove(this.el),e.remove(this.$overlay[0]),this._animateOut(),this}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Modal}},{key:"defaults",get:function(){return i}}]),s}();n._modalsOpen=0,n._count=0,M.Modal=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"modal","M_Modal")}(cash,M.anime),function(t,e){"use strict";var i={inDuration:275,outDuration:200,onOpenStart:null,onOpenEnd:null,onCloseStart:null,onCloseEnd:null},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Materialbox=n,n.options=t.extend({},s.defaults,i),n.overlayActive=!1,n.doneAnimating=!0,n.placeholder=t("<div></div>").addClass("material-placeholder"),n.originalWidth=0,n.originalHeight=0,n.originInlineStyles=n.$el.attr("style"),n.caption=n.el.getAttribute("data-caption")||"",n.$el.before(n.placeholder),n.placeholder.append(n.$el),n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._removeEventHandlers(),this.el.M_Materialbox=void 0}},{key:"_setupEventHandlers",value:function(){this._handleMaterialboxClickBound=this._handleMaterialboxClick.bind(this),this.el.addEventListener("click",this._handleMaterialboxClickBound)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("click",this._handleMaterialboxClickBound)}},{key:"_handleMaterialboxClick",value:function(t){!1===this.doneAnimating||this.overlayActive&&this.doneAnimating?this.close():this.open()}},{key:"_handleWindowScroll",value:function(){this.overlayActive&&this.close()}},{key:"_handleWindowResize",value:function(){this.overlayActive&&this.close()}},{key:"_handleWindowEscape",value:function(t){27===t.keyCode&&this.doneAnimating&&this.overlayActive&&this.close()}},{key:"_makeAncestorsOverflowVisible",value:function(){this.ancestorsChanged=t();for(var e=this.placeholder[0].parentNode;null!==e&&!t(e).is(document);){var i=t(e);"visible"!==i.css("overflow")&&(i.css("overflow","visible"),void 0===this.ancestorsChanged?this.ancestorsChanged=i:this.ancestorsChanged=this.ancestorsChanged.add(i)),e=e.parentNode}}},{key:"_animateImageIn",value:function(){var t=this,i={targets:this.el,height:[this.originalHeight,this.newHeight],width:[this.originalWidth,this.newWidth],left:M.getDocumentScrollLeft()+this.windowWidth/2-this.placeholder.offset().left-this.newWidth/2,top:M.getDocumentScrollTop()+this.windowHeight/2-this.placeholder.offset().top-this.newHeight/2,duration:this.options.inDuration,easing:"easeOutQuad",complete:function(){t.doneAnimating=!0,"function"==typeof t.options.onOpenEnd&&t.options.onOpenEnd.call(t,t.el)}};this.maxWidth=this.$el.css("max-width"),this.maxHeight=this.$el.css("max-height"),"none"!==this.maxWidth&&(i.maxWidth=this.newWidth),"none"!==this.maxHeight&&(i.maxHeight=this.newHeight),e(i)}},{key:"_animateImageOut",value:function(){var t=this,i={targets:this.el,width:this.originalWidth,height:this.originalHeight,left:0,top:0,duration:this.options.outDuration,easing:"easeOutQuad",complete:function(){t.placeholder.css({height:"",width:"",position:"",top:"",left:""}),t.attrWidth&&t.$el.attr("width",t.attrWidth),t.attrHeight&&t.$el.attr("height",t.attrHeight),t.$el.removeAttr("style"),t.$el.attr("style",t.originInlineStyles),t.$el.removeClass("active"),t.doneAnimating=!0,t.ancestorsChanged.length&&t.ancestorsChanged.css("overflow",""),"function"==typeof t.options.onCloseEnd&&t.options.onCloseEnd.call(t,t.el)}};e(i)}},{key:"_updateVars",value:function(){this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight,this.caption=this.el.getAttribute("data-caption")||""}},{key:"open",value:function(){var i=this;this._updateVars(),this.originalWidth=this.el.getBoundingClientRect().width,this.originalHeight=this.el.getBoundingClientRect().height,this.doneAnimating=!1,this.$el.addClass("active"),this.overlayActive=!0,"function"==typeof this.options.onOpenStart&&this.options.onOpenStart.call(this,this.el),this.placeholder.css({width:this.placeholder[0].getBoundingClientRect().width+"px",height:this.placeholder[0].getBoundingClientRect().height+"px",position:"relative",top:0,left:0}),this._makeAncestorsOverflowVisible(),this.$el.css({position:"absolute","z-index":1e3,"will-change":"left, top, width, height"}),this.attrWidth=this.$el.attr("width"),this.attrHeight=this.$el.attr("height"),this.attrWidth&&(this.$el.css("width",this.attrWidth+"px"),this.$el.removeAttr("width")),this.attrHeight&&(this.$el.css("width",this.attrHeight+"px"),this.$el.removeAttr("height")),this.$overlay=t('<div id="materialbox-overlay"></div>').css({opacity:0}).one("click",function(){i.doneAnimating&&i.close()}),this.$el.before(this.$overlay);var n=this.$overlay[0].getBoundingClientRect();this.$overlay.css({width:this.windowWidth+"px",height:this.windowHeight+"px",left:-1*n.left+"px",top:-1*n.top+"px"}),e.remove(this.el),e.remove(this.$overlay[0]),e({targets:this.$overlay[0],opacity:1,duration:this.options.inDuration,easing:"easeOutQuad"}),""!==this.caption&&(this.$photocaption&&e.remove(this.$photoCaption[0]),this.$photoCaption=t('<div class="materialbox-caption"></div>'),this.$photoCaption.text(this.caption),t("body").append(this.$photoCaption),this.$photoCaption.css({display:"inline"}),e({targets:this.$photoCaption[0],opacity:1,duration:this.options.inDuration,easing:"easeOutQuad"}));var s=0,o=this.originalWidth/this.windowWidth,a=this.originalHeight/this.windowHeight;this.newWidth=0,this.newHeight=0,o>a?(s=this.originalHeight/this.originalWidth,this.newWidth=.9*this.windowWidth,this.newHeight=.9*this.windowWidth*s):(s=this.originalWidth/this.originalHeight,this.newWidth=.9*this.windowHeight*s,this.newHeight=.9*this.windowHeight),this._animateImageIn(),this._handleWindowScrollBound=this._handleWindowScroll.bind(this),this._handleWindowResizeBound=this._handleWindowResize.bind(this),this._handleWindowEscapeBound=this._handleWindowEscape.bind(this),window.addEventListener("scroll",this._handleWindowScrollBound),window.addEventListener("resize",this._handleWindowResizeBound),window.addEventListener("keyup",this._handleWindowEscapeBound)}},{key:"close",value:function(){var t=this;this._updateVars(),this.doneAnimating=!1,"function"==typeof this.options.onCloseStart&&this.options.onCloseStart.call(this,this.el),e.remove(this.el),e.remove(this.$overlay[0]),""!==this.caption&&e.remove(this.$photoCaption[0]),window.removeEventListener("scroll",this._handleWindowScrollBound),window.removeEventListener("resize",this._handleWindowResizeBound),window.removeEventListener("keyup",this._handleWindowEscapeBound),e({targets:this.$overlay[0],opacity:0,duration:this.options.outDuration,easing:"easeOutQuad",complete:function(){t.overlayActive=!1,t.$overlay.remove()}}),this._animateImageOut(),""!==this.caption&&e({targets:this.$photoCaption[0],opacity:0,duration:this.options.outDuration,easing:"easeOutQuad",complete:function(){t.$photoCaption.remove()}})}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Materialbox}},{key:"defaults",get:function(){return i}}]),s}();M.Materialbox=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"materialbox","M_Materialbox")}(cash,M.anime),function(t){"use strict";var e={responsiveThreshold:0},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_Parallax=s,s.options=t.extend({},n.defaults,i),s._enabled=window.innerWidth>s.options.responsiveThreshold,s.$img=s.$el.find("img").first(),s.$img.each(function(){var e=this;e.complete&&t(e).trigger("load")}),s._updateParallax(),s._setupEventHandlers(),s._setupStyles(),n._parallaxes.push(s),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){n._parallaxes.splice(n._parallaxes.indexOf(this),1),this.$img[0].style.transform="",this._removeEventHandlers(),this.$el[0].M_Parallax=void 0}},{key:"_setupEventHandlers",value:function(){this._handleImageLoadBound=this._handleImageLoad.bind(this),this.$img[0].addEventListener("load",this._handleImageLoadBound),0===n._parallaxes.length&&(n._handleScrollThrottled=M.throttle(n._handleScroll,5),window.addEventListener("scroll",n._handleScrollThrottled),n._handleWindowResizeThrottled=M.throttle(n._handleWindowResize,5),window.addEventListener("resize",n._handleWindowResizeThrottled))}},{key:"_removeEventHandlers",value:function(){this.$img[0].removeEventListener("load",this._handleImageLoadBound),0===n._parallaxes.length&&(window.removeEventListener("scroll",n._handleScrollThrottled),window.removeEventListener("resize",n._handleWindowResizeThrottled))}},{key:"_setupStyles",value:function(){this.$img[0].style.opacity=1}},{key:"_handleImageLoad",value:function(){this._updateParallax()}},{key:"_updateParallax",value:function(){var t=this.$el.height()>0?this.el.parentNode.offsetHeight:500,e=this.$img[0].offsetHeight-t,i=this.$el.offset().top+t,n=this.$el.offset().top,s=M.getDocumentScrollTop(),o=window.innerHeight,a=e*((s+o-n)/(t+o));this._enabled?i>s&&n<s+o&&(this.$img[0].style.transform="translate3D(-50%, "+a+"px, 0)"):this.$img[0].style.transform=""}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Parallax}},{key:"_handleScroll",value:function(){for(var t=0;t<n._parallaxes.length;t++){var e=n._parallaxes[t];e._updateParallax.call(e)}}},{key:"_handleWindowResize",value:function(){for(var t=0;t<n._parallaxes.length;t++){var e=n._parallaxes[t];e._enabled=window.innerWidth>e.options.responsiveThreshold}}},{key:"defaults",get:function(){return e}}]),n}();i._parallaxes=[],M.Parallax=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"parallax","M_Parallax")}(cash),function(t,e){"use strict";var i={duration:300,onShow:null,swipeable:!1,responsiveThreshold:1/0},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Tabs=n,n.options=t.extend({},s.defaults,i),n.$tabLinks=n.$el.children("li.tab").children("a"),n.index=0,n._setTabsAndTabWidth(),n._setupActiveTabLink(),n._createIndicator(),n.options.swipeable?n._setupSwipeableTabs():n._setupNormalTabs(),n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._removeEventHandlers(),this._indicator.parentNode.removeChild(this._indicator),this.options.swipeable?this._teardownSwipeableTabs():this._teardownNormalTabs(),this.$el[0].M_Tabs=void 0}},{key:"_setupEventHandlers",value:function(){this._handleWindowResizeBound=this._handleWindowResize.bind(this),window.addEventListener("resize",this._handleWindowResizeBound),this._handleTabClickBound=this._handleTabClick.bind(this),this.el.addEventListener("click",this._handleTabClickBound)}},{key:"_removeEventHandlers",value:function(){window.removeEventListener("resize",this._handleWindowResizeBound),this.el.removeEventListener("click",this._handleTabClickBound)}},{key:"_handleWindowResize",value:function(){this._setTabsAndTabWidth(),0!==this.tabWidth&&0!==this.tabsWidth&&(this._indicator.style.left=this._calcLeftPos(this.$activeTabLink)+"px",this._indicator.style.right=this._calcRightPos(this.$activeTabLink)+"px")}},{key:"_handleTabClick",value:function(e){var i=this,n=t(e.target).closest("li.tab"),s=t(e.target).closest("a");if(s.length&&s.parent().hasClass("tab"))if(n.hasClass("disabled"))e.preventDefault();else if(!s.attr("target")){this._setTabsAndTabWidth(),this.$activeTabLink.removeClass("active");var o=this.$content;this.$activeTabLink=s,this.$content=t(M.escapeHash(s[0].hash)),this.$tabLinks=this.$el.children("li.tab").children("a"),this.$activeTabLink.addClass("active");var a=this.index;this.index=Math.max(this.$tabLinks.index(s),0),this.options.swipeable?this._tabsCarousel&&this._tabsCarousel.set(this.index,function(){"function"==typeof i.options.onShow&&i.options.onShow.call(i,i.$content[0])}):this.$content.length&&(this.$content[0].style.display="block",this.$content.addClass("active"),"function"==typeof this.options.onShow&&this.options.onShow.call(this,this.$content[0]),o.length&&!o.is(this.$content)&&(o[0].style.display="none",o.removeClass("active"))),this._animateIndicator(a),e.preventDefault()}}},{key:"_createIndicator",value:function(){var t=this,e=document.createElement("li");e.classList.add("indicator"),this.el.appendChild(e),this._indicator=e,setTimeout(function(){t._indicator.style.left=t._calcLeftPos(t.$activeTabLink)+"px",t._indicator.style.right=t._calcRightPos(t.$activeTabLink)+"px"},0)}},{key:"_setupActiveTabLink",value:function(){this.$activeTabLink=t(this.$tabLinks.filter('[href="'+location.hash+'"]')),0===this.$activeTabLink.length&&(this.$activeTabLink=this.$el.children("li.tab").children("a.active").first()),0===this.$activeTabLink.length&&(this.$activeTabLink=this.$el.children("li.tab").children("a").first()),this.$tabLinks.removeClass("active"),this.$activeTabLink[0].classList.add("active"),this.index=Math.max(this.$tabLinks.index(this.$activeTabLink),0),this.$activeTabLink.length&&(this.$content=t(M.escapeHash(this.$activeTabLink[0].hash)),this.$content.addClass("active"))}},{key:"_setupSwipeableTabs",value:function(){var e=this;window.innerWidth>this.options.responsiveThreshold&&(this.options.swipeable=!1);var i=t();this.$tabLinks.each(function(e){var n=t(M.escapeHash(e.hash));n.addClass("carousel-item"),i=i.add(n)});var n=t('<div class="tabs-content carousel carousel-slider"></div>');i.first().before(n),n.append(i),i[0].style.display="";var s=this.$activeTabLink.closest(".tab").index();this._tabsCarousel=M.Carousel.init(n[0],{fullWidth:!0,noWrap:!0,onCycleTo:function(i){var n=e.index;e.index=t(i).index(),e.$activeTabLink.removeClass("active"),e.$activeTabLink=e.$tabLinks.eq(e.index),e.$activeTabLink.addClass("active"),e._animateIndicator(n),"function"==typeof e.options.onShow&&e.options.onShow.call(e,e.$content[0])}}),this._tabsCarousel.set(s)}},{key:"_teardownSwipeableTabs",value:function(){var t=this._tabsCarousel.$el;this._tabsCarousel.destroy(),t.after(t.children()),t.remove()}},{key:"_setupNormalTabs",value:function(){this.$tabLinks.not(this.$activeTabLink).each(function(e){if(e.hash){var i=t(M.escapeHash(e.hash));i.length&&(i[0].style.display="none")}})}},{key:"_teardownNormalTabs",value:function(){this.$tabLinks.each(function(e){if(e.hash){var i=t(M.escapeHash(e.hash));i.length&&(i[0].style.display="")}})}},{key:"_setTabsAndTabWidth",value:function(){this.tabsWidth=this.$el.width(),this.tabWidth=Math.max(this.tabsWidth,this.el.scrollWidth)/this.$tabLinks.length}},{key:"_calcRightPos",value:function(t){return Math.ceil(this.tabsWidth-t.position().left-t[0].getBoundingClientRect().width)}},{key:"_calcLeftPos",value:function(t){return Math.floor(t.position().left)}},{key:"updateTabIndicator",value:function(){this._animateIndicator(this.index)}},{key:"_animateIndicator",value:function(t){var i=0,n=0;this.index-t>=0?i=90:n=90;var s={targets:this._indicator,left:{value:this._calcLeftPos(this.$activeTabLink),delay:i},right:{value:this._calcRightPos(this.$activeTabLink),delay:n},duration:this.options.duration,easing:"easeOutQuad"};e.remove(this._indicator),e(s)}},{key:"select",value:function(t){var e=this.$tabLinks.filter('[href="#'+t+'"]');e.length&&e.trigger("click")}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Tabs}},{key:"defaults",get:function(){return i}}]),s}();window.M.Tabs=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"tabs","M_Tabs")}(cash,M.anime),function(t,e){"use strict";var i={exitDelay:200,enterDelay:0,html:null,margin:5,inDuration:250,outDuration:200,position:"bottom",transitionMovement:10},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Tooltip=n,n.options=t.extend({},s.defaults,i),n.isOpen=!1,n.isHovered=!1,n.isFocused=!1,n._appendTooltipEl(),n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){t(this.tooltipEl).remove(),this._removeEventHandlers(),this.el.M_Tooltip=void 0}},{key:"_appendTooltipEl",value:function(){var t=document.createElement("div");t.classList.add("material-tooltip"),this.tooltipEl=t;var e=document.createElement("div");e.classList.add("tooltip-content"),e.innerHTML=this.options.html,t.appendChild(e),document.body.appendChild(t)}},{key:"_updateTooltipContent",value:function(){this.tooltipEl.querySelector(".tooltip-content").innerHTML=this.options.html}},{key:"_setupEventHandlers",value:function(){this._handleMouseEnterBound=this._handleMouseEnter.bind(this),this._handleMouseLeaveBound=this._handleMouseLeave.bind(this),this._handleFocusBound=this._handleFocus.bind(this),this._handleBlurBound=this._handleBlur.bind(this),this.el.addEventListener("mouseenter",this._handleMouseEnterBound),this.el.addEventListener("mouseleave",this._handleMouseLeaveBound),this.el.addEventListener("focus",this._handleFocusBound,!0),this.el.addEventListener("blur",this._handleBlurBound,!0)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("mouseenter",this._handleMouseEnterBound),this.el.removeEventListener("mouseleave",this._handleMouseLeaveBound),this.el.removeEventListener("focus",this._handleFocusBound,!0),this.el.removeEventListener("blur",this._handleBlurBound,!0)}},{key:"open",value:function(){this.isOpen||(this.isOpen=!0,this.options=t.extend({},this.options,this._getAttributeOptions()),this._updateTooltipContent(),this._setEnterDelayTimeout())}},{key:"close",value:function(){this.isOpen&&(this.isOpen=!1,this._setExitDelayTimeout())}},{key:"_setExitDelayTimeout",value:function(){var t=this;clearTimeout(this._exitDelayTimeout),this._exitDelayTimeout=setTimeout(function(){t.isHovered||t.isFocused||t._animateOut()},this.options.exitDelay)}},{key:"_setEnterDelayTimeout",value:function(){var t=this;clearTimeout(this._enterDelayTimeout),this._enterDelayTimeout=setTimeout(function(){(t.isHovered||t.isFocused)&&t._animateIn()},this.options.enterDelay)}},{key:"_positionTooltip",value:function(){var e=this.el,i=this.tooltipEl,n=e.offsetHeight,s=e.offsetWidth,o=i.offsetHeight,a=i.offsetWidth,r=void 0,l=this.options.margin,h=void 0,d=void 0;this.xMovement=0,this.yMovement=0,h=e.getBoundingClientRect().top+M.getDocumentScrollTop(),d=e.getBoundingClientRect().left+M.getDocumentScrollLeft(),"top"===this.options.position?(h+=-o-l,d+=s/2-a/2,this.yMovement=-this.options.transitionMovement):"right"===this.options.position?(h+=n/2-o/2,d+=s+l,this.xMovement=this.options.transitionMovement):"left"===this.options.position?(h+=n/2-o/2,d+=-a-l,this.xMovement=-this.options.transitionMovement):(h+=n+l,d+=s/2-a/2,this.yMovement=this.options.transitionMovement),r=this._repositionWithinScreen(d,h,a,o),t(i).css({top:r.y+"px",left:r.x+"px"})}},{key:"_repositionWithinScreen",value:function(t,e,i,n){var s=M.getDocumentScrollLeft(),o=M.getDocumentScrollTop(),a=t-s,r=e-o,l={left:a,top:r,width:i,height:n},h=this.options.margin+this.options.transitionMovement,d=M.checkWithinContainer(document.body,l,h);return d.left?a=h:d.right&&(a-=a+i-window.innerWidth),d.top?r=h:d.bottom&&(r-=r+n-window.innerHeight),{x:a+s,y:r+o}}},{key:"_animateIn",value:function(){this._positionTooltip(),this.tooltipEl.style.visibility="visible",e.remove(this.tooltipEl),e({targets:this.tooltipEl,opacity:1,translateX:this.xMovement,translateY:this.yMovement,duration:this.options.inDuration,easing:"easeOutCubic"})}},{key:"_animateOut",value:function(){e.remove(this.tooltipEl),e({targets:this.tooltipEl,opacity:0,translateX:0,translateY:0,duration:this.options.outDuration,easing:"easeOutCubic"})}},{key:"_handleMouseEnter",value:function(){this.isHovered=!0,this.open()}},{key:"_handleMouseLeave",value:function(){this.isHovered=!1,this.close()}},{key:"_handleFocus",value:function(){this.isFocused=!0,this.open()}},{key:"_handleBlur",value:function(){this.isFocused=!1,this.close()}},{key:"_getAttributeOptions",value:function(){var t={},e=this.el.getAttribute("data-tooltip"),i=this.el.getAttribute("data-position");return e&&(t.html=e),i&&(t.position=i),t}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Tooltip}},{key:"defaults",get:function(){return i}}]),s}();M.Tooltip=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"tooltip","M_Tooltip")}(cash,M.anime),function(t){"use strict";function e(t){return null!==t&&t===t.window}function i(t){return e(t)?t:9===t.nodeType&&t.defaultView}function n(t){var e,n,s={top:0,left:0},o=t&&t.ownerDocument;return e=o.documentElement,void 0!==t.getBoundingClientRect&&(s=t.getBoundingClientRect()),n=i(o),{top:s.top+n.pageYOffset-e.clientTop,left:s.left+n.pageXOffset-e.clientLeft}}function s(t){var e="";for(var i in t)t.hasOwnProperty(i)&&(e+=i+":"+t[i]+";");return e}function o(t){if(!1===d.allowEvent(t))return null;for(var e=null,i=t.target||t.srcElement;null!==i.parentNode;){if(!(i instanceof SVGElement)&&-1!==i.className.indexOf("waves-effect")){e=i;break}i=i.parentNode}return e}function a(e){var i=o(e);null!==i&&(h.show(e,i),"ontouchstart"in t&&(i.addEventListener("touchend",h.hide,!1),i.addEventListener("touchcancel",h.hide,!1)),i.addEventListener("mouseup",h.hide,!1),i.addEventListener("mouseleave",h.hide,!1),i.addEventListener("dragend",h.hide,!1))}var r=r||{},l=document.querySelectorAll.bind(document),h={duration:750,show:function(t,e){if(2===t.button)return!1;var i=e||this,o=document.createElement("div");o.className="waves-ripple",i.appendChild(o);var a=n(i),r=t.pageY-a.top,l=t.pageX-a.left,d="scale("+i.clientWidth/100*10+")";"touches"in t&&(r=t.touches[0].pageY-a.top,l=t.touches[0].pageX-a.left),o.setAttribute("data-hold",Date.now()),o.setAttribute("data-scale",d),o.setAttribute("data-x",l),o.setAttribute("data-y",r);var u={top:r+"px",left:l+"px"};o.className=o.className+" waves-notransition",o.setAttribute("style",s(u)),o.className=o.className.replace("waves-notransition",""),u["-webkit-transform"]=d,u["-moz-transform"]=d,u["-ms-transform"]=d,u["-o-transform"]=d,u.transform=d,u.opacity="1",u["-webkit-transition-duration"]=h.duration+"ms",u["-moz-transition-duration"]=h.duration+"ms",u["-o-transition-duration"]=h.duration+"ms",u["transition-duration"]=h.duration+"ms",u["-webkit-transition-timing-function"]="cubic-bezier(0.250, 0.460, 0.450, 0.940)",u["-moz-transition-timing-function"]="cubic-bezier(0.250, 0.460, 0.450, 0.940)",u["-o-transition-timing-function"]="cubic-bezier(0.250, 0.460, 0.450, 0.940)",u["transition-timing-function"]="cubic-bezier(0.250, 0.460, 0.450, 0.940)",o.setAttribute("style",s(u))},hide:function(t){d.touchup(t);var e=this,i=(e.clientWidth,null),n=e.getElementsByClassName("waves-ripple");if(!(n.length>0))return!1;var o=(i=n[n.length-1]).getAttribute("data-x"),a=i.getAttribute("data-y"),r=i.getAttribute("data-scale"),l=350-(Date.now()-Number(i.getAttribute("data-hold")));l<0&&(l=0),setTimeout(function(){var t={top:a+"px",left:o+"px",opacity:"0","-webkit-transition-duration":h.duration+"ms","-moz-transition-duration":h.duration+"ms","-o-transition-duration":h.duration+"ms","transition-duration":h.duration+"ms","-webkit-transform":r,"-moz-transform":r,"-ms-transform":r,"-o-transform":r,transform:r};i.setAttribute("style",s(t)),setTimeout(function(){try{e.removeChild(i)}catch(t){return!1}},h.duration)},l)},wrapInput:function(t){for(var e=0;e<t.length;e++){var i=t[e];if("input"===i.tagName.toLowerCase()){var n=i.parentNode;if("i"===n.tagName.toLowerCase()&&-1!==n.className.indexOf("waves-effect"))continue;var s=document.createElement("i");s.className=i.className+" waves-input-wrapper";var o=i.getAttribute("style");o||(o=""),s.setAttribute("style",o),i.className="waves-button-input",i.removeAttribute("style"),n.replaceChild(s,i),s.appendChild(i)}}}},d={touches:0,allowEvent:function(t){var e=!0;return"touchstart"===t.type?d.touches+=1:"touchend"===t.type||"touchcancel"===t.type?setTimeout(function(){d.touches>0&&(d.touches-=1)},500):"mousedown"===t.type&&d.touches>0&&(e=!1),e},touchup:function(t){d.allowEvent(t)}};r.displayEffect=function(e){"duration"in(e=e||{})&&(h.duration=e.duration),h.wrapInput(l(".waves-effect")),"ontouchstart"in t&&document.body.addEventListener("touchstart",a,!1),document.body.addEventListener("mousedown",a,!1)},r.attach=function(e){"input"===e.tagName.toLowerCase()&&(h.wrapInput([e]),e=e.parentNode),"ontouchstart"in t&&e.addEventListener("touchstart",a,!1),e.addEventListener("mousedown",a,!1)},t.Waves=r,document.addEventListener("DOMContentLoaded",function(){r.displayEffect()},!1)}(window),function(t,e){"use strict";var i={html:"",displayLength:4e3,inDuration:300,outDuration:375,classes:"",completeCallback:null,activationPercent:.8},n=function(){function n(e){_classCallCheck(this,n),this.options=t.extend({},n.defaults,e),this.message=this.options.html,this.panning=!1,this.timeRemaining=this.options.displayLength,0===n._toasts.length&&n._createContainer(),n._toasts.push(this);var i=this._createToast();i.M_Toast=this,this.el=i,this._animateIn(),this._setTimer()}return _createClass(n,[{key:"_createToast",value:function(){var e=document.createElement("div");return e.classList.add("toast"),this.options.classes.length&&t(e).addClass(this.options.classes),("object"==typeof HTMLElement?this.message instanceof HTMLElement:this.message&&"object"==typeof this.message&&null!==this.message&&1===this.message.nodeType&&"string"==typeof this.message.nodeName)?e.appendChild(this.message):this.message.jquery?t(e).append(this.message[0]):e.innerHTML=this.message,n._container.appendChild(e),e}},{key:"_animateIn",value:function(){e({targets:this.el,top:0,opacity:1,duration:300,easing:"easeOutCubic"})}},{key:"_setTimer",value:function(){var t=this;this.timeRemaining!==1/0&&(this.counterInterval=setInterval(function(){t.panning||(t.timeRemaining-=20),t.timeRemaining<=0&&t.dismiss()},20))}},{key:"dismiss",value:function(){var t=this;window.clearInterval(this.counterInterval);var i=this.el.offsetWidth*this.options.activationPercent;this.wasSwiped&&(this.el.style.transition="transform .05s, opacity .05s",this.el.style.transform="translateX("+i+"px)",this.el.style.opacity=0),e({targets:this.el,opacity:0,marginTop:-40,duration:this.options.outDuration,easing:"easeOutExpo",complete:function(){"function"==typeof t.options.completeCallback&&t.options.completeCallback(),t.el.parentNode.removeChild(t.el),n._toasts.splice(n._toasts.indexOf(t),1),0===n._toasts.length&&n._removeContainer()}})}}],[{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Toast}},{key:"_createContainer",value:function(){var t=document.createElement("div");t.setAttribute("id","toast-container"),t.addEventListener("touchstart",n._onDragStart),t.addEventListener("touchmove",n._onDragMove),t.addEventListener("touchend",n._onDragEnd),t.addEventListener("mousedown",n._onDragStart),document.addEventListener("mousemove",n._onDragMove),document.addEventListener("mouseup",n._onDragEnd),document.body.appendChild(t),n._container=t}},{key:"_removeContainer",value:function(){document.removeEventListener("mousemove",n._onDragMove),document.removeEventListener("mouseup",n._onDragEnd),n._container.parentNode.removeChild(n._container),n._container=null}},{key:"_onDragStart",value:function(e){if(e.target&&t(e.target).closest(".toast").length){var i=t(e.target).closest(".toast")[0].M_Toast;i.panning=!0,n._draggedToast=i,i.el.classList.add("panning"),i.el.style.transition="",i.startingXPos=n._xPos(e),i.time=Date.now(),i.xPos=n._xPos(e)}}},{key:"_onDragMove",value:function(t){if(n._draggedToast){t.preventDefault();var e=n._draggedToast;e.deltaX=Math.abs(e.xPos-n._xPos(t)),e.xPos=n._xPos(t),e.velocityX=e.deltaX/(Date.now()-e.time),e.time=Date.now();var i=e.xPos-e.startingXPos,s=e.el.offsetWidth*e.options.activationPercent;e.el.style.transform="translateX("+i+"px)",e.el.style.opacity=1-Math.abs(i/s)}}},{key:"_onDragEnd",value:function(){if(n._draggedToast){var t=n._draggedToast;t.panning=!1,t.el.classList.remove("panning");var e=t.xPos-t.startingXPos,i=t.el.offsetWidth*t.options.activationPercent;Math.abs(e)>i||t.velocityX>1?(t.wasSwiped=!0,t.dismiss()):(t.el.style.transition="transform .2s, opacity .2s",t.el.style.transform="",t.el.style.opacity=""),n._draggedToast=null}}},{key:"_xPos",value:function(t){return t.targetTouches&&t.targetTouches.length>=1?t.targetTouches[0].clientX:t.clientX}},{key:"dismissAll",value:function(){for(var t in n._toasts)n._toasts[t].dismiss()}},{key:"defaults",get:function(){return i}}]),n}();n._toasts=[],n._container=null,n._draggedToast=null,M.Toast=n,M.toast=function(t){return new n(t)}}(cash,M.anime),function(t,e){"use strict";var i={edge:"left",draggable:!0,inDuration:250,outDuration:200,onOpenStart:null,onOpenEnd:null,onCloseStart:null,onCloseEnd:null,preventScrolling:!0},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Sidenav=n,n.id=n.$el.attr("id"),n.options=t.extend({},s.defaults,i),n.isOpen=!1,n.isFixed=n.el.classList.contains("sidenav-fixed"),n.isDragged=!1,n.lastWindowWidth=window.innerWidth,n.lastWindowHeight=window.innerHeight,n._createOverlay(),n._createDragTarget(),n._setupEventHandlers(),n._setupClasses(),n._setupFixed(),s._sidenavs.push(n),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._removeEventHandlers(),this._overlay.parentNode.removeChild(this._overlay),this.dragTarget.parentNode.removeChild(this.dragTarget),this.el.M_Sidenav=void 0;var t=s._sidenavs.indexOf(this);t>=0&&s._sidenavs.splice(t,1)}},{key:"_createOverlay",value:function(){var t=document.createElement("div");this._closeBound=this.close.bind(this),t.classList.add("sidenav-overlay"),t.addEventListener("click",this._closeBound),document.body.appendChild(t),this._overlay=t}},{key:"_setupEventHandlers",value:function(){0===s._sidenavs.length&&document.body.addEventListener("click",this._handleTriggerClick),this._handleDragTargetDragBound=this._handleDragTargetDrag.bind(this),this._handleDragTargetReleaseBound=this._handleDragTargetRelease.bind(this),this._handleCloseDragBound=this._handleCloseDrag.bind(this),this._handleCloseReleaseBound=this._handleCloseRelease.bind(this),this._handleCloseTriggerClickBound=this._handleCloseTriggerClick.bind(this),this.dragTarget.addEventListener("touchmove",this._handleDragTargetDragBound),this.dragTarget.addEventListener("touchend",this._handleDragTargetReleaseBound),this._overlay.addEventListener("touchmove",this._handleCloseDragBound),this._overlay.addEventListener("touchend",this._handleCloseReleaseBound),this.el.addEventListener("touchmove",this._handleCloseDragBound),this.el.addEventListener("touchend",this._handleCloseReleaseBound),this.el.addEventListener("click",this._handleCloseTriggerClickBound),this.isFixed&&(this._handleWindowResizeBound=this._handleWindowResize.bind(this),window.addEventListener("resize",this._handleWindowResizeBound))}},{key:"_removeEventHandlers",value:function(){1===s._sidenavs.length&&document.body.removeEventListener("click",this._handleTriggerClick),this.dragTarget.removeEventListener("touchmove",this._handleDragTargetDragBound),this.dragTarget.removeEventListener("touchend",this._handleDragTargetReleaseBound),this._overlay.removeEventListener("touchmove",this._handleCloseDragBound),this._overlay.removeEventListener("touchend",this._handleCloseReleaseBound),this.el.removeEventListener("touchmove",this._handleCloseDragBound),this.el.removeEventListener("touchend",this._handleCloseReleaseBound),this.el.removeEventListener("click",this._handleCloseTriggerClickBound),this.isFixed&&window.removeEventListener("resize",this._handleWindowResizeBound)}},{key:"_handleTriggerClick",value:function(e){var i=t(e.target).closest(".sidenav-trigger");if(e.target&&i.length){var n=M.getIdFromTrigger(i[0]),s=document.getElementById(n).M_Sidenav;s&&s.open(i),e.preventDefault()}}},{key:"_startDrag",value:function(t){var i=t.targetTouches[0].clientX;this.isDragged=!0,this._startingXpos=i,this._xPos=this._startingXpos,this._time=Date.now(),this._width=this.el.getBoundingClientRect().width,this._overlay.style.display="block",this._initialScrollTop=this.isOpen?this.el.scrollTop:M.getDocumentScrollTop(),this._verticallyScrolling=!1,e.remove(this.el),e.remove(this._overlay)}},{key:"_dragMoveUpdate",value:function(t){var e=t.targetTouches[0].clientX,i=this.isOpen?this.el.scrollTop:M.getDocumentScrollTop();this.deltaX=Math.abs(this._xPos-e),this._xPos=e,this.velocityX=this.deltaX/(Date.now()-this._time),this._time=Date.now(),this._initialScrollTop!==i&&(this._verticallyScrolling=!0)}},{key:"_handleDragTargetDrag",value:function(t){if(this.options.draggable&&!this._isCurrentlyFixed()&&!this._verticallyScrolling){this.isDragged||this._startDrag(t),this._dragMoveUpdate(t);var e=this._xPos-this._startingXpos,i=e>0?"right":"left";e=Math.min(this._width,Math.abs(e)),this.options.edge===i&&(e=0);var n=e,s="translateX(-100%)";"right"===this.options.edge&&(s="translateX(100%)",n=-n),this.percentOpen=Math.min(1,e/this._width),this.el.style.transform=s+" translateX("+n+"px)",this._overlay.style.opacity=this.percentOpen}}},{key:"_handleDragTargetRelease",value:function(){this.isDragged&&(this.percentOpen>.5?this.open():this._animateOut(),this.isDragged=!1,this._verticallyScrolling=!1)}},{key:"_handleCloseDrag",value:function(t){if(this.isOpen){if(!this.options.draggable||this._isCurrentlyFixed()||this._verticallyScrolling)return;this.isDragged||this._startDrag(t),this._dragMoveUpdate(t);var e=this._xPos-this._startingXpos,i=e>0?"right":"left";e=Math.min(this._width,Math.abs(e)),this.options.edge!==i&&(e=0);var n=-e;"right"===this.options.edge&&(n=-n),this.percentOpen=Math.min(1,1-e/this._width),this.el.style.transform="translateX("+n+"px)",this._overlay.style.opacity=this.percentOpen}}},{key:"_handleCloseRelease",value:function(){this.isOpen&&this.isDragged&&(this.percentOpen>.5?this._animateIn():this.close(),this.isDragged=!1,this._verticallyScrolling=!1)}},{key:"_handleCloseTriggerClick",value:function(e){t(e.target).closest(".sidenav-close").length&&!this._isCurrentlyFixed()&&this.close()}},{key:"_handleWindowResize",value:function(){this.lastWindowWidth!==window.innerWidth&&(window.innerWidth>992?this.open():this.close()),this.lastWindowWidth=window.innerWidth,this.lastWindowHeight=window.innerHeight}},{key:"_setupClasses",value:function(){"right"===this.options.edge&&(this.el.classList.add("right-aligned"),this.dragTarget.classList.add("right-aligned"))}},{key:"_removeClasses",value:function(){this.el.classList.remove("right-aligned"),this.dragTarget.classList.remove("right-aligned")}},{key:"_setupFixed",value:function(){this._isCurrentlyFixed()&&this.open()}},{key:"_isCurrentlyFixed",value:function(){return this.isFixed&&window.innerWidth>992}},{key:"_createDragTarget",value:function(){var t=document.createElement("div");t.classList.add("drag-target"),document.body.appendChild(t),this.dragTarget=t}},{key:"_preventBodyScrolling",value:function(){document.body.style.overflow="hidden"}},{key:"_enableBodyScrolling",value:function(){document.body.style.overflow=""}},{key:"open",value:function(){!0!==this.isOpen&&(this.isOpen=!0,"function"==typeof this.options.onOpenStart&&this.options.onOpenStart.call(this,this.el),this._isCurrentlyFixed()?(e.remove(this.el),e({targets:this.el,translateX:0,duration:0,easing:"easeOutQuad"}),this._enableBodyScrolling(),this._overlay.style.display="none"):(this.options.preventScrolling&&this._preventBodyScrolling(),this.isDragged&&1==this.percentOpen||this._animateIn()))}},{key:"close",value:function(){if(!1!==this.isOpen)if(this.isOpen=!1,"function"==typeof this.options.onCloseStart&&this.options.onCloseStart.call(this,this.el),this._isCurrentlyFixed()){var t="left"===this.options.edge?"-105%":"105%";this.el.style.transform="translateX("+t+")"}else this._enableBodyScrolling(),this.isDragged&&0==this.percentOpen?this._overlay.style.display="none":this._animateOut()}},{key:"_animateIn",value:function(){this._animateSidenavIn(),this._animateOverlayIn()}},{key:"_animateSidenavIn",value:function(){var t=this,i="left"===this.options.edge?-1:1;this.isDragged&&(i="left"===this.options.edge?i+this.percentOpen:i-this.percentOpen),e.remove(this.el),e({targets:this.el,translateX:[100*i+"%",0],duration:this.options.inDuration,easing:"easeOutQuad",complete:function(){"function"==typeof t.options.onOpenEnd&&t.options.onOpenEnd.call(t,t.el)}})}},{key:"_animateOverlayIn",value:function(){var i=0;this.isDragged?i=this.percentOpen:t(this._overlay).css({display:"block"}),e.remove(this._overlay),e({targets:this._overlay,opacity:[i,1],duration:this.options.inDuration,easing:"easeOutQuad"})}},{key:"_animateOut",value:function(){this._animateSidenavOut(),this._animateOverlayOut()}},{key:"_animateSidenavOut",value:function(){var t=this,i="left"===this.options.edge?-1:1,n=0;this.isDragged&&(n="left"===this.options.edge?i+this.percentOpen:i-this.percentOpen),e.remove(this.el),e({targets:this.el,translateX:[100*n+"%",105*i+"%"],duration:this.options.outDuration,easing:"easeOutQuad",complete:function(){"function"==typeof t.options.onCloseEnd&&t.options.onCloseEnd.call(t,t.el)}})}},{key:"_animateOverlayOut",value:function(){var i=this;e.remove(this._overlay),e({targets:this._overlay,opacity:0,duration:this.options.outDuration,easing:"easeOutQuad",complete:function(){t(i._overlay).css("display","none")}})}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Sidenav}},{key:"defaults",get:function(){return i}}]),s}();n._sidenavs=[],window.M.Sidenav=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"sidenav","M_Sidenav")}(cash,M.anime),function(t,e){"use strict";var i={throttle:100,scrollOffset:200,activeClass:"active",getActiveElement:function(t){return'a[href="#'+t+'"]'}},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_ScrollSpy=n,n.options=t.extend({},s.defaults,i),s._elements.push(n),s._count++,s._increment++,n.tickId=-1,n.id=s._increment,n._setupEventHandlers(),n._handleWindowScroll(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){s._elements.splice(s._elements.indexOf(this),1),s._elementsInView.splice(s._elementsInView.indexOf(this),1),s._visibleElements.splice(s._visibleElements.indexOf(this.$el),1),s._count--,this._removeEventHandlers(),t(this.options.getActiveElement(this.$el.attr("id"))).removeClass(this.options.activeClass),this.el.M_ScrollSpy=void 0}},{key:"_setupEventHandlers",value:function(){var t=M.throttle(this._handleWindowScroll,200);this._handleThrottledResizeBound=t.bind(this),this._handleWindowScrollBound=this._handleWindowScroll.bind(this),1===s._count&&(window.addEventListener("scroll",this._handleWindowScrollBound),window.addEventListener("resize",this._handleThrottledResizeBound),document.body.addEventListener("click",this._handleTriggerClick))}},{key:"_removeEventHandlers",value:function(){0===s._count&&(window.removeEventListener("scroll",this._handleWindowScrollBound),window.removeEventListener("resize",this._handleThrottledResizeBound),document.body.removeEventListener("click",this._handleTriggerClick))}},{key:"_handleTriggerClick",value:function(i){for(var n=t(i.target),o=s._elements.length-1;o>=0;o--){var a=s._elements[o];if(n.is('a[href="#'+a.$el.attr("id")+'"]')){i.preventDefault();var r=a.$el.offset().top+1;e({targets:[document.documentElement,document.body],scrollTop:r-a.options.scrollOffset,duration:400,easing:"easeOutCubic"});break}}}},{key:"_handleWindowScroll",value:function(){s._ticks++;for(var t=M.getDocumentScrollTop(),e=M.getDocumentScrollLeft(),i=e+window.innerWidth,n=t+window.innerHeight,o=s._findElements(t,i,n,e),a=0;a<o.length;a++){var r=o[a];r.tickId<0&&r._enter(),r.tickId=s._ticks}for(var l=0;l<s._elementsInView.length;l++){var h=s._elementsInView[l],d=h.tickId;d>=0&&d!==s._ticks&&(h._exit(),h.tickId=-1)}s._elementsInView=o}},{key:"_enter",value:function(){s._visibleElements=s._visibleElements.filter(function(t){return 0!=t.height()}),s._visibleElements[0]?(t(this.options.getActiveElement(s._visibleElements[0].attr("id"))).removeClass(this.options.activeClass),s._visibleElements[0][0].M_ScrollSpy&&this.id<s._visibleElements[0][0].M_ScrollSpy.id?s._visibleElements.unshift(this.$el):s._visibleElements.push(this.$el)):s._visibleElements.push(this.$el),t(this.options.getActiveElement(s._visibleElements[0].attr("id"))).addClass(this.options.activeClass)}},{key:"_exit",value:function(){var e=this;s._visibleElements=s._visibleElements.filter(function(t){return 0!=t.height()}),s._visibleElements[0]&&(t(this.options.getActiveElement(s._visibleElements[0].attr("id"))).removeClass(this.options.activeClass),s._visibleElements=s._visibleElements.filter(function(t){return t.attr("id")!=e.$el.attr("id")}),s._visibleElements[0]&&t(this.options.getActiveElement(s._visibleElements[0].attr("id"))).addClass(this.options.activeClass))}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_ScrollSpy}},{key:"_findElements",value:function(t,e,i,n){for(var o=[],a=0;a<s._elements.length;a++){var r=s._elements[a],l=t+r.options.scrollOffset||200;if(r.$el.height()>0){var h=r.$el.offset().top,d=r.$el.offset().left,u=d+r.$el.width(),c=h+r.$el.height();!(d>e||u<n||h>i||c<l)&&o.push(r)}}return o}},{key:"defaults",get:function(){return i}}]),s}();n._elements=[],n._elementsInView=[],n._visibleElements=[],n._count=0,n._increment=0,n._ticks=0,M.ScrollSpy=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"scrollSpy","M_ScrollSpy")}(cash,M.anime),function(t){"use strict";var e={data:{},limit:1/0,onAutocomplete:null,minLength:1,sortFunction:function(t,e,i){return t.indexOf(i)-e.indexOf(i)}},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_Autocomplete=s,s.options=t.extend({},n.defaults,i),s.isOpen=!1,s.count=0,s.activeIndex=-1,s.oldVal,s.$inputField=s.$el.closest(".input-field"),s.$active=t(),s._setupDropdown(),s._setupEventHandlers(),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this._removeDropdown(),this.el.M_Autocomplete=void 0}},{key:"_setupEventHandlers",value:function(){this._handleInputBlurBound=this._handleInputBlur.bind(this),this._handleInputKeyupAndFocusBound=this._handleInputKeyupAndFocus.bind(this),this._handleInputKeydownBound=this._handleInputKeydown.bind(this),this._handleContainerMousedownAndTouchstartBound=this._handleContainerMousedownAndTouchstart.bind(this),this.el.addEventListener("blur",this._handleInputBlurBound),this.el.addEventListener("keyup",this._handleInputKeyupAndFocusBound),this.el.addEventListener("focus",this._handleInputKeyupAndFocusBound),this.el.addEventListener("keydown",this._handleInputKeydownBound),this.container.addEventListener("mousedown",this._handleContainerMousedownAndTouchstartBound),void 0!==window.ontouchstart&&this.container.addEventListener("touchstart",this._handleContainerMousedownAndTouchstartBound)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("blur",this._handleInputBlurBound),this.el.removeEventListener("keyup",this._handleInputKeyupAndFocusBound),this.el.removeEventListener("focus",this._handleInputKeyupAndFocusBound),this.el.removeEventListener("keydown",this._handleInputKeydownBound),this.container.removeEventListener("mousedown",this._handleContainerMousedownAndTouchstartBound),void 0!==window.ontouchstart&&this.container.removeEventListener("touchstart",this._handleContainerMousedownAndTouchstartBound)}},{key:"_setupDropdown",value:function(){this.container=document.createElement("ul"),this.container.id="autocomplete-options-"+M.guid(),t(this.container).addClass("autocomplete-content dropdown-content"),this.$inputField.append(this.container),this.el.setAttribute("data-target",this.container.id),this.dropdown=M.Dropdown.init(this.el,{autoFocus:!1,closeOnClick:!1,coverTrigger:!1}),this.el.removeEventListener("click",this.dropdown._handleClickBound)}},{key:"_removeDropdown",value:function(){this.container.parentNode.removeChild(this.container)}},{key:"_handleInputBlur",value:function(){this.dropdown.close(),this._resetAutocomplete()}},{key:"_handleInputKeyupAndFocus",value:function(t){var e=this;"keyup"===t.type&&(n._keydown=!1),this.count=0;var i=this.el.value.toLowerCase();13!==t.keyCode&&38!==t.keyCode&&40!==t.keyCode&&(this.oldVal!==i&&(this._resetAutocomplete(),i.length>=this.options.minLength&&(this.isOpen=!0,this._renderDropdown(this.options.data,i)),this.dropdown.isOpen?this.dropdown.recalculateDimensions():setTimeout(function(){e.dropdown.open()},100)),this.oldVal=i)}},{key:"_handleInputKeydown",value:function(e){n._keydown=!0;var i=e.keyCode,s=void 0,o=t(this.container).children("li").length;13===i&&this.activeIndex>=0?(s=t(this.container).children("li").eq(this.activeIndex)).length&&(this.selectOption(s),e.preventDefault()):38!==i&&40!==i||(e.preventDefault(),38===i&&this.activeIndex>0&&this.activeIndex--,40===i&&this.activeIndex<o-1&&this.activeIndex++,this.$active.removeClass("active"),this.activeIndex>=0&&(this.$active=t(this.container).children("li").eq(this.activeIndex),this.$active.addClass("active")))}},{key:"_handleContainerMousedownAndTouchstart",value:function(e){var i=t(e.target).closest("li");this.selectOption(i)}},{key:"_highlight",value:function(t,e){var i=e.find("img"),n=e.text().toLowerCase().indexOf(""+t.toLowerCase()),s=n+t.length-1,o=e.text().slice(0,n),a=e.text().slice(n,s+1),r=e.text().slice(s+1);e.html("<span>"+o+"<span class='highlight'>"+a+"</span>"+r+"</span>"),i.length&&e.prepend(i)}},{key:"_resetCurrentElement",value:function(){this.activeIndex=-1,this.$active.removeClass("active")}},{key:"_resetAutocomplete",value:function(){t(this.container).empty(),this._resetCurrentElement(),this.oldVal=null,this.isOpen=!1}},{key:"selectOption",value:function(t){var e=t.text().trim();this.el.value=e,this.$el.trigger("change"),this._resetAutocomplete(),this.dropdown.close(),"function"==typeof this.options.onAutocomplete&&this.options.onAutocomplete.call(this,e)}},{key:"_renderDropdown",value:function(e,i){var n=this;this._resetAutocomplete();var s=[];for(var o in e)if(e.hasOwnProperty(o)&&-1!==o.toLowerCase().indexOf(i)){if(this.count>=this.options.limit)break;var a={data:e[o],key:o};s.push(a),this.count++}s.sort(function(t,e){return n.options.sortFunction(t.key.toLowerCase(),e.key.toLowerCase(),i.toLowerCase())});for(var r=0;r<s.length;r++){var l=s[r],h=t("<li></li>");l.data?h.append('<img src="'+l.data+'" class="right circle"><span>'+l.key+"</span>"):h.append("<span>"+l.key+"</span>"),t(this.container).append(h),this._highlight(i,h)}}},{key:"updateData",value:function(t){var e=this.el.value.toLowerCase();this.options.data=t,this.isOpen&&this._renderDropdown(t,e)}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Autocomplete}},{key:"defaults",get:function(){return e}}]),n}();i._keydown=!1,M.Autocomplete=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"autocomplete","M_Autocomplete")}(cash),function(t){M.updateTextFields=function(){t("input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea").each(function(e,i){var n=t(this);e.value.length>0||t(e).is(":focus")||e.autofocus||null!==n.attr("placeholder")?n.siblings("label").addClass("active"):e.validity?n.siblings("label").toggleClass("active",!0===e.validity.badInput):n.siblings("label").removeClass("active")})},M.validate_field=function(t){var e=null!==t.attr("data-length"),i=parseInt(t.attr("data-length")),n=t[0].value.length;0!==n||!1!==t[0].validity.badInput||t.is(":required")?t.hasClass("validate")&&(t.is(":valid")&&e&&n<=i||t.is(":valid")&&!e?(t.removeClass("invalid"),t.addClass("valid")):(t.removeClass("valid"),t.addClass("invalid"))):t.hasClass("validate")&&(t.removeClass("valid"),t.removeClass("invalid"))},M.textareaAutoResize=function(e){if(e instanceof Element&&(e=t(e)),e.length){var i=t(".hiddendiv").first();i.length||(i=t('<div class="hiddendiv common"></div>'),t("body").append(i));var n=e.css("font-family"),s=e.css("font-size"),o=e.css("line-height"),a=e.css("padding-top"),r=e.css("padding-right"),l=e.css("padding-bottom"),h=e.css("padding-left");s&&i.css("font-size",s),n&&i.css("font-family",n),o&&i.css("line-height",o),a&&i.css("padding-top",a),r&&i.css("padding-right",r),l&&i.css("padding-bottom",l),h&&i.css("padding-left",h),e.data("original-height")||e.data("original-height",e.height()),"off"===e.attr("wrap")&&i.css("overflow-wrap","normal").css("white-space","pre"),i.text(e[0].value+"\n");var d=i.html().replace(/\n/g,"<br>");i.html(d),e[0].offsetWidth>0&&e[0].offsetHeight>0?i.css("width",e.width()+"px"):i.css("width",window.innerWidth/2+"px"),e.data("original-height")<=i.innerHeight()?e.css("height",i.innerHeight()+"px"):e[0].value.length<e.data("previous-length")&&e.css("height",e.data("original-height")+"px"),e.data("previous-length",e[0].value.length)}else console.error("No textarea element found")},t(document).ready(function(){var e="input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea";t(document).on("change",e,function(){0===this.value.length&&null===t(this).attr("placeholder")||t(this).siblings("label").addClass("active"),M.validate_field(t(this))}),t(document).ready(function(){M.updateTextFields()}),t(document).on("reset",function(i){var n=t(i.target);n.is("form")&&(n.find(e).removeClass("valid").removeClass("invalid"),n.find(e).each(function(e){this.value.length&&t(this).siblings("label").removeClass("active")}),setTimeout(function(){n.find("select").each(function(){if(this.M_FormSelect){var e=t(this).find("option[selected]").text();t(this).siblings("input.select-dropdown")[0].value=e}})},0))}),document.addEventListener("focus",function(i){t(i.target).is(e)&&t(i.target).siblings("label, .prefix").addClass("active")},!0),document.addEventListener("blur",function(i){var n=t(i.target);if(n.is(e)){var s=".prefix";0===n[0].value.length&&!0!==n[0].validity.badInput&&null===n.attr("placeholder")&&(s+=", label"),n.siblings(s).removeClass("active"),M.validate_field(n)}},!0);t(document).on("keyup","input[type=radio], input[type=checkbox]",function(e){if(e.which===M.keys.TAB)return t(this).addClass("tabbed"),void t(this).one("blur",function(e){t(this).removeClass("tabbed")})});t(".materialize-textarea").each(function(){var e=t(this);e.data("original-height",e.height()),e.data("previous-length",this.value.length),M.textareaAutoResize(e)}),t(document).on("keyup",".materialize-textarea",function(){M.textareaAutoResize(t(this))}),t(document).on("keydown",".materialize-textarea",function(){M.textareaAutoResize(t(this))}),t(document).on("change",'.file-field input[type="file"]',function(){for(var e=t(this).closest(".file-field").find("input.file-path"),i=t(this)[0].files,n=[],s=0;s<i.length;s++)n.push(i[s].name);e[0].value=n.join(", "),e.trigger("change")})})}(cash),function(t,e){"use strict";var i={indicators:!0,height:400,duration:500,interval:6e3},n=function(n){function s(i,n){_classCallCheck(this,s);var o=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,i,n));return o.el.M_Slider=o,o.options=t.extend({},s.defaults,n),o.$slider=o.$el.find(".slides"),o.$slides=o.$slider.children("li"),o.activeIndex=o.$slides.filter(function(e){return t(e).hasClass("active")}).first().index(),-1!=o.activeIndex&&(o.$active=o.$slides.eq(o.activeIndex)),o._setSliderHeight(),o.$slides.find(".caption").each(function(t){o._animateCaptionIn(t,0)}),o.$slides.find("img").each(function(e){var i="data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";t(e).attr("src")!==i&&(t(e).css("background-image",'url("'+t(e).attr("src")+'")'),t(e).attr("src",i))}),o._setupIndicators(),o.$active?o.$active.css("display","block"):(o.$slides.first().addClass("active"),e({targets:o.$slides.first()[0],opacity:1,duration:o.options.duration,easing:"easeOutQuad"}),o.activeIndex=0,o.$active=o.$slides.eq(o.activeIndex),o.options.indicators&&o.$indicators.eq(o.activeIndex).addClass("active")),o.$active.find("img").each(function(t){e({targets:o.$active.find(".caption")[0],opacity:1,translateX:0,translateY:0,duration:o.options.duration,easing:"easeOutQuad"})}),o._setupEventHandlers(),o.start(),o}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this.pause(),this._removeIndicators(),this._removeEventHandlers(),this.el.M_Slider=void 0}},{key:"_setupEventHandlers",value:function(){var t=this;this._handleIntervalBound=this._handleInterval.bind(this),this._handleIndicatorClickBound=this._handleIndicatorClick.bind(this),this.options.indicators&&this.$indicators.each(function(e){e.addEventListener("click",t._handleIndicatorClickBound)})}},{key:"_removeEventHandlers",value:function(){var t=this;this.options.indicators&&this.$indicators.each(function(e){e.removeEventListener("click",t._handleIndicatorClickBound)})}},{key:"_handleIndicatorClick",value:function(e){var i=t(e.target).index();this.set(i)}},{key:"_handleInterval",value:function(){var t=this.$slider.find(".active").index();this.$slides.length===t+1?t=0:t+=1,this.set(t)}},{key:"_animateCaptionIn",value:function(i,n){var s={targets:i,opacity:0,duration:n,easing:"easeOutQuad"};t(i).hasClass("center-align")?s.translateY=-100:t(i).hasClass("right-align")?s.translateX=100:t(i).hasClass("left-align")&&(s.translateX=-100),e(s)}},{key:"_setSliderHeight",value:function(){this.$el.hasClass("fullscreen")||(this.options.indicators?this.$el.css("height",this.options.height+40+"px"):this.$el.css("height",this.options.height+"px"),this.$slider.css("height",this.options.height+"px"))}},{key:"_setupIndicators",value:function(){var e=this;this.options.indicators&&(this.$indicators=t('<ul class="indicators"></ul>'),this.$slides.each(function(i,n){var s=t('<li class="indicator-item"></li>');e.$indicators.append(s[0])}),this.$el.append(this.$indicators[0]),this.$indicators=this.$indicators.children("li.indicator-item"))}},{key:"_removeIndicators",value:function(){this.$el.find("ul.indicators").remove()}},{key:"set",value:function(t){var i=this;if(t>=this.$slides.length?t=0:t<0&&(t=this.$slides.length-1),this.activeIndex!=t){this.$active=this.$slides.eq(this.activeIndex);var n=this.$active.find(".caption");this.$active.removeClass("active"),e({targets:this.$active[0],opacity:0,duration:this.options.duration,easing:"easeOutQuad",complete:function(){i.$slides.not(".active").each(function(t){e({targets:t,opacity:0,translateX:0,translateY:0,duration:0,easing:"easeOutQuad"})})}}),this._animateCaptionIn(n[0],this.options.duration),this.options.indicators&&(this.$indicators.eq(this.activeIndex).removeClass("active"),this.$indicators.eq(t).addClass("active")),e({targets:this.$slides.eq(t)[0],opacity:1,duration:this.options.duration,easing:"easeOutQuad"}),e({targets:this.$slides.eq(t).find(".caption")[0],opacity:1,translateX:0,translateY:0,duration:this.options.duration,delay:this.options.duration,easing:"easeOutQuad"}),this.$slides.eq(t).addClass("active"),this.activeIndex=t,this.start()}}},{key:"pause",value:function(){clearInterval(this.interval)}},{key:"start",value:function(){clearInterval(this.interval),this.interval=setInterval(this._handleIntervalBound,this.options.duration+this.options.interval)}},{key:"next",value:function(){var t=this.activeIndex+1;t>=this.$slides.length?t=0:t<0&&(t=this.$slides.length-1),this.set(t)}},{key:"prev",value:function(){var t=this.activeIndex-1;t>=this.$slides.length?t=0:t<0&&(t=this.$slides.length-1),this.set(t)}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Slider}},{key:"defaults",get:function(){return i}}]),s}();M.Slider=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"slider","M_Slider")}(cash,M.anime),function(t,e){t(document).on("click",".card",function(i){if(t(this).children(".card-reveal").length){var n=t(i.target).closest(".card");void 0===n.data("initialOverflow")&&n.data("initialOverflow",void 0===n.css("overflow")?"":n.css("overflow"));var s=t(this).find(".card-reveal");t(i.target).is(t(".card-reveal .card-title"))||t(i.target).is(t(".card-reveal .card-title i"))?e({targets:s[0],translateY:0,duration:225,easing:"easeInOutQuad",complete:function(e){var i=e.animatables[0].target;t(i).css({display:"none"}),n.css("overflow",n.data("initialOverflow"))}}):(t(i.target).is(t(".card .activator"))||t(i.target).is(t(".card .activator i")))&&(n.css("overflow","hidden"),s.css({display:"block"}),e({targets:s[0],translateY:"-100%",duration:300,easing:"easeInOutQuad"}))}})}(cash,M.anime),function(t){"use strict";var e={data:[],placeholder:"",secondaryPlaceholder:"",autocompleteOptions:{},limit:1/0,onChipAdd:null,onChipSelect:null,onChipDelete:null},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_Chips=s,s.options=t.extend({},n.defaults,i),s.$el.addClass("chips input-field"),s.chipsData=[],s.$chips=t(),s._setupInput(),s.hasAutocomplete=Object.keys(s.options.autocompleteOptions).length>0,s.$input.attr("id")||s.$input.attr("id",M.guid()),s.options.data.length&&(s.chipsData=s.options.data,s._renderChips(s.chipsData)),s.hasAutocomplete&&s._setupAutocomplete(),s._setPlaceholder(),s._setupLabel(),s._setupEventHandlers(),s}return _inherits(n,Component),_createClass(n,[{key:"getData",value:function(){return this.chipsData}},{key:"destroy",value:function(){this._removeEventHandlers(),this.$chips.remove(),this.el.M_Chips=void 0}},{key:"_setupEventHandlers",value:function(){this._handleChipClickBound=this._handleChipClick.bind(this),this._handleInputKeydownBound=this._handleInputKeydown.bind(this),this._handleInputFocusBound=this._handleInputFocus.bind(this),this._handleInputBlurBound=this._handleInputBlur.bind(this),this.el.addEventListener("click",this._handleChipClickBound),document.addEventListener("keydown",n._handleChipsKeydown),document.addEventListener("keyup",n._handleChipsKeyup),this.el.addEventListener("blur",n._handleChipsBlur,!0),this.$input[0].addEventListener("focus",this._handleInputFocusBound),this.$input[0].addEventListener("blur",this._handleInputBlurBound),this.$input[0].addEventListener("keydown",this._handleInputKeydownBound)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("click",this._handleChipClickBound),document.removeEventListener("keydown",n._handleChipsKeydown),document.removeEventListener("keyup",n._handleChipsKeyup),this.el.removeEventListener("blur",n._handleChipsBlur,!0),this.$input[0].removeEventListener("focus",this._handleInputFocusBound),this.$input[0].removeEventListener("blur",this._handleInputBlurBound),this.$input[0].removeEventListener("keydown",this._handleInputKeydownBound)}},{key:"_handleChipClick",value:function(e){var i=t(e.target).closest(".chip"),n=t(e.target).is(".close");if(i.length){var s=i.index();n?(this.deleteChip(s),this.$input[0].focus()):this.selectChip(s)}else this.$input[0].focus()}},{key:"_handleInputFocus",value:function(){this.$el.addClass("focus")}},{key:"_handleInputBlur",value:function(){this.$el.removeClass("focus")}},{key:"_handleInputKeydown",value:function(t){if(n._keydown=!0,13===t.keyCode){if(this.hasAutocomplete&&this.autocomplete&&this.autocomplete.isOpen)return;t.preventDefault(),this.addChip({tag:this.$input[0].value}),this.$input[0].value=""}else 8!==t.keyCode&&37!==t.keyCode||""!==this.$input[0].value||!this.chipsData.length||(t.preventDefault(),this.selectChip(this.chipsData.length-1))}},{key:"_renderChip",value:function(e){if(e.tag){var i=document.createElement("div"),n=document.createElement("i");if(i.classList.add("chip"),i.textContent=e.tag,i.setAttribute("tabindex",0),t(n).addClass("material-icons close"),n.textContent="close",e.image){var s=document.createElement("img");s.setAttribute("src",e.image),i.insertBefore(s,i.firstChild)}return i.appendChild(n),i}}},{key:"_renderChips",value:function(){this.$chips.remove();for(var t=0;t<this.chipsData.length;t++){var e=this._renderChip(this.chipsData[t]);this.$el.append(e),this.$chips.add(e)}this.$el.append(this.$input[0])}},{key:"_setupAutocomplete",value:function(){var t=this;this.options.autocompleteOptions.onAutocomplete=function(e){t.addChip({tag:e}),t.$input[0].value="",t.$input[0].focus()},this.autocomplete=M.Autocomplete.init(this.$input[0],this.options.autocompleteOptions)}},{key:"_setupInput",value:function(){this.$input=this.$el.find("input"),this.$input.length||(this.$input=t("<input></input>"),this.$el.append(this.$input)),this.$input.addClass("input")}},{key:"_setupLabel",value:function(){this.$label=this.$el.find("label"),this.$label.length&&this.$label.setAttribute("for",this.$input.attr("id"))}},{key:"_setPlaceholder",value:function(){void 0!==this.chipsData&&!this.chipsData.length&&this.options.placeholder?t(this.$input).prop("placeholder",this.options.placeholder):(void 0===this.chipsData||this.chipsData.length)&&this.options.secondaryPlaceholder&&t(this.$input).prop("placeholder",this.options.secondaryPlaceholder)}},{key:"_isValid",value:function(t){if(t.hasOwnProperty("tag")&&""!==t.tag){for(var e=!1,i=0;i<this.chipsData.length;i++)if(this.chipsData[i].tag===t.tag){e=!0;break}return!e}return!1}},{key:"addChip",value:function(e){if(this._isValid(e)&&!(this.chipsData.length>=this.options.limit)){var i=this._renderChip(e);this.$chips.add(i),this.chipsData.push(e),t(this.$input).before(i),this._setPlaceholder(),"function"==typeof this.options.onChipAdd&&this.options.onChipAdd.call(this,this.$el,i)}}},{key:"deleteChip",value:function(e){var i=this.$chips.eq(e);this.$chips.eq(e).remove(),this.$chips=this.$chips.filter(function(e){return t(e).index()>=0}),this.chipsData.splice(e,1),this._setPlaceholder(),"function"==typeof this.options.onChipDelete&&this.options.onChipDelete.call(this,this.$el,i[0])}},{key:"selectChip",value:function(t){var e=this.$chips.eq(t);this._selectedChip=e,e[0].focus(),"function"==typeof this.options.onChipSelect&&this.options.onChipSelect.call(this,this.$el,e[0])}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Chips}},{key:"_handleChipsKeydown",value:function(e){n._keydown=!0;var i=t(e.target).closest(".chips"),s=e.target&&i.length;if(!t(e.target).is("input, textarea")&&s){var o=i[0].M_Chips;if(8===e.keyCode||46===e.keyCode){e.preventDefault();var a=o.chipsData.length;if(o._selectedChip){var r=o._selectedChip.index();o.deleteChip(r),o._selectedChip=null,a=Math.max(r-1,0)}o.chipsData.length&&o.selectChip(a)}else if(37===e.keyCode){if(o._selectedChip){var l=o._selectedChip.index()-1;if(l<0)return;o.selectChip(l)}}else if(39===e.keyCode&&o._selectedChip){var h=o._selectedChip.index()+1;h>=o.chipsData.length?o.$input[0].focus():o.selectChip(h)}}}},{key:"_handleChipsKeyup",value:function(t){n._keydown=!1}},{key:"_handleChipsBlur",value:function(e){n._keydown||(t(e.target).closest(".chips")[0].M_Chips._selectedChip=null)}},{key:"defaults",get:function(){return e}}]),n}();i._keydown=!1,M.Chips=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"chips","M_Chips"),t(document).ready(function(){t(document.body).on("click",".chip .close",function(){var e=t(this).closest(".chips");e.length&&e[0].M_Chips||t(this).closest(".chip").remove()})})}(cash),function(t){"use strict";var e={top:0,bottom:1/0,offset:0,onPositionChange:null},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_Pushpin=s,s.options=t.extend({},n.defaults,i),s.originalOffset=s.el.offsetTop,n._pushpins.push(s),s._setupEventHandlers(),s._updatePosition(),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this.el.style.top=null,this._removePinClasses(),this._removeEventHandlers();var t=n._pushpins.indexOf(this);n._pushpins.splice(t,1)}},{key:"_setupEventHandlers",value:function(){document.addEventListener("scroll",n._updateElements)}},{key:"_removeEventHandlers",value:function(){document.removeEventListener("scroll",n._updateElements)}},{key:"_updatePosition",value:function(){var t=M.getDocumentScrollTop()+this.options.offset;this.options.top<=t&&this.options.bottom>=t&&!this.el.classList.contains("pinned")&&(this._removePinClasses(),this.el.style.top=this.options.offset+"px",this.el.classList.add("pinned"),"function"==typeof this.options.onPositionChange&&this.options.onPositionChange.call(this,"pinned")),t<this.options.top&&!this.el.classList.contains("pin-top")&&(this._removePinClasses(),this.el.style.top=0,this.el.classList.add("pin-top"),"function"==typeof this.options.onPositionChange&&this.options.onPositionChange.call(this,"pin-top")),t>this.options.bottom&&!this.el.classList.contains("pin-bottom")&&(this._removePinClasses(),this.el.classList.add("pin-bottom"),this.el.style.top=this.options.bottom-this.originalOffset+"px","function"==typeof this.options.onPositionChange&&this.options.onPositionChange.call(this,"pin-bottom"))}},{key:"_removePinClasses",value:function(){this.el.classList.remove("pin-top","pinned","pin-bottom")}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Pushpin}},{key:"_updateElements",value:function(){for(var t in n._pushpins)n._pushpins[t]._updatePosition()}},{key:"defaults",get:function(){return e}}]),n}();i._pushpins=[],M.Pushpin=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"pushpin","M_Pushpin")}(cash),function(t,e){"use strict";var i={direction:"top",hoverEnabled:!0,toolbarEnabled:!1};t.fn.reverse=[].reverse;var n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_FloatingActionButton=n,n.options=t.extend({},s.defaults,i),n.isOpen=!1,n.$anchor=n.$el.children("a").first(),n.$menu=n.$el.children("ul").first(),n.$floatingBtns=n.$el.find("ul .btn-floating"),n.$floatingBtnsReverse=n.$el.find("ul .btn-floating").reverse(),n.offsetY=0,n.offsetX=0,"top"===n.options.direction?(n.$el.addClass("direction-top"),n.offsetY=40):"right"===n.options.direction?(n.$el.addClass("direction-right"),n.offsetX=-40):"bottom"===n.options.direction?(n.$el.addClass("direction-bottom"),n.offsetY=-40):(n.$el.addClass("direction-left"),n.offsetX=40),n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._removeEventHandlers(),this.el.M_FloatingActionButton=void 0}},{key:"_setupEventHandlers",value:function(){this._handleFABClickBound=this._handleFABClick.bind(this),this._handleOpenBound=this.open.bind(this),this._handleCloseBound=this.close.bind(this),this.options.hoverEnabled&&!this.options.toolbarEnabled?(this.el.addEventListener("mouseenter",this._handleOpenBound),this.el.addEventListener("mouseleave",this._handleCloseBound)):this.el.addEventListener("click",this._handleFABClickBound)}},{key:"_removeEventHandlers",value:function(){this.options.hoverEnabled&&!this.options.toolbarEnabled?(this.el.removeEventListener("mouseenter",this._handleOpenBound),this.el.removeEventListener("mouseleave",this._handleCloseBound)):this.el.removeEventListener("click",this._handleFABClickBound)}},{key:"_handleFABClick",value:function(){this.isOpen?this.close():this.open()}},{key:"_handleDocumentClick",value:function(e){t(e.target).closest(this.$menu).length||this.close()}},{key:"open",value:function(){this.isOpen||(this.options.toolbarEnabled?this._animateInToolbar():this._animateInFAB(),this.isOpen=!0)}},{key:"close",value:function(){this.isOpen&&(this.options.toolbarEnabled?(window.removeEventListener("scroll",this._handleCloseBound,!0),document.body.removeEventListener("click",this._handleDocumentClickBound,!0),this._animateOutToolbar()):this._animateOutFAB(),this.isOpen=!1)}},{key:"_animateInFAB",value:function(){var t=this;this.$el.addClass("active");var i=0;this.$floatingBtnsReverse.each(function(n){e({targets:n,opacity:1,scale:[.4,1],translateY:[t.offsetY,0],translateX:[t.offsetX,0],duration:275,delay:i,easing:"easeInOutQuad"}),i+=40})}},{key:"_animateOutFAB",value:function(){var t=this;this.$floatingBtnsReverse.each(function(i){e.remove(i),e({targets:i,opacity:0,scale:.4,translateY:t.offsetY,translateX:t.offsetX,duration:175,easing:"easeOutQuad",complete:function(){t.$el.removeClass("active")}})})}},{key:"_animateInToolbar",value:function(){var e=this,i=void 0,n=window.innerWidth,s=window.innerHeight,o=this.el.getBoundingClientRect(),a=t('<div class="fab-backdrop"></div>'),r=this.$anchor.css("background-color");this.$anchor.append(a),this.offsetX=o.left-n/2+o.width/2,this.offsetY=s-o.bottom,i=n/a[0].clientWidth,this.btnBottom=o.bottom,this.btnLeft=o.left,this.btnWidth=o.width,this.$el.addClass("active"),this.$el.css({"text-align":"center",width:"100%",bottom:0,left:0,transform:"translateX("+this.offsetX+"px)",transition:"none"}),this.$anchor.css({transform:"translateY("+-this.offsetY+"px)",transition:"none"}),a.css({"background-color":r}),setTimeout(function(){e.$el.css({transform:"",transition:"transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s"}),e.$anchor.css({overflow:"visible",transform:"",transition:"transform .2s"}),setTimeout(function(){e.$el.css({overflow:"hidden","background-color":r}),a.css({transform:"scale("+i+")",transition:"transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)"}),e.$menu.children("li").children("a").css({opacity:1}),e._handleDocumentClickBound=e._handleDocumentClick.bind(e),window.addEventListener("scroll",e._handleCloseBound,!0),document.body.addEventListener("click",e._handleDocumentClickBound,!0)},100)},0)}},{key:"_animateOutToolbar",value:function(){var t=this,e=window.innerWidth,i=window.innerHeight,n=this.$el.find(".fab-backdrop"),s=this.$anchor.css("background-color");this.offsetX=this.btnLeft-e/2+this.btnWidth/2,this.offsetY=i-this.btnBottom,this.$el.removeClass("active"),this.$el.css({"background-color":"transparent",transition:"none"}),this.$anchor.css({transition:"none"}),n.css({transform:"scale(0)","background-color":s}),this.$menu.children("li").children("a").css({opacity:""}),setTimeout(function(){n.remove(),t.$el.css({"text-align":"",width:"",bottom:"",left:"",overflow:"","background-color":"",transform:"translate3d("+-t.offsetX+"px,0,0)"}),t.$anchor.css({overflow:"",transform:"translate3d(0,"+t.offsetY+"px,0)"}),setTimeout(function(){t.$el.css({transform:"translate3d(0,0,0)",transition:"transform .2s"}),t.$anchor.css({transform:"translate3d(0,0,0)",transition:"transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)"})},20)},200)}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_FloatingActionButton}},{key:"defaults",get:function(){return i}}]),s}();M.FloatingActionButton=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"floatingActionButton","M_FloatingActionButton")}(cash,M.anime),function(t){"use strict";var e={format:"mmm dd, yyyy",parse:null,defaultDate:null,setDefaultDate:!1,disableWeekends:!1,disableDayFn:null,firstDay:0,minDate:null,maxDate:null,yearRange:10,minYear:0,maxYear:9999,minMonth:void 0,maxMonth:void 0,startRange:null,endRange:null,isRTL:!1,showMonthAfterYear:!1,showDaysInNextAndPreviousMonths:!1,container:null,showClearBtn:!1,i18n:{cancel:"Cancel",clear:"Clear",done:"Ok",previousMonth:"â€¹",nextMonth:"â€º",months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],weekdays:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],weekdaysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],weekdaysAbbrev:["S","M","T","W","T","F","S"]},events:[],onSelect:null,onOpen:null,onClose:null,onDraw:null},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));s.el.M_Datepicker=s,s.options=t.extend({},n.defaults,i),i&&i.hasOwnProperty("i18n")&&"object"==typeof i.i18n&&(s.options.i18n=t.extend({},n.defaults.i18n,i.i18n)),s.options.minDate&&s.options.minDate.setHours(0,0,0,0),s.options.maxDate&&s.options.maxDate.setHours(0,0,0,0),s.id=M.guid(),s._setupVariables(),s._insertHTMLIntoDOM(),s._setupModal(),s._setupEventHandlers(),s.options.defaultDate||(s.options.defaultDate=new Date(Date.parse(s.el.value)),s.options.setDefaultDate=!0);var o=s.options.defaultDate;return n._isDate(o)?s.options.setDefaultDate?s.setDate(o,!0):s.gotoDate(o):s.gotoDate(new Date),s.isOpen=!1,s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this.modal.destroy(),t(this.modalEl).remove(),this.destroySelects(),this.el.M_Datepicker=void 0}},{key:"destroySelects",value:function(){var t=this.calendarEl.querySelector(".pika-select-year");t&&M.FormSelect.getInstance(t).destroy();var e=this.calendarEl.querySelector(".pika-select-month");e&&M.FormSelect.getInstance(e).destroy()}},{key:"_insertHTMLIntoDOM",value:function(){this.options.showClearBtn&&(t(this.clearBtn).css({visibility:""}),this.clearBtn.innerHTML=this.options.i18n.clear),this.doneBtn.innerHTML=this.options.i18n.done,this.cancelBtn.innerHTML=this.options.i18n.cancel,this.options.container?this.$modalEl.appendTo(this.options.container):this.$modalEl.insertBefore(this.el)}},{key:"_setupModal",value:function(){var t=this;this.modalEl.id="modal-"+this.id,this.modal=M.Modal.init(this.modalEl,{onCloseEnd:function(){t.isOpen=!1}})}},{key:"toString",value:function(t){var e=this;return t=t||this.options.format,n._isDate(this.date)?t.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g).map(function(t){return e.formats[t]?e.formats[t]():t}).join(""):""}},{key:"setDate",value:function(t,e){if(!t)return this.date=null,this._renderDateDisplay(),this.draw();if("string"==typeof t&&(t=new Date(Date.parse(t))),n._isDate(t)){var i=this.options.minDate,s=this.options.maxDate;n._isDate(i)&&t<i?t=i:n._isDate(s)&&t>s&&(t=s),this.date=new Date(t.getTime()),this._renderDateDisplay(),n._setToStartOfDay(this.date),this.gotoDate(this.date),e||"function"!=typeof this.options.onSelect||this.options.onSelect.call(this,this.date)}}},{key:"setInputValue",value:function(){this.el.value=this.toString(),this.$el.trigger("change",{firedBy:this})}},{key:"_renderDateDisplay",value:function(){var t=n._isDate(this.date)?this.date:new Date,e=this.options.i18n,i=e.weekdaysShort[t.getDay()],s=e.monthsShort[t.getMonth()],o=t.getDate();this.yearTextEl.innerHTML=t.getFullYear(),this.dateTextEl.innerHTML=i+", "+s+" "+o}},{key:"gotoDate",value:function(t){var e=!0;if(n._isDate(t)){if(this.calendars){var i=new Date(this.calendars[0].year,this.calendars[0].month,1),s=new Date(this.calendars[this.calendars.length-1].year,this.calendars[this.calendars.length-1].month,1),o=t.getTime();s.setMonth(s.getMonth()+1),s.setDate(s.getDate()-1),e=o<i.getTime()||s.getTime()<o}e&&(this.calendars=[{month:t.getMonth(),year:t.getFullYear()}]),this.adjustCalendars()}}},{key:"adjustCalendars",value:function(){this.calendars[0]=this.adjustCalendar(this.calendars[0]),this.draw()}},{key:"adjustCalendar",value:function(t){return t.month<0&&(t.year-=Math.ceil(Math.abs(t.month)/12),t.month+=12),t.month>11&&(t.year+=Math.floor(Math.abs(t.month)/12),t.month-=12),t}},{key:"nextMonth",value:function(){this.calendars[0].month++,this.adjustCalendars()}},{key:"prevMonth",value:function(){this.calendars[0].month--,this.adjustCalendars()}},{key:"render",value:function(t,e,i){var s=this.options,o=new Date,a=n._getDaysInMonth(t,e),r=new Date(t,e,1).getDay(),l=[],h=[];n._setToStartOfDay(o),s.firstDay>0&&(r-=s.firstDay)<0&&(r+=7);for(var d=0===e?11:e-1,u=11===e?0:e+1,c=0===e?t-1:t,p=11===e?t+1:t,v=n._getDaysInMonth(c,d),f=a+r,m=f;m>7;)m-=7;f+=7-m;for(var g=!1,_=0,y=0;_<f;_++){var k=new Date(t,e,_-r+1),b=!!n._isDate(this.date)&&n._compareDates(k,this.date),w=n._compareDates(k,o),C=-1!==s.events.indexOf(k.toDateString()),E=_<r||_>=a+r,M=_-r+1,x=e,O=t,T=s.startRange&&n._compareDates(s.startRange,k),L=s.endRange&&n._compareDates(s.endRange,k),$=s.startRange&&s.endRange&&s.startRange<k&&k<s.endRange,B=s.minDate&&k<s.minDate||s.maxDate&&k>s.maxDate||s.disableWeekends&&n._isWeekend(k)||s.disableDayFn&&s.disableDayFn(k);E&&(_<r?(M=v+M,x=d,O=c):(M-=a,x=u,O=p));var D={day:M,month:x,year:O,hasEvent:C,isSelected:b,isToday:w,isDisabled:B,isEmpty:E,isStartRange:T,isEndRange:L,isInRange:$,showDaysInNextAndPreviousMonths:s.showDaysInNextAndPreviousMonths};h.push(this.renderDay(D)),7==++y&&(l.push(this.renderRow(h,s.isRTL,g)),h=[],y=0,g=!1)}return this.renderTable(s,l,i)}},{key:"renderDay",value:function(t){var e=[],i="false";if(t.isEmpty){if(!t.showDaysInNextAndPreviousMonths)return'<td class="is-empty"></td>';e.push("is-outside-current-month"),e.push("is-selection-disabled")}return t.isDisabled&&e.push("is-disabled"),t.isToday&&e.push("is-today"),t.isSelected&&(e.push("is-selected"),i="true"),t.hasEvent&&e.push("has-event"),t.isInRange&&e.push("is-inrange"),t.isStartRange&&e.push("is-startrange"),t.isEndRange&&e.push("is-endrange"),'<td data-day="'+t.day+'" class="'+e.join(" ")+'" aria-selected="'+i+'"><button class="datepicker-day-button" type="button" data-pika-year="'+t.year+'" data-pika-month="'+t.month+'" data-pika-day="'+t.day+'">'+t.day+"</button></td>"}},{key:"renderRow",value:function(t,e,i){return'<tr class="pika-row'+(i?" is-selected":"")+'">'+(e?t.reverse():t).join("")+"</tr>"}},{key:"renderTable",value:function(t,e,i){return'<div class="datepicker-table-wrapper"><table cellpadding="0" cellspacing="0" class="datepicker-table" role="grid" aria-labelledby="'+i+'">'+this.renderHead(t)+this.renderBody(e)+"</table></div>"}},{key:"renderHead",value:function(t){var e=void 0,i=[];for(e=0;e<7;e++)i.push('<th scope="col"><abbr title="'+this.renderDayName(t,e)+'">'+this.renderDayName(t,e,!0)+"</abbr></th>");return"<thead><tr>"+(t.isRTL?i.reverse():i).join("")+"</tr></thead>"}},{key:"renderBody",value:function(t){return"<tbody>"+t.join("")+"</tbody>"}},{key:"renderTitle",value:function(e,i,n,s,o,a){var r=void 0,l=void 0,h=void 0,d=this.options,u=n===d.minYear,c=n===d.maxYear,p='<div id="'+a+'" class="datepicker-controls" role="heading" aria-live="assertive">',v=void 0,f=void 0,m=!0,g=!0;for(h=[],r=0;r<12;r++)h.push('<option value="'+(n===o?r-i:12+r-i)+'"'+(r===s?' selected="selected"':"")+(u&&r<d.minMonth||c&&r>d.maxMonth?'disabled="disabled"':"")+">"+d.i18n.months[r]+"</option>");for(v='<select class="pika-select pika-select-month" tabindex="-1">'+h.join("")+"</select>",t.isArray(d.yearRange)?(r=d.yearRange[0],l=d.yearRange[1]+1):(r=n-d.yearRange,l=1+n+d.yearRange),h=[];r<l&&r<=d.maxYear;r++)r>=d.minYear&&h.push('<option value="'+r+'"'+(r===n?' selected="selected"':"")+">"+r+"</option>");f='<select class="pika-select pika-select-year" tabindex="-1">'+h.join("")+"</select>";p+='<button class="month-prev'+(m?"":" is-disabled")+'" type="button"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"/><path d="M0-.5h24v24H0z" fill="none"/></svg></button>',p+='<div class="selects-container">',d.showMonthAfterYear?p+=f+v:p+=v+f,p+="</div>",u&&(0===s||d.minMonth>=s)&&(m=!1),c&&(11===s||d.maxMonth<=s)&&(g=!1);return p+='<button class="month-next'+(g?"":" is-disabled")+'" type="button"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"/><path d="M0-.25h24v24H0z" fill="none"/></svg></button>',p+="</div>"}},{key:"draw",value:function(t){if(this.isOpen||t){var e=this.options,i=e.minYear,n=e.maxYear,s=e.minMonth,o=e.maxMonth,a="",r=void 0;this._y<=i&&(this._y=i,!isNaN(s)&&this._m<s&&(this._m=s)),this._y>=n&&(this._y=n,!isNaN(o)&&this._m>o&&(this._m=o)),r="pika-title-"+Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,2);for(var l=0;l<1;l++)this._renderDateDisplay(),a+=this.renderTitle(this,l,this.calendars[l].year,this.calendars[l].month,this.calendars[0].year,r)+this.render(this.calendars[l].year,this.calendars[l].month,r);this.destroySelects(),this.calendarEl.innerHTML=a;var h=this.calendarEl.querySelector(".pika-select-year"),d=this.calendarEl.querySelector(".pika-select-month");M.FormSelect.init(h,{classes:"select-year",dropdownOptions:{container:document.body,constrainWidth:!1}}),M.FormSelect.init(d,{classes:"select-month",dropdownOptions:{container:document.body,constrainWidth:!1}}),h.addEventListener("change",this._handleYearChange.bind(this)),d.addEventListener("change",this._handleMonthChange.bind(this)),"function"==typeof this.options.onDraw&&this.options.onDraw(this)}}},{key:"_setupEventHandlers",value:function(){this._handleInputKeydownBound=this._handleInputKeydown.bind(this),this._handleInputClickBound=this._handleInputClick.bind(this),this._handleInputChangeBound=this._handleInputChange.bind(this),this._handleCalendarClickBound=this._handleCalendarClick.bind(this),this._finishSelectionBound=this._finishSelection.bind(this),this._handleMonthChange=this._handleMonthChange.bind(this),this._closeBound=this.close.bind(this),this.el.addEventListener("click",this._handleInputClickBound),this.el.addEventListener("keydown",this._handleInputKeydownBound),this.el.addEventListener("change",this._handleInputChangeBound),this.calendarEl.addEventListener("click",this._handleCalendarClickBound),this.doneBtn.addEventListener("click",this._finishSelectionBound),this.cancelBtn.addEventListener("click",this._closeBound),this.options.showClearBtn&&(this._handleClearClickBound=this._handleClearClick.bind(this),this.clearBtn.addEventListener("click",this._handleClearClickBound))}},{key:"_setupVariables",value:function(){var e=this;this.$modalEl=t(n._template),this.modalEl=this.$modalEl[0],this.calendarEl=this.modalEl.querySelector(".pika-single"),this.yearTextEl=this.modalEl.querySelector(".year-text"),this.dateTextEl=this.modalEl.querySelector(".date-text"),this.options.showClearBtn&&(this.clearBtn=this.modalEl.querySelector(".datepicker-clear")),this.doneBtn=this.modalEl.querySelector(".datepicker-done"),this.cancelBtn=this.modalEl.querySelector(".datepicker-cancel"),this.formats={d:function(){return e.date.getDate()},dd:function(){var t=e.date.getDate();return(t<10?"0":"")+t},ddd:function(){return e.options.i18n.weekdaysShort[e.date.getDay()]},dddd:function(){return e.options.i18n.weekdays[e.date.getDay()]},m:function(){return e.date.getMonth()+1},mm:function(){var t=e.date.getMonth()+1;return(t<10?"0":"")+t},mmm:function(){return e.options.i18n.monthsShort[e.date.getMonth()]},mmmm:function(){return e.options.i18n.months[e.date.getMonth()]},yy:function(){return(""+e.date.getFullYear()).slice(2)},yyyy:function(){return e.date.getFullYear()}}}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("click",this._handleInputClickBound),this.el.removeEventListener("keydown",this._handleInputKeydownBound),this.el.removeEventListener("change",this._handleInputChangeBound),this.calendarEl.removeEventListener("click",this._handleCalendarClickBound)}},{key:"_handleInputClick",value:function(){this.open()}},{key:"_handleInputKeydown",value:function(t){t.which===M.keys.ENTER&&(t.preventDefault(),this.open())}},{key:"_handleCalendarClick",value:function(e){if(this.isOpen){var i=t(e.target);i.hasClass("is-disabled")||(!i.hasClass("datepicker-day-button")||i.hasClass("is-empty")||i.parent().hasClass("is-disabled")?i.closest(".month-prev").length?this.prevMonth():i.closest(".month-next").length&&this.nextMonth():this.setDate(new Date(e.target.getAttribute("data-pika-year"),e.target.getAttribute("data-pika-month"),e.target.getAttribute("data-pika-day"))))}}},{key:"_handleClearClick",value:function(){this.date=null,this.setInputValue(),this.close()}},{key:"_handleMonthChange",value:function(t){this.gotoMonth(t.target.value)}},{key:"_handleYearChange",value:function(t){this.gotoYear(t.target.value)}},{key:"gotoMonth",value:function(t){isNaN(t)||(this.calendars[0].month=parseInt(t,10),this.adjustCalendars())}},{key:"gotoYear",value:function(t){isNaN(t)||(this.calendars[0].year=parseInt(t,10),this.adjustCalendars())}},{key:"_handleInputChange",value:function(t){var e=void 0;t.firedBy!==this&&(e=this.options.parse?this.options.parse(this.el.value,this.options.format):new Date(Date.parse(this.el.value)),n._isDate(e)&&this.setDate(e))}},{key:"renderDayName",value:function(t,e,i){for(e+=t.firstDay;e>=7;)e-=7;return i?t.i18n.weekdaysAbbrev[e]:t.i18n.weekdays[e]}},{key:"_finishSelection",value:function(){this.setInputValue(),this.close()}},{key:"open",value:function(){if(!this.isOpen)return this.isOpen=!0,"function"==typeof this.options.onOpen&&this.options.onOpen.call(this),this.draw(),this.modal.open(),this}},{key:"close",value:function(){if(this.isOpen)return this.isOpen=!1,"function"==typeof this.options.onClose&&this.options.onClose.call(this),this.modal.close(),this}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"_isDate",value:function(t){return/Date/.test(Object.prototype.toString.call(t))&&!isNaN(t.getTime())}},{key:"_isWeekend",value:function(t){var e=t.getDay();return 0===e||6===e}},{key:"_setToStartOfDay",value:function(t){n._isDate(t)&&t.setHours(0,0,0,0)}},{key:"_getDaysInMonth",value:function(t,e){return[31,n._isLeapYear(t)?29:28,31,30,31,30,31,31,30,31,30,31][e]}},{key:"_isLeapYear",value:function(t){return t%4==0&&t%100!=0||t%400==0}},{key:"_compareDates",value:function(t,e){return t.getTime()===e.getTime()}},{key:"_setToStartOfDay",value:function(t){n._isDate(t)&&t.setHours(0,0,0,0)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Datepicker}},{key:"defaults",get:function(){return e}}]),n}();i._template=['<div class= "modal datepicker-modal">','<div class="modal-content datepicker-container">','<div class="datepicker-date-display">','<span class="year-text"></span>','<span class="date-text"></span>',"</div>",'<div class="datepicker-calendar-container">','<div class="pika-single"></div>','<div class="datepicker-footer">','<button class="btn-flat datepicker-clear waves-effect" style="visibility: hidden;" type="button"></button>','<div class="confirmation-btns">','<button class="btn-flat datepicker-cancel waves-effect" type="button"></button>','<button class="btn-flat datepicker-done waves-effect" type="button"></button>',"</div>","</div>","</div>","</div>","</div>"].join(""),M.Datepicker=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"datepicker","M_Datepicker")}(cash),function(t){"use strict";var e={dialRadius:135,outerRadius:105,innerRadius:70,tickRadius:20,duration:350,container:null,defaultTime:"now",fromNow:0,showClearBtn:!1,i18n:{cancel:"Cancel",clear:"Clear",done:"Ok"},autoClose:!1,twelveHour:!0,vibrate:!0},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_Timepicker=s,s.options=t.extend({},n.defaults,i),s.id=M.guid(),s._insertHTMLIntoDOM(),s._setupModal(),s._setupVariables(),s._setupEventHandlers(),s._clockSetup(),s._pickerSetup(),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this.modal.destroy(),t(this.modalEl).remove(),this.el.M_Timepicker=void 0}},{key:"_setupEventHandlers",value:function(){this._handleInputKeydownBound=this._handleInputKeydown.bind(this),this._handleInputClickBound=this._handleInputClick.bind(this),this._handleClockClickStartBound=this._handleClockClickStart.bind(this),this._handleDocumentClickMoveBound=this._handleDocumentClickMove.bind(this),this._handleDocumentClickEndBound=this._handleDocumentClickEnd.bind(this),this.el.addEventListener("click",this._handleInputClickBound),this.el.addEventListener("keydown",this._handleInputKeydownBound),this.plate.addEventListener("mousedown",this._handleClockClickStartBound),this.plate.addEventListener("touchstart",this._handleClockClickStartBound),t(this.spanHours).on("click",this.showView.bind(this,"hours")),t(this.spanMinutes).on("click",this.showView.bind(this,"minutes"))}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("click",this._handleInputClickBound),this.el.removeEventListener("keydown",this._handleInputKeydownBound)}},{key:"_handleInputClick",value:function(){this.open()}},{key:"_handleInputKeydown",value:function(t){t.which===M.keys.ENTER&&(t.preventDefault(),this.open())}},{key:"_handleClockClickStart",value:function(t){t.preventDefault();var e=this.plate.getBoundingClientRect(),i={x:e.left,y:e.top};this.x0=i.x+this.options.dialRadius,this.y0=i.y+this.options.dialRadius,this.moved=!1;var s=n._Pos(t);this.dx=s.x-this.x0,this.dy=s.y-this.y0,this.setHand(this.dx,this.dy,!1),document.addEventListener("mousemove",this._handleDocumentClickMoveBound),document.addEventListener("touchmove",this._handleDocumentClickMoveBound),document.addEventListener("mouseup",this._handleDocumentClickEndBound),document.addEventListener("touchend",this._handleDocumentClickEndBound)}},{key:"_handleDocumentClickMove",value:function(t){t.preventDefault();var e=n._Pos(t),i=e.x-this.x0,s=e.y-this.y0;this.moved=!0,this.setHand(i,s,!1,!0)}},{key:"_handleDocumentClickEnd",value:function(e){var i=this;e.preventDefault(),document.removeEventListener("mouseup",this._handleDocumentClickEndBound),document.removeEventListener("touchend",this._handleDocumentClickEndBound);var s=n._Pos(e),o=s.x-this.x0,a=s.y-this.y0;this.moved&&o===this.dx&&a===this.dy&&this.setHand(o,a),"hours"===this.currentView?this.showView("minutes",this.options.duration/2):this.options.autoClose&&(t(this.minutesView).addClass("timepicker-dial-out"),setTimeout(function(){i.done()},this.options.duration/2)),document.removeEventListener("mousemove",this._handleDocumentClickMoveBound),document.removeEventListener("touchmove",this._handleDocumentClickMoveBound)}},{key:"_insertHTMLIntoDOM",value:function(){this.$modalEl=t(n._template),this.modalEl=this.$modalEl[0],this.modalEl.id="modal-"+this.id;var e=document.querySelector(this.options.container);this.options.container&&e?this.$modalEl.appendTo(e):this.$modalEl.insertBefore(this.el)}},{key:"_setupModal",value:function(){var t=this;this.modal=M.Modal.init(this.modalEl,{onCloseEnd:function(){t.isOpen=!1}})}},{key:"_setupVariables",value:function(){this.currentView="hours",this.vibrate=navigator.vibrate?"vibrate":navigator.webkitVibrate?"webkitVibrate":null,this._canvas=this.modalEl.querySelector(".timepicker-canvas"),this.plate=this.modalEl.querySelector(".timepicker-plate"),this.hoursView=this.modalEl.querySelector(".timepicker-hours"),this.minutesView=this.modalEl.querySelector(".timepicker-minutes"),this.spanHours=this.modalEl.querySelector(".timepicker-span-hours"),this.spanMinutes=this.modalEl.querySelector(".timepicker-span-minutes"),this.spanAmPm=this.modalEl.querySelector(".timepicker-span-am-pm"),this.footer=this.modalEl.querySelector(".timepicker-footer"),this.amOrPm="PM"}},{key:"_pickerSetup",value:function(){var e=t('<button class="btn-flat timepicker-clear waves-effect" style="visibility: hidden;" type="button" tabindex="'+(this.options.twelveHour?"3":"1")+'">'+this.options.i18n.clear+"</button>").appendTo(this.footer).on("click",this.clear.bind(this));this.options.showClearBtn&&e.css({visibility:""});var i=t('<div class="confirmation-btns"></div>');t('<button class="btn-flat timepicker-close waves-effect" type="button" tabindex="'+(this.options.twelveHour?"3":"1")+'">'+this.options.i18n.cancel+"</button>").appendTo(i).on("click",this.close.bind(this)),t('<button class="btn-flat timepicker-close waves-effect" type="button" tabindex="'+(this.options.twelveHour?"3":"1")+'">'+this.options.i18n.done+"</button>").appendTo(i).on("click",this.done.bind(this)),i.appendTo(this.footer)}},{key:"_clockSetup",value:function(){this.options.twelveHour&&(this.$amBtn=t('<div class="am-btn">AM</div>'),this.$pmBtn=t('<div class="pm-btn">PM</div>'),this.$amBtn.on("click",this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm),this.$pmBtn.on("click",this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm)),this._buildHoursView(),this._buildMinutesView(),this._buildSVGClock()}},{key:"_buildSVGClock",value:function(){var t=this.options.dialRadius,e=this.options.tickRadius,i=2*t,s=n._createSVGEl("svg");s.setAttribute("class","timepicker-svg"),s.setAttribute("width",i),s.setAttribute("height",i);var o=n._createSVGEl("g");o.setAttribute("transform","translate("+t+","+t+")");var a=n._createSVGEl("circle");a.setAttribute("class","timepicker-canvas-bearing"),a.setAttribute("cx",0),a.setAttribute("cy",0),a.setAttribute("r",4);var r=n._createSVGEl("line");r.setAttribute("x1",0),r.setAttribute("y1",0);var l=n._createSVGEl("circle");l.setAttribute("class","timepicker-canvas-bg"),l.setAttribute("r",e),o.appendChild(r),o.appendChild(l),o.appendChild(a),s.appendChild(o),this._canvas.appendChild(s),this.hand=r,this.bg=l,this.bearing=a,this.g=o}},{key:"_buildHoursView",value:function(){var e=t('<div class="timepicker-tick"></div>');if(this.options.twelveHour)for(var i=1;i<13;i+=1){var n=e.clone(),s=i/6*Math.PI,o=this.options.outerRadius;n.css({left:this.options.dialRadius+Math.sin(s)*o-this.options.tickRadius+"px",top:this.options.dialRadius-Math.cos(s)*o-this.options.tickRadius+"px"}),n.html(0===i?"00":i),this.hoursView.appendChild(n[0])}else for(var a=0;a<24;a+=1){var r=e.clone(),l=a/6*Math.PI,h=a>0&&a<13?this.options.innerRadius:this.options.outerRadius;r.css({left:this.options.dialRadius+Math.sin(l)*h-this.options.tickRadius+"px",top:this.options.dialRadius-Math.cos(l)*h-this.options.tickRadius+"px"}),r.html(0===a?"00":a),this.hoursView.appendChild(r[0])}}},{key:"_buildMinutesView",value:function(){for(var e=t('<div class="timepicker-tick"></div>'),i=0;i<60;i+=5){var s=e.clone(),o=i/30*Math.PI;s.css({left:this.options.dialRadius+Math.sin(o)*this.options.outerRadius-this.options.tickRadius+"px",top:this.options.dialRadius-Math.cos(o)*this.options.outerRadius-this.options.tickRadius+"px"}),s.html(n._addLeadingZero(i)),this.minutesView.appendChild(s[0])}}},{key:"_handleAmPmClick",value:function(e){var i=t(e.target);this.amOrPm=i.hasClass("am-btn")?"AM":"PM",this._updateAmPmView()}},{key:"_updateAmPmView",value:function(){this.options.twelveHour&&(this.$amBtn.toggleClass("text-primary","AM"===this.amOrPm),this.$pmBtn.toggleClass("text-primary","PM"===this.amOrPm))}},{key:"_updateTimeFromInput",value:function(){var t=((this.el.value||this.options.defaultTime||"")+"").split(":");if(this.options.twelveHour&&void 0!==t[1]&&(t[1].toUpperCase().indexOf("AM")>0?this.amOrPm="AM":this.amOrPm="PM",t[1]=t[1].replace("AM","").replace("PM","")),"now"===t[0]){var e=new Date(+new Date+this.options.fromNow);t=[e.getHours(),e.getMinutes()],this.options.twelveHour&&(this.amOrPm=t[0]>=12&&t[0]<24?"PM":"AM")}this.hours=+t[0]||0,this.minutes=+t[1]||0,this.spanHours.innerHTML=this.hours,this.spanMinutes.innerHTML=n._addLeadingZero(this.minutes),this._updateAmPmView()}},{key:"showView",value:function(e,i){"minutes"===e&&t(this.hoursView).css("visibility");var n="hours"===e,s=n?this.hoursView:this.minutesView,o=n?this.minutesView:this.hoursView;this.currentView=e,t(this.spanHours).toggleClass("text-primary",n),t(this.spanMinutes).toggleClass("text-primary",!n),o.classList.add("timepicker-dial-out"),t(s).css("visibility","visible").removeClass("timepicker-dial-out"),this.resetClock(i),clearTimeout(this.toggleViewTimer),this.toggleViewTimer=setTimeout(function(){t(o).css("visibility","hidden")},this.options.duration)}},{key:"resetClock",value:function(e){var i=this.currentView,n=this[i],s="hours"===i,o=n*(Math.PI/(s?6:30)),a=s&&n>0&&n<13?this.options.innerRadius:this.options.outerRadius,r=Math.sin(o)*a,l=-Math.cos(o)*a,h=this;e?(t(this.canvas).addClass("timepicker-canvas-out"),setTimeout(function(){t(h.canvas).removeClass("timepicker-canvas-out"),h.setHand(r,l)},e)):this.setHand(r,l)}},{key:"setHand",value:function(t,e,i){var s=this,o=Math.atan2(t,-e),a="hours"===this.currentView,r=Math.PI/(a||i?6:30),l=Math.sqrt(t*t+e*e),h=a&&l<(this.options.outerRadius+this.options.innerRadius)/2,d=h?this.options.innerRadius:this.options.outerRadius;this.options.twelveHour&&(d=this.options.outerRadius),o<0&&(o=2*Math.PI+o);var u=Math.round(o/r);o=u*r,this.options.twelveHour?a?0===u&&(u=12):(i&&(u*=5),60===u&&(u=0)):a?(12===u&&(u=0),u=h?0===u?12:u:0===u?0:u+12):(i&&(u*=5),60===u&&(u=0)),this[this.currentView]!==u&&this.vibrate&&this.options.vibrate&&(this.vibrateTimer||(navigator[this.vibrate](10),this.vibrateTimer=setTimeout(function(){s.vibrateTimer=null},100))),this[this.currentView]=u,a?this.spanHours.innerHTML=u:this.spanMinutes.innerHTML=n._addLeadingZero(u);var c=Math.sin(o)*(d-this.options.tickRadius),p=-Math.cos(o)*(d-this.options.tickRadius),v=Math.sin(o)*d,f=-Math.cos(o)*d;this.hand.setAttribute("x2",c),this.hand.setAttribute("y2",p),this.bg.setAttribute("cx",v),this.bg.setAttribute("cy",f)}},{key:"open",value:function(){this.isOpen||(this.isOpen=!0,this._updateTimeFromInput(),this.showView("hours"),this.modal.open())}},{key:"close",value:function(){this.isOpen&&(this.isOpen=!1,this.modal.close())}},{key:"done",value:function(t,e){var i=this.el.value,s=e?"":n._addLeadingZero(this.hours)+":"+n._addLeadingZero(this.minutes);this.time=s,!e&&this.options.twelveHour&&(s=s+" "+this.amOrPm),this.el.value=s,s!==i&&this.$el.trigger("change"),this.close(),this.el.focus()}},{key:"clear",value:function(){this.done(null,!0)}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"_addLeadingZero",value:function(t){return(t<10?"0":"")+t}},{key:"_createSVGEl",value:function(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}},{key:"_Pos",value:function(t){return t.targetTouches&&t.targetTouches.length>=1?{x:t.targetTouches[0].clientX,y:t.targetTouches[0].clientY}:{x:t.clientX,y:t.clientY}}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Timepicker}},{key:"defaults",get:function(){return e}}]),n}();i._template=['<div class= "modal timepicker-modal">','<div class="modal-content timepicker-container">','<div class="timepicker-digital-display">','<div class="timepicker-text-container">','<div class="timepicker-display-column">','<span class="timepicker-span-hours text-primary"></span>',":",'<span class="timepicker-span-minutes"></span>',"</div>",'<div class="timepicker-display-column timepicker-display-am-pm">','<div class="timepicker-span-am-pm"></div>',"</div>","</div>","</div>",'<div class="timepicker-analog-display">','<div class="timepicker-plate">','<div class="timepicker-canvas"></div>','<div class="timepicker-dial timepicker-hours"></div>','<div class="timepicker-dial timepicker-minutes timepicker-dial-out"></div>',"</div>",'<div class="timepicker-footer"></div>',"</div>","</div>","</div>"].join(""),M.Timepicker=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"timepicker","M_Timepicker")}(cash),function(t){"use strict";var e={},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_CharacterCounter=s,s.options=t.extend({},n.defaults,i),s.isInvalid=!1,s.isValidLength=!1,s._setupCounter(),s._setupEventHandlers(),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this.el.CharacterCounter=void 0,this._removeCounter()}},{key:"_setupEventHandlers",value:function(){this._handleUpdateCounterBound=this.updateCounter.bind(this),this.el.addEventListener("focus",this._handleUpdateCounterBound,!0),this.el.addEventListener("input",this._handleUpdateCounterBound,!0)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("focus",this._handleUpdateCounterBound,!0),this.el.removeEventListener("input",this._handleUpdateCounterBound,!0)}},{key:"_setupCounter",value:function(){this.counterEl=document.createElement("span"),t(this.counterEl).addClass("character-counter").css({float:"right","font-size":"12px",height:1}),this.$el.parent().append(this.counterEl)}},{key:"_removeCounter",value:function(){t(this.counterEl).remove()}},{key:"updateCounter",value:function(){var e=+this.$el.attr("data-length"),i=this.el.value.length;this.isValidLength=i<=e;var n=i;e&&(n+="/"+e,this._validateInput()),t(this.counterEl).html(n)}},{key:"_validateInput",value:function(){this.isValidLength&&this.isInvalid?(this.isInvalid=!1,this.$el.removeClass("invalid")):this.isValidLength||this.isInvalid||(this.isInvalid=!0,this.$el.removeClass("valid"),this.$el.addClass("invalid"))}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_CharacterCounter}},{key:"defaults",get:function(){return e}}]),n}();M.CharacterCounter=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"characterCounter","M_CharacterCounter")}(cash),function(t){"use strict";var e={duration:200,dist:-100,shift:0,padding:0,numVisible:5,fullWidth:!1,indicators:!1,noWrap:!1,onCycleTo:null},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_Carousel=s,s.options=t.extend({},n.defaults,i),s.hasMultipleSlides=s.$el.find(".carousel-item").length>1,s.showIndicators=s.options.indicators&&s.hasMultipleSlides,s.noWrap=s.options.noWrap||!s.hasMultipleSlides,s.pressed=!1,s.dragged=!1,s.offset=s.target=0,s.images=[],s.itemWidth=s.$el.find(".carousel-item").first().innerWidth(),s.itemHeight=s.$el.find(".carousel-item").first().innerHeight(),s.dim=2*s.itemWidth+s.options.padding||1,s._autoScrollBound=s._autoScroll.bind(s),s._trackBound=s._track.bind(s),s.options.fullWidth&&(s.options.dist=0,s._setCarouselHeight(),s.showIndicators&&s.$el.find(".carousel-fixed-item").addClass("with-indicators")),s.$indicators=t('<ul class="indicators"></ul>'),s.$el.find(".carousel-item").each(function(e,i){if(s.images.push(e),s.showIndicators){var n=t('<li class="indicator-item"></li>');0===i&&n[0].classList.add("active"),s.$indicators.append(n)}}),s.showIndicators&&s.$el.append(s.$indicators),s.count=s.images.length,s.options.numVisible=Math.min(s.count,s.options.numVisible),s.xform="transform",["webkit","Moz","O","ms"].every(function(t){var e=t+"Transform";return void 0===document.body.style[e]||(s.xform=e,!1)}),s._setupEventHandlers(),s._scroll(s.offset),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this.el.M_Carousel=void 0}},{key:"_setupEventHandlers",value:function(){var t=this;this._handleCarouselTapBound=this._handleCarouselTap.bind(this),this._handleCarouselDragBound=this._handleCarouselDrag.bind(this),this._handleCarouselReleaseBound=this._handleCarouselRelease.bind(this),this._handleCarouselClickBound=this._handleCarouselClick.bind(this),void 0!==window.ontouchstart&&(this.el.addEventListener("touchstart",this._handleCarouselTapBound),this.el.addEventListener("touchmove",this._handleCarouselDragBound),this.el.addEventListener("touchend",this._handleCarouselReleaseBound)),this.el.addEventListener("mousedown",this._handleCarouselTapBound),this.el.addEventListener("mousemove",this._handleCarouselDragBound),this.el.addEventListener("mouseup",this._handleCarouselReleaseBound),this.el.addEventListener("mouseleave",this._handleCarouselReleaseBound),this.el.addEventListener("click",this._handleCarouselClickBound),this.showIndicators&&this.$indicators&&(this._handleIndicatorClickBound=this._handleIndicatorClick.bind(this),this.$indicators.find(".indicator-item").each(function(e,i){e.addEventListener("click",t._handleIndicatorClickBound)}));var e=M.throttle(this._handleResize,200);this._handleThrottledResizeBound=e.bind(this),window.addEventListener("resize",this._handleThrottledResizeBound)}},{key:"_removeEventHandlers",value:function(){var t=this;void 0!==window.ontouchstart&&(this.el.removeEventListener("touchstart",this._handleCarouselTapBound),this.el.removeEventListener("touchmove",this._handleCarouselDragBound),this.el.removeEventListener("touchend",this._handleCarouselReleaseBound)),this.el.removeEventListener("mousedown",this._handleCarouselTapBound),this.el.removeEventListener("mousemove",this._handleCarouselDragBound),this.el.removeEventListener("mouseup",this._handleCarouselReleaseBound),this.el.removeEventListener("mouseleave",this._handleCarouselReleaseBound),this.el.removeEventListener("click",this._handleCarouselClickBound),this.showIndicators&&this.$indicators&&this.$indicators.find(".indicator-item").each(function(e,i){e.removeEventListener("click",t._handleIndicatorClickBound)}),window.removeEventListener("resize",this._handleThrottledResizeBound)}},{key:"_handleCarouselTap",value:function(e){"mousedown"===e.type&&t(e.target).is("img")&&e.preventDefault(),this.pressed=!0,this.dragged=!1,this.verticalDragged=!1,this.reference=this._xpos(e),this.referenceY=this._ypos(e),this.velocity=this.amplitude=0,this.frame=this.offset,this.timestamp=Date.now(),clearInterval(this.ticker),this.ticker=setInterval(this._trackBound,100)}},{key:"_handleCarouselDrag",value:function(t){var e=void 0,i=void 0,n=void 0;if(this.pressed)if(e=this._xpos(t),i=this._ypos(t),n=this.reference-e,Math.abs(this.referenceY-i)<30&&!this.verticalDragged)(n>2||n<-2)&&(this.dragged=!0,this.reference=e,this._scroll(this.offset+n));else{if(this.dragged)return t.preventDefault(),t.stopPropagation(),!1;this.verticalDragged=!0}if(this.dragged)return t.preventDefault(),t.stopPropagation(),!1}},{key:"_handleCarouselRelease",value:function(t){if(this.pressed)return this.pressed=!1,clearInterval(this.ticker),this.target=this.offset,(this.velocity>10||this.velocity<-10)&&(this.amplitude=.9*this.velocity,this.target=this.offset+this.amplitude),this.target=Math.round(this.target/this.dim)*this.dim,this.noWrap&&(this.target>=this.dim*(this.count-1)?this.target=this.dim*(this.count-1):this.target<0&&(this.target=0)),this.amplitude=this.target-this.offset,this.timestamp=Date.now(),requestAnimationFrame(this._autoScrollBound),this.dragged&&(t.preventDefault(),t.stopPropagation()),!1}},{key:"_handleCarouselClick",value:function(e){if(this.dragged)return e.preventDefault(),e.stopPropagation(),!1;if(!this.options.fullWidth){var i=t(e.target).closest(".carousel-item").index();0!==this._wrap(this.center)-i&&(e.preventDefault(),e.stopPropagation()),this._cycleTo(i)}}},{key:"_handleIndicatorClick",value:function(e){e.stopPropagation();var i=t(e.target).closest(".indicator-item");i.length&&this._cycleTo(i.index())}},{key:"_handleResize",value:function(t){this.options.fullWidth?(this.itemWidth=this.$el.find(".carousel-item").first().innerWidth(),this.imageHeight=this.$el.find(".carousel-item.active").height(),this.dim=2*this.itemWidth+this.options.padding,this.offset=2*this.center*this.itemWidth,this.target=this.offset,this._setCarouselHeight(!0)):this._scroll()}},{key:"_setCarouselHeight",value:function(t){var e=this,i=this.$el.find(".carousel-item.active").length?this.$el.find(".carousel-item.active").first():this.$el.find(".carousel-item").first(),n=i.find("img").first();if(n.length)if(n[0].complete){var s=n.height();if(s>0)this.$el.css("height",s+"px");else{var o=n[0].naturalWidth,a=n[0].naturalHeight,r=this.$el.width()/o*a;this.$el.css("height",r+"px")}}else n.one("load",function(t,i){e.$el.css("height",t.offsetHeight+"px")});else if(!t){var l=i.height();this.$el.css("height",l+"px")}}},{key:"_xpos",value:function(t){return t.targetTouches&&t.targetTouches.length>=1?t.targetTouches[0].clientX:t.clientX}},{key:"_ypos",value:function(t){return t.targetTouches&&t.targetTouches.length>=1?t.targetTouches[0].clientY:t.clientY}},{key:"_wrap",value:function(t){return t>=this.count?t%this.count:t<0?this._wrap(this.count+t%this.count):t}},{key:"_track",value:function(){var t=void 0,e=void 0,i=void 0,n=void 0;e=(t=Date.now())-this.timestamp,this.timestamp=t,i=this.offset-this.frame,this.frame=this.offset,n=1e3*i/(1+e),this.velocity=.8*n+.2*this.velocity}},{key:"_autoScroll",value:function(){var t=void 0,e=void 0;this.amplitude&&(t=Date.now()-this.timestamp,(e=this.amplitude*Math.exp(-t/this.options.duration))>2||e<-2?(this._scroll(this.target-e),requestAnimationFrame(this._autoScrollBound)):this._scroll(this.target))}},{key:"_scroll",value:function(e){var i=this;this.$el.hasClass("scrolling")||this.el.classList.add("scrolling"),null!=this.scrollingTimeout&&window.clearTimeout(this.scrollingTimeout),this.scrollingTimeout=window.setTimeout(function(){i.$el.removeClass("scrolling")},this.options.duration);var n=void 0,s=void 0,o=void 0,a=void 0,r=void 0,l=void 0,h=void 0,d=void 0,u=void 0,c=void 0,p=this.center,v=1/this.options.numVisible;if(this.offset="number"==typeof e?e:this.offset,this.center=Math.floor((this.offset+this.dim/2)/this.dim),o=this.offset-this.center*this.dim,a=o<0?1:-1,r=-a*o*2/this.dim,s=this.count>>1,this.options.fullWidth?(h="translateX(0)",c=1):(h="translateX("+(this.el.clientWidth-this.itemWidth)/2+"px) ",h+="translateY("+(this.el.clientHeight-this.itemHeight)/2+"px)",c=1-v*r),this.showIndicators){var f=this.center%this.count,m=this.$indicators.find(".indicator-item.active");m.index()!==f&&(m.removeClass("active"),this.$indicators.find(".indicator-item").eq(f)[0].classList.add("active"))}if(!this.noWrap||this.center>=0&&this.center<this.count){l=this.images[this._wrap(this.center)],t(l).hasClass("active")||(this.$el.find(".carousel-item").removeClass("active"),l.classList.add("active"));var g=h+" translateX("+-o/2+"px) translateX("+a*this.options.shift*r*n+"px) translateZ("+this.options.dist*r+"px)";this._updateItemStyle(l,c,0,g)}for(n=1;n<=s;++n){if(this.options.fullWidth?(d=this.options.dist,u=n===s&&o<0?1-r:1):(d=this.options.dist*(2*n+r*a),u=1-v*(2*n+r*a)),!this.noWrap||this.center+n<this.count){l=this.images[this._wrap(this.center+n)];var _=h+" translateX("+(this.options.shift+(this.dim*n-o)/2)+"px) translateZ("+d+"px)";this._updateItemStyle(l,u,-n,_)}if(this.options.fullWidth?(d=this.options.dist,u=n===s&&o>0?1-r:1):(d=this.options.dist*(2*n-r*a),u=1-v*(2*n-r*a)),!this.noWrap||this.center-n>=0){l=this.images[this._wrap(this.center-n)];var y=h+" translateX("+(-this.options.shift+(-this.dim*n-o)/2)+"px) translateZ("+d+"px)";this._updateItemStyle(l,u,-n,y)}}if(!this.noWrap||this.center>=0&&this.center<this.count){l=this.images[this._wrap(this.center)];var k=h+" translateX("+-o/2+"px) translateX("+a*this.options.shift*r+"px) translateZ("+this.options.dist*r+"px)";this._updateItemStyle(l,c,0,k)}var b=this.$el.find(".carousel-item").eq(this._wrap(this.center));p!==this.center&&"function"==typeof this.options.onCycleTo&&this.options.onCycleTo.call(this,b[0],this.dragged),"function"==typeof this.oneTimeCallback&&(this.oneTimeCallback.call(this,b[0],this.dragged),this.oneTimeCallback=null)}},{key:"_updateItemStyle",value:function(t,e,i,n){t.style[this.xform]=n,t.style.zIndex=i,t.style.opacity=e,t.style.visibility="visible"}},{key:"_cycleTo",value:function(t,e){var i=this.center%this.count-t;this.noWrap||(i<0?Math.abs(i+this.count)<Math.abs(i)&&(i+=this.count):i>0&&Math.abs(i-this.count)<i&&(i-=this.count)),this.target=this.dim*Math.round(this.offset/this.dim),i<0?this.target+=this.dim*Math.abs(i):i>0&&(this.target-=this.dim*i),"function"==typeof e&&(this.oneTimeCallback=e),this.offset!==this.target&&(this.amplitude=this.target-this.offset,this.timestamp=Date.now(),requestAnimationFrame(this._autoScrollBound))}},{key:"next",value:function(t){(void 0===t||isNaN(t))&&(t=1);var e=this.center+t;if(e>this.count||e<0){if(this.noWrap)return;e=this._wrap(e)}this._cycleTo(e)}},{key:"prev",value:function(t){(void 0===t||isNaN(t))&&(t=1);var e=this.center-t;if(e>this.count||e<0){if(this.noWrap)return;e=this._wrap(e)}this._cycleTo(e)}},{key:"set",value:function(t,e){if((void 0===t||isNaN(t))&&(t=0),t>this.count||t<0){if(this.noWrap)return;t=this._wrap(t)}this._cycleTo(t,e)}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Carousel}},{key:"defaults",get:function(){return e}}]),n}();M.Carousel=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"carousel","M_Carousel")}(cash),function(t){"use strict";var e={onOpen:void 0,onClose:void 0},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.el.M_TapTarget=s,s.options=t.extend({},n.defaults,i),s.isOpen=!1,s.$origin=t("#"+s.$el.attr("data-target")),s._setup(),s._calculatePositioning(),s._setupEventHandlers(),s}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this.el.TapTarget=void 0}},{key:"_setupEventHandlers",value:function(){this._handleDocumentClickBound=this._handleDocumentClick.bind(this),this._handleTargetClickBound=this._handleTargetClick.bind(this),this._handleOriginClickBound=this._handleOriginClick.bind(this),this.el.addEventListener("click",this._handleTargetClickBound),this.originEl.addEventListener("click",this._handleOriginClickBound);var t=M.throttle(this._handleResize,200);this._handleThrottledResizeBound=t.bind(this),window.addEventListener("resize",this._handleThrottledResizeBound)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("click",this._handleTargetClickBound),this.originEl.removeEventListener("click",this._handleOriginClickBound),window.removeEventListener("resize",this._handleThrottledResizeBound)}},{key:"_handleTargetClick",value:function(t){this.open()}},{key:"_handleOriginClick",value:function(t){this.close()}},{key:"_handleResize",value:function(t){this._calculatePositioning()}},{key:"_handleDocumentClick",value:function(e){t(e.target).closest(".tap-target-wrapper").length||(this.close(),e.preventDefault(),e.stopPropagation())}},{key:"_setup",value:function(){this.wrapper=this.$el.parent()[0],this.waveEl=t(this.wrapper).find(".tap-target-wave")[0],this.originEl=t(this.wrapper).find(".tap-target-origin")[0],this.contentEl=this.$el.find(".tap-target-content")[0],t(this.wrapper).hasClass(".tap-target-wrapper")||(this.wrapper=document.createElement("div"),this.wrapper.classList.add("tap-target-wrapper"),this.$el.before(t(this.wrapper)),this.wrapper.append(this.el)),this.contentEl||(this.contentEl=document.createElement("div"),this.contentEl.classList.add("tap-target-content"),this.$el.append(this.contentEl)),this.waveEl||(this.waveEl=document.createElement("div"),this.waveEl.classList.add("tap-target-wave"),this.originEl||(this.originEl=this.$origin.clone(!0,!0),this.originEl.addClass("tap-target-origin"),this.originEl.removeAttr("id"),this.originEl.removeAttr("style"),this.originEl=this.originEl[0],this.waveEl.append(this.originEl)),this.wrapper.append(this.waveEl))}},{key:"_calculatePositioning",value:function(){var e="fixed"===this.$origin.css("position");if(!e)for(var i=this.$origin.parents(),n=0;n<i.length&&!(e="fixed"==t(i[n]).css("position"));n++);var s=this.$origin.outerWidth(),o=this.$origin.outerHeight(),a=e?this.$origin.offset().top-M.getDocumentScrollTop():this.$origin.offset().top,r=e?this.$origin.offset().left-M.getDocumentScrollLeft():this.$origin.offset().left,l=window.innerWidth,h=window.innerHeight,d=l/2,u=h/2,c=r<=d,p=r>d,v=a<=u,f=a>u,m=r>=.25*l&&r<=.75*l,g=this.$el.outerWidth(),_=this.$el.outerHeight(),y=a+o/2-_/2,k=r+s/2-g/2,b=e?"fixed":"absolute",w=m?g:g/2+s,C=_/2,E=v?_/2:0,x=c&&!m?g/2-s:0,O=s,T=f?"bottom":"top",L=2*s,$=L,B=_/2-$/2,D=g/2-L/2,S={};S.top=v?y+"px":"",S.right=p?l-k-g+"px":"",S.bottom=f?h-y-_+"px":"",S.left=c?k+"px":"",S.position=b,t(this.wrapper).css(S),t(this.contentEl).css({width:w+"px",height:C+"px",top:E+"px",right:"0px",bottom:"0px",left:x+"px",padding:O+"px",verticalAlign:T}),t(this.waveEl).css({top:B+"px",left:D+"px",width:L+"px",height:$+"px"})}},{key:"open",value:function(){this.isOpen||("function"==typeof this.options.onOpen&&this.options.onOpen.call(this,this.$origin[0]),this.isOpen=!0,this.wrapper.classList.add("open"),document.body.addEventListener("click",this._handleDocumentClickBound,!0),document.body.addEventListener("touchend",this._handleDocumentClickBound))}},{key:"close",value:function(){this.isOpen&&("function"==typeof this.options.onClose&&this.options.onClose.call(this,this.$origin[0]),this.isOpen=!1,this.wrapper.classList.remove("open"),document.body.removeEventListener("click",this._handleDocumentClickBound,!0),document.body.removeEventListener("touchend",this._handleDocumentClickBound))}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_TapTarget}},{key:"defaults",get:function(){return e}}]),n}();M.TapTarget=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"tapTarget","M_TapTarget")}(cash),function(t){"use strict";var e={classes:"",dropdownOptions:{}},i=function(i){function n(e,i){_classCallCheck(this,n);var s=_possibleConstructorReturn(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,n,e,i));return s.$el.hasClass("browser-default")?_possibleConstructorReturn(s):(s.el.M_FormSelect=s,s.options=t.extend({},n.defaults,i),s.isMultiple=s.$el.prop("multiple"),s.el.tabIndex=-1,s._keysSelected={},s._valueDict={},s._setupDropdown(),s._setupEventHandlers(),s)}return _inherits(n,Component),_createClass(n,[{key:"destroy",value:function(){this._removeEventHandlers(),this._removeDropdown(),this.el.M_FormSelect=void 0}},{key:"_setupEventHandlers",value:function(){var e=this;this._handleSelectChangeBound=this._handleSelectChange.bind(this),this._handleOptionClickBound=this._handleOptionClick.bind(this),this._handleInputClickBound=this._handleInputClick.bind(this),t(this.dropdownOptions).find("li:not(.optgroup)").each(function(t){t.addEventListener("click",e._handleOptionClickBound)}),this.el.addEventListener("change",this._handleSelectChangeBound),this.input.addEventListener("click",this._handleInputClickBound)}},{key:"_removeEventHandlers",value:function(){var e=this;t(this.dropdownOptions).find("li:not(.optgroup)").each(function(t){t.removeEventListener("click",e._handleOptionClickBound)}),this.el.removeEventListener("change",this._handleSelectChangeBound),this.input.removeEventListener("click",this._handleInputClickBound)}},{key:"_handleSelectChange",value:function(t){this._setValueToInput()}},{key:"_handleOptionClick",value:function(e){e.preventDefault();var i=t(e.target).closest("li")[0],n=i.id;if(!t(i).hasClass("disabled")&&!t(i).hasClass("optgroup")&&n.length){var s=!0;if(this.isMultiple){var o=t(this.dropdownOptions).find("li.disabled.selected");o.length&&(o.removeClass("selected"),o.find('input[type="checkbox"]').prop("checked",!1),this._toggleEntryFromArray(o[0].id));var a=t(i).find('input[type="checkbox"]');a.prop("checked",!a.prop("checked")),s=this._toggleEntryFromArray(n)}else t(this.dropdownOptions).find("li").removeClass("active"),t(i).toggleClass("active"),this.input.value=i.textContent;this._activateOption(t(this.dropdownOptions),i),t(this._valueDict[n].el).prop("selected",s),this.$el.trigger("change")}e.stopPropagation()}},{key:"_handleInputClick",value:function(){this.dropdown&&this.dropdown.isOpen&&(this._setValueToInput(),this._setSelectedStates())}},{key:"_setupDropdown",value:function(){var e=this;this.wrapper=document.createElement("div"),t(this.wrapper).addClass("select-wrapper "+this.options.classes),this.$el.before(t(this.wrapper)),this.wrapper.appendChild(this.el),this.el.disabled&&this.wrapper.classList.add("disabled"),this.$selectOptions=this.$el.children("option, optgroup"),this.dropdownOptions=document.createElement("ul"),this.dropdownOptions.id="select-options-"+M.guid(),t(this.dropdownOptions).addClass("dropdown-content select-dropdown "+(this.isMultiple?"multiple-select-dropdown":"")),this.$selectOptions.length&&this.$selectOptions.each(function(i){if(t(i).is("option")){var n=void 0;n=e.isMultiple?e._appendOptionWithIcon(e.$el,i,"multiple"):e._appendOptionWithIcon(e.$el,i),e._addOptionToValueDict(i,n)}else if(t(i).is("optgroup")){var s=t(i).children("option");t(e.dropdownOptions).append(t('<li class="optgroup"><span>'+i.getAttribute("label")+"</span></li>")[0]),s.each(function(t){var i=e._appendOptionWithIcon(e.$el,t,"optgroup-option");e._addOptionToValueDict(t,i)})}}),this.$el.after(this.dropdownOptions),this.input=document.createElement("input"),t(this.input).addClass("select-dropdown dropdown-trigger"),this.input.setAttribute("type","text"),this.input.setAttribute("readonly","true"),this.input.setAttribute("data-target",this.dropdownOptions.id),this.el.disabled&&t(this.input).prop("disabled","true"),this.$el.before(this.input),this._setValueToInput();var i=t('<svg class="caret" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');if(this.$el.before(i[0]),!this.el.disabled){var n=t.extend({},this.options.dropdownOptions);n.onOpenEnd=function(i){var n=t(e.dropdownOptions).find(".selected").first();if(e.dropdown.isScrollable&&n.length){var s=n[0].getBoundingClientRect().top-e.dropdownOptions.getBoundingClientRect().top;s-=e.dropdownOptions.clientHeight/2,e.dropdownOptions.scrollTop=s}},this.isMultiple&&(n.closeOnClick=!1),this.dropdown=M.Dropdown.init(this.input,n)}this._setSelectedStates()}},{key:"_addOptionToValueDict",value:function(t,e){var i=Object.keys(this._valueDict).length,n=this.dropdownOptions.id+i,s={};e.id=n,s.el=t,s.optionEl=e,this._valueDict[n]=s}},{key:"_removeDropdown",value:function(){t(this.wrapper).find(".caret").remove(),t(this.input).remove(),t(this.dropdownOptions).remove(),t(this.wrapper).before(this.$el),t(this.wrapper).remove()}},{key:"_appendOptionWithIcon",value:function(e,i,n){var s=i.disabled?"disabled ":"",o="optgroup-option"===n?"optgroup-option ":"",a=this.isMultiple?'<label><input type="checkbox"'+s+'"/><span>'+i.innerHTML+"</span></label>":i.innerHTML,r=t("<li></li>"),l=t("<span></span>");l.html(a),r.addClass(s+" "+o),r.append(l);var h=i.getAttribute("data-icon");i.getAttribute("class");if(h){var d=t('<img alt="" src="'+h+'">');r.prepend(d)}return t(this.dropdownOptions).append(r[0]),r[0]}},{key:"_toggleEntryFromArray",value:function(e){var i=!this._keysSelected.hasOwnProperty(e);return i?this._keysSelected[e]=!0:delete this._keysSelected[e],t(this._valueDict[e].optionEl).toggleClass("active"),t(this._valueDict[e].el).prop("selected",i),i}},{key:"_setValueToInput",value:function(){var e="";if(this.$el.find("option").each(function(i){if(t(i).prop("selected")){var n=t(i).text();e+=""===e?n:", "+n}}),""===e){var i=this.$el.find("option:disabled").eq(0);i.length&&(e=i.text())}this.input.value=e}},{key:"_setSelectedStates",value:function(){this._keysSelected={};for(var e in this._valueDict){var i=this._valueDict[e];t(i.el).prop("selected")?(t(i.optionEl).find('input[type="checkbox"]').prop("checked",!0),this._activateOption(t(this.dropdownOptions),t(i.optionEl)),this._keysSelected[e]=!0):(t(i.optionEl).find('input[type="checkbox"]').prop("checked",!1),t(i.optionEl).removeClass("selected"))}}},{key:"_activateOption",value:function(e,i){i&&(this.isMultiple||e.find("li.selected").removeClass("selected"),t(i).addClass("selected"))}},{key:"getSelectedValues",value:function(){var t=[];for(var e in this._keysSelected)t.push(this._valueDict[e].el.value);return t}}],[{key:"init",value:function(t,e){return _get(n.__proto__||Object.getPrototypeOf(n),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_FormSelect}},{key:"defaults",get:function(){return e}}]),n}();M.FormSelect=i,M.jQueryLoaded&&M.initializeJqueryWrapper(i,"formSelect","M_FormSelect")}(cash),function(t,e){"use strict";var i={},n=function(n){function s(e,i){_classCallCheck(this,s);var n=_possibleConstructorReturn(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,s,e,i));return n.el.M_Range=n,n.options=t.extend({},s.defaults,i),n._mousedown=!1,n._setupThumb(),n._setupEventHandlers(),n}return _inherits(s,Component),_createClass(s,[{key:"destroy",value:function(){this._removeEventHandlers(),this._removeThumb(),this.el.M_Range=void 0}},{key:"_setupEventHandlers",value:function(){this._handleRangeChangeBound=this._handleRangeChange.bind(this),this._handleRangeFocusBound=this._handleRangeFocus.bind(this),this._handleRangeMousedownTouchstartBound=this._handleRangeMousedownTouchstart.bind(this),this._handleRangeInputMousemoveTouchmoveBound=this._handleRangeInputMousemoveTouchmove.bind(this),this._handleRangeMouseupTouchendBound=this._handleRangeMouseupTouchend.bind(this),this._handleRangeBlurMouseoutTouchleaveBound=this._handleRangeBlurMouseoutTouchleave.bind(this),this.el.addEventListener("change",this._handleRangeChangeBound),this.el.addEventListener("focus",this._handleRangeFocusBound),this.el.addEventListener("mousedown",this._handleRangeMousedownTouchstartBound),this.el.addEventListener("touchstart",this._handleRangeMousedownTouchstartBound),this.el.addEventListener("input",this._handleRangeInputMousemoveTouchmoveBound),this.el.addEventListener("mousemove",this._handleRangeInputMousemoveTouchmoveBound),this.el.addEventListener("touchmove",this._handleRangeInputMousemoveTouchmoveBound),this.el.addEventListener("mouseup",this._handleRangeMouseupTouchendBound),this.el.addEventListener("touchend",this._handleRangeMouseupTouchendBound),this.el.addEventListener("blur",this._handleRangeBlurMouseoutTouchleaveBound),this.el.addEventListener("mouseout",this._handleRangeBlurMouseoutTouchleaveBound),this.el.addEventListener("touchleave",this._handleRangeBlurMouseoutTouchleaveBound)}},{key:"_removeEventHandlers",value:function(){this.el.removeEventListener("change",this._handleRangeChangeBound),this.el.removeEventListener("focus",this._handleRangeFocusBound),this.el.removeEventListener("mousedown",this._handleRangeMousedownTouchstartBound),this.el.removeEventListener("touchstart",this._handleRangeMousedownTouchstartBound),this.el.removeEventListener("input",this._handleRangeInputMousemoveTouchmoveBound),this.el.removeEventListener("mousemove",this._handleRangeInputMousemoveTouchmoveBound),this.el.removeEventListener("touchmove",this._handleRangeInputMousemoveTouchmoveBound),this.el.removeEventListener("mouseup",this._handleRangeMouseupTouchendBound),this.el.removeEventListener("touchend",this._handleRangeMouseupTouchendBound),this.el.removeEventListener("blur",this._handleRangeBlurMouseoutTouchleaveBound),this.el.removeEventListener("mouseout",this._handleRangeBlurMouseoutTouchleaveBound),this.el.removeEventListener("touchleave",this._handleRangeBlurMouseoutTouchleaveBound)}},{key:"_handleRangeChange",value:function(){t(this.value).html(this.$el.val()),t(this.thumb).hasClass("active")||this._showRangeBubble();var e=this._calcRangeOffset();t(this.thumb).addClass("active").css("left",e+"px")}},{key:"_handleRangeFocus",value:function(){M.tabPressed&&this.$el.addClass("focused")}},{key:"_handleRangeMousedownTouchstart",value:function(e){if(t(this.value).html(this.$el.val()),this._mousedown=!0,this.$el.addClass("active"),t(this.thumb).hasClass("active")||this._showRangeBubble(),"input"!==e.type){var i=this._calcRangeOffset();t(this.thumb).addClass("active").css("left",i+"px")}}},{key:"_handleRangeInputMousemoveTouchmove",value:function(){if(this._mousedown){t(this.thumb).hasClass("active")||this._showRangeBubble();var e=this._calcRangeOffset();t(this.thumb).addClass("active").css("left",e+"px"),t(this.value).html(this.$el.val())}}},{key:"_handleRangeMouseupTouchend",value:function(){this._mousedown=!1,this.$el.removeClass("active")}},{key:"_handleRangeBlurMouseoutTouchleave",value:function(){if(!this._mousedown){this.$el.removeClass("focused");var i=7+parseInt(this.$el.css("padding-left"))+"px";t(this.thumb).hasClass("active")&&(e.remove(this.thumb),e({targets:this.thumb,height:0,width:0,top:10,easing:"easeOutQuad",marginLeft:i,duration:100})),t(this.thumb).removeClass("active")}}},{key:"_setupThumb",value:function(){this.thumb=document.createElement("span"),this.value=document.createElement("span"),t(this.thumb).addClass("thumb"),t(this.value).addClass("value"),t(this.thumb).append(this.value),this.$el.after(this.thumb)}},{key:"_removeThumb",value:function(){t(this.thumb).remove()}},{key:"_showRangeBubble",value:function(){var i=-7+parseInt(t(this.thumb).parent().css("padding-left"))+"px";e.remove(this.thumb),e({targets:this.thumb,height:30,width:30,top:-30,marginLeft:i,duration:300,easing:"easeOutQuint"})}},{key:"_calcRangeOffset",value:function(){var t=this.$el.width()-15,e=parseFloat(this.$el.attr("max")),i=parseFloat(this.$el.attr("min"));return(parseFloat(this.$el.val())-i)/(e-i)*t}}],[{key:"init",value:function(t,e){return _get(s.__proto__||Object.getPrototypeOf(s),"init",this).call(this,this,t,e)}},{key:"getInstance",value:function(t){return(t.jquery?t[0]:t).M_Range}},{key:"defaults",get:function(){return i}}]),s}();M.Range=n,M.jQueryLoaded&&M.initializeJqueryWrapper(n,"range","M_Range"),n.init(t("input[type=range]"))}(cash,M.anime);
--- END FILE: .\scripts\lib\materialize.min.js ---


--- START FILE: .\scripts\lib\require.js ---
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
var requirejs,require,define;!function(global,setTimeout){function commentReplace(e,t){return t||""}function isFunction(e){return"[object Function]"===ostring.call(e)}function isArray(e){return"[object Array]"===ostring.call(e)}function each(e,t){if(e){var i;for(i=0;i<e.length&&(!e[i]||!t(e[i],i,e));i+=1);}}function eachReverse(e,t){if(e){var i;for(i=e.length-1;i>-1&&(!e[i]||!t(e[i],i,e));i-=1);}}function hasProp(e,t){return hasOwn.call(e,t)}function getOwn(e,t){return hasProp(e,t)&&e[t]}function eachProp(e,t){var i;for(i in e)if(hasProp(e,i)&&t(e[i],i))break}function mixin(e,t,i,r){return t&&eachProp(t,function(t,n){!i&&hasProp(e,n)||(!r||"object"!=typeof t||!t||isArray(t)||isFunction(t)||t instanceof RegExp?e[n]=t:(e[n]||(e[n]={}),mixin(e[n],t,i,r)))}),e}function bind(e,t){return function(){return t.apply(e,arguments)}}function scripts(){return document.getElementsByTagName("script")}function defaultOnError(e){throw e}function getGlobal(e){if(!e)return e;var t=global;return each(e.split("."),function(e){t=t[e]}),t}function makeError(e,t,i,r){var n=new Error(t+"\nhttp://requirejs.org/docs/errors.html#"+e);return n.requireType=e,n.requireModules=r,i&&(n.originalError=i),n}function newContext(e){function t(e){var t,i;for(t=0;t<e.length;t++)if("."===(i=e[t]))e.splice(t,1),t-=1;else if(".."===i){if(0===t||1===t&&".."===e[2]||".."===e[t-1])continue;t>0&&(e.splice(t-1,2),t-=2)}}function i(e,i,r){var n,o,a,s,u,c,d,p,f,l,h=i&&i.split("/"),m=y.map,g=m&&m["*"];if(e&&(c=(e=e.split("/")).length-1,y.nodeIdCompat&&jsSuffixRegExp.test(e[c])&&(e[c]=e[c].replace(jsSuffixRegExp,"")),"."===e[0].charAt(0)&&h&&(e=h.slice(0,h.length-1).concat(e)),t(e),e=e.join("/")),r&&m&&(h||g)){e:for(a=(o=e.split("/")).length;a>0;a-=1){if(u=o.slice(0,a).join("/"),h)for(s=h.length;s>0;s-=1)if((n=getOwn(m,h.slice(0,s).join("/")))&&(n=getOwn(n,u))){d=n,p=a;break e}!f&&g&&getOwn(g,u)&&(f=getOwn(g,u),l=a)}!d&&f&&(d=f,p=l),d&&(o.splice(0,p,d),e=o.join("/"))}return getOwn(y.pkgs,e)||e}function r(e){isBrowser&&each(scripts(),function(t){if(t.getAttribute("data-requiremodule")===e&&t.getAttribute("data-requirecontext")===q.contextName)return t.parentNode.removeChild(t),!0})}function n(e){var t=getOwn(y.paths,e);if(t&&isArray(t)&&t.length>1)return t.shift(),q.require.undef(e),q.makeRequire(null,{skipMap:!0})([e]),!0}function o(e){var t,i=e?e.indexOf("!"):-1;return i>-1&&(t=e.substring(0,i),e=e.substring(i+1,e.length)),[t,e]}function a(e,t,r,n){var a,s,u,c,d=null,p=t?t.name:null,f=e,l=!0,h="";return e||(l=!1,e="_@r"+(T+=1)),c=o(e),d=c[0],e=c[1],d&&(d=i(d,p,n),s=getOwn(j,d)),e&&(d?h=r?e:s&&s.normalize?s.normalize(e,function(e){return i(e,p,n)}):-1===e.indexOf("!")?i(e,p,n):e:(d=(c=o(h=i(e,p,n)))[0],h=c[1],r=!0,a=q.nameToUrl(h))),u=!d||s||r?"":"_unnormalized"+(A+=1),{prefix:d,name:h,parentMap:t,unnormalized:!!u,url:a,originalName:f,isDefine:l,id:(d?d+"!"+h:h)+u}}function s(e){var t=e.id,i=getOwn(S,t);return i||(i=S[t]=new q.Module(e)),i}function u(e,t,i){var r=e.id,n=getOwn(S,r);!hasProp(j,r)||n&&!n.defineEmitComplete?(n=s(e)).error&&"error"===t?i(n.error):n.on(t,i):"defined"===t&&i(j[r])}function c(e,t){var i=e.requireModules,r=!1;t?t(e):(each(i,function(t){var i=getOwn(S,t);i&&(i.error=e,i.events.error&&(r=!0,i.emit("error",e)))}),r||req.onError(e))}function d(){globalDefQueue.length&&(each(globalDefQueue,function(e){var t=e[0];"string"==typeof t&&(q.defQueueMap[t]=!0),O.push(e)}),globalDefQueue=[])}function p(e){delete S[e],delete k[e]}function f(e,t,i){var r=e.map.id;e.error?e.emit("error",e.error):(t[r]=!0,each(e.depMaps,function(r,n){var o=r.id,a=getOwn(S,o);!a||e.depMatched[n]||i[o]||(getOwn(t,o)?(e.defineDep(n,j[o]),e.check()):f(a,t,i))}),i[r]=!0)}function l(){var e,t,i=1e3*y.waitSeconds,o=i&&q.startTime+i<(new Date).getTime(),a=[],s=[],u=!1,d=!0;if(!x){if(x=!0,eachProp(k,function(e){var i=e.map,c=i.id;if(e.enabled&&(i.isDefine||s.push(e),!e.error))if(!e.inited&&o)n(c)?(t=!0,u=!0):(a.push(c),r(c));else if(!e.inited&&e.fetched&&i.isDefine&&(u=!0,!i.prefix))return d=!1}),o&&a.length)return e=makeError("timeout","Load timeout for modules: "+a,null,a),e.contextName=q.contextName,c(e);d&&each(s,function(e){f(e,{},{})}),o&&!t||!u||!isBrowser&&!isWebWorker||w||(w=setTimeout(function(){w=0,l()},50)),x=!1}}function h(e){hasProp(j,e[0])||s(a(e[0],null,!0)).init(e[1],e[2])}function m(e,t,i,r){e.detachEvent&&!isOpera?r&&e.detachEvent(r,t):e.removeEventListener(i,t,!1)}function g(e){var t=e.currentTarget||e.srcElement;return m(t,q.onScriptLoad,"load","onreadystatechange"),m(t,q.onScriptError,"error"),{node:t,id:t&&t.getAttribute("data-requiremodule")}}function v(){var e;for(d();O.length;){if(null===(e=O.shift())[0])return c(makeError("mismatch","Mismatched anonymous define() module: "+e[e.length-1]));h(e)}q.defQueueMap={}}var x,b,q,E,w,y={waitSeconds:7,baseUrl:"./",paths:{},bundles:{},pkgs:{},shim:{},config:{}},S={},k={},M={},O=[],j={},P={},R={},T=1,A=1;return E={require:function(e){return e.require?e.require:e.require=q.makeRequire(e.map)},exports:function(e){if(e.usingExports=!0,e.map.isDefine)return e.exports?j[e.map.id]=e.exports:e.exports=j[e.map.id]={}},module:function(e){return e.module?e.module:e.module={id:e.map.id,uri:e.map.url,config:function(){return getOwn(y.config,e.map.id)||{}},exports:e.exports||(e.exports={})}}},b=function(e){this.events=getOwn(M,e.id)||{},this.map=e,this.shim=getOwn(y.shim,e.id),this.depExports=[],this.depMaps=[],this.depMatched=[],this.pluginMaps={},this.depCount=0},b.prototype={init:function(e,t,i,r){r=r||{},this.inited||(this.factory=t,i?this.on("error",i):this.events.error&&(i=bind(this,function(e){this.emit("error",e)})),this.depMaps=e&&e.slice(0),this.errback=i,this.inited=!0,this.ignore=r.ignore,r.enabled||this.enabled?this.enable():this.check())},defineDep:function(e,t){this.depMatched[e]||(this.depMatched[e]=!0,this.depCount-=1,this.depExports[e]=t)},fetch:function(){if(!this.fetched){this.fetched=!0,q.startTime=(new Date).getTime();var e=this.map;if(!this.shim)return e.prefix?this.callPlugin():this.load();q.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],bind(this,function(){return e.prefix?this.callPlugin():this.load()}))}},load:function(){var e=this.map.url;P[e]||(P[e]=!0,q.load(this.map.id,e))},check:function(){if(this.enabled&&!this.enabling){var e,t,i=this.map.id,r=this.depExports,n=this.exports,o=this.factory;if(this.inited){if(this.error)this.emit("error",this.error);else if(!this.defining){if(this.defining=!0,this.depCount<1&&!this.defined){if(isFunction(o)){if(this.events.error&&this.map.isDefine||req.onError!==defaultOnError)try{n=q.execCb(i,o,r,n)}catch(t){e=t}else n=q.execCb(i,o,r,n);if(this.map.isDefine&&void 0===n&&((t=this.module)?n=t.exports:this.usingExports&&(n=this.exports)),e)return e.requireMap=this.map,e.requireModules=this.map.isDefine?[this.map.id]:null,e.requireType=this.map.isDefine?"define":"require",c(this.error=e)}else n=o;if(this.exports=n,this.map.isDefine&&!this.ignore&&(j[i]=n,req.onResourceLoad)){var a=[];each(this.depMaps,function(e){a.push(e.normalizedMap||e)}),req.onResourceLoad(q,this.map,a)}p(i),this.defined=!0}this.defining=!1,this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=!0)}}else hasProp(q.defQueueMap,i)||this.fetch()}},callPlugin:function(){var e=this.map,t=e.id,r=a(e.prefix);this.depMaps.push(r),u(r,"defined",bind(this,function(r){var n,o,d,f=getOwn(R,this.map.id),l=this.map.name,h=this.map.parentMap?this.map.parentMap.name:null,m=q.makeRequire(e.parentMap,{enableBuildCallback:!0});return this.map.unnormalized?(r.normalize&&(l=r.normalize(l,function(e){return i(e,h,!0)})||""),o=a(e.prefix+"!"+l,this.map.parentMap,!0),u(o,"defined",bind(this,function(e){this.map.normalizedMap=o,this.init([],function(){return e},null,{enabled:!0,ignore:!0})})),void((d=getOwn(S,o.id))&&(this.depMaps.push(o),this.events.error&&d.on("error",bind(this,function(e){this.emit("error",e)})),d.enable()))):f?(this.map.url=q.nameToUrl(f),void this.load()):((n=bind(this,function(e){this.init([],function(){return e},null,{enabled:!0})})).error=bind(this,function(e){this.inited=!0,this.error=e,e.requireModules=[t],eachProp(S,function(e){0===e.map.id.indexOf(t+"_unnormalized")&&p(e.map.id)}),c(e)}),n.fromText=bind(this,function(i,r){var o=e.name,u=a(o),d=useInteractive;r&&(i=r),d&&(useInteractive=!1),s(u),hasProp(y.config,t)&&(y.config[o]=y.config[t]);try{req.exec(i)}catch(e){return c(makeError("fromtexteval","fromText eval for "+t+" failed: "+e,e,[t]))}d&&(useInteractive=!0),this.depMaps.push(u),q.completeLoad(o),m([o],n)}),void r.load(e.name,m,n,y))})),q.enable(r,this),this.pluginMaps[r.id]=r},enable:function(){k[this.map.id]=this,this.enabled=!0,this.enabling=!0,each(this.depMaps,bind(this,function(e,t){var i,r,n;if("string"==typeof e){if(e=a(e,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap),this.depMaps[t]=e,n=getOwn(E,e.id))return void(this.depExports[t]=n(this));this.depCount+=1,u(e,"defined",bind(this,function(e){this.undefed||(this.defineDep(t,e),this.check())})),this.errback?u(e,"error",bind(this,this.errback)):this.events.error&&u(e,"error",bind(this,function(e){this.emit("error",e)}))}i=e.id,r=S[i],hasProp(E,i)||!r||r.enabled||q.enable(e,this)})),eachProp(this.pluginMaps,bind(this,function(e){var t=getOwn(S,e.id);t&&!t.enabled&&q.enable(e,this)})),this.enabling=!1,this.check()},on:function(e,t){var i=this.events[e];i||(i=this.events[e]=[]),i.push(t)},emit:function(e,t){each(this.events[e],function(e){e(t)}),"error"===e&&delete this.events[e]}},q={config:y,contextName:e,registry:S,defined:j,urlFetched:P,defQueue:O,defQueueMap:{},Module:b,makeModuleMap:a,nextTick:req.nextTick,onError:c,configure:function(e){if(e.baseUrl&&"/"!==e.baseUrl.charAt(e.baseUrl.length-1)&&(e.baseUrl+="/"),"string"==typeof e.urlArgs){var t=e.urlArgs;e.urlArgs=function(e,i){return(-1===i.indexOf("?")?"?":"&")+t}}var i=y.shim,r={paths:!0,bundles:!0,config:!0,map:!0};eachProp(e,function(e,t){r[t]?(y[t]||(y[t]={}),mixin(y[t],e,!0,!0)):y[t]=e}),e.bundles&&eachProp(e.bundles,function(e,t){each(e,function(e){e!==t&&(R[e]=t)})}),e.shim&&(eachProp(e.shim,function(e,t){isArray(e)&&(e={deps:e}),!e.exports&&!e.init||e.exportsFn||(e.exportsFn=q.makeShimExports(e)),i[t]=e}),y.shim=i),e.packages&&each(e.packages,function(e){var t;t=(e="string"==typeof e?{name:e}:e).name,e.location&&(y.paths[t]=e.location),y.pkgs[t]=e.name+"/"+(e.main||"main").replace(currDirRegExp,"").replace(jsSuffixRegExp,"")}),eachProp(S,function(e,t){e.inited||e.map.unnormalized||(e.map=a(t,null,!0))}),(e.deps||e.callback)&&q.require(e.deps||[],e.callback)},makeShimExports:function(e){return function(){var t;return e.init&&(t=e.init.apply(global,arguments)),t||e.exports&&getGlobal(e.exports)}},makeRequire:function(t,n){function o(i,r,u){var d,p,f;return n.enableBuildCallback&&r&&isFunction(r)&&(r.__requireJsBuild=!0),"string"==typeof i?isFunction(r)?c(makeError("requireargs","Invalid require call"),u):t&&hasProp(E,i)?E[i](S[t.id]):req.get?req.get(q,i,t,o):(p=a(i,t,!1,!0),d=p.id,hasProp(j,d)?j[d]:c(makeError("notloaded",'Module name "'+d+'" has not been loaded yet for context: '+e+(t?"":". Use require([])")))):(v(),q.nextTick(function(){v(),(f=s(a(null,t))).skipMap=n.skipMap,f.init(i,r,u,{enabled:!0}),l()}),o)}return n=n||{},mixin(o,{isBrowser:isBrowser,toUrl:function(e){var r,n=e.lastIndexOf("."),o=e.split("/")[0],a="."===o||".."===o;return-1!==n&&(!a||n>1)&&(r=e.substring(n,e.length),e=e.substring(0,n)),q.nameToUrl(i(e,t&&t.id,!0),r,!0)},defined:function(e){return hasProp(j,a(e,t,!1,!0).id)},specified:function(e){return e=a(e,t,!1,!0).id,hasProp(j,e)||hasProp(S,e)}}),t||(o.undef=function(e){d();var i=a(e,t,!0),n=getOwn(S,e);n.undefed=!0,r(e),delete j[e],delete P[i.url],delete M[e],eachReverse(O,function(t,i){t[0]===e&&O.splice(i,1)}),delete q.defQueueMap[e],n&&(n.events.defined&&(M[e]=n.events),p(e))}),o},enable:function(e){getOwn(S,e.id)&&s(e).enable()},completeLoad:function(e){var t,i,r,o=getOwn(y.shim,e)||{},a=o.exports;for(d();O.length;){if(null===(i=O.shift())[0]){if(i[0]=e,t)break;t=!0}else i[0]===e&&(t=!0);h(i)}if(q.defQueueMap={},r=getOwn(S,e),!t&&!hasProp(j,e)&&r&&!r.inited){if(!(!y.enforceDefine||a&&getGlobal(a)))return n(e)?void 0:c(makeError("nodefine","No define call for "+e,null,[e]));h([e,o.deps||[],o.exportsFn])}l()},nameToUrl:function(e,t,i){var r,n,o,a,s,u,c,d=getOwn(y.pkgs,e);if(d&&(e=d),c=getOwn(R,e))return q.nameToUrl(c,t,i);if(req.jsExtRegExp.test(e))s=e+(t||"");else{for(r=y.paths,o=(n=e.split("/")).length;o>0;o-=1)if(a=n.slice(0,o).join("/"),u=getOwn(r,a)){isArray(u)&&(u=u[0]),n.splice(0,o,u);break}s=n.join("/"),s=("/"===(s+=t||(/^data\:|^blob\:|\?/.test(s)||i?"":".js")).charAt(0)||s.match(/^[\w\+\.\-]+:/)?"":y.baseUrl)+s}return y.urlArgs&&!/^blob\:/.test(s)?s+y.urlArgs(e,s):s},load:function(e,t){req.load(q,e,t)},execCb:function(e,t,i,r){return t.apply(r,i)},onScriptLoad:function(e){if("load"===e.type||readyRegExp.test((e.currentTarget||e.srcElement).readyState)){interactiveScript=null;var t=g(e);q.completeLoad(t.id)}},onScriptError:function(e){var t=g(e);if(!n(t.id)){var i=[];return eachProp(S,function(e,r){0!==r.indexOf("_@r")&&each(e.depMaps,function(e){if(e.id===t.id)return i.push(r),!0})}),c(makeError("scripterror",'Script error for "'+t.id+(i.length?'", needed by: '+i.join(", "):'"'),e,[t.id]))}}},q.require=q.makeRequire(),q}function getInteractiveScript(){return interactiveScript&&"interactive"===interactiveScript.readyState?interactiveScript:(eachReverse(scripts(),function(e){if("interactive"===e.readyState)return interactiveScript=e}),interactiveScript)}var req,s,head,baseElement,dataMain,src,interactiveScript,currentlyAddingScript,mainScript,subPath,version="2.3.5",commentRegExp=/\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/gm,cjsRequireRegExp=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,jsSuffixRegExp=/\.js$/,currDirRegExp=/^\.\//,op=Object.prototype,ostring=op.toString,hasOwn=op.hasOwnProperty,isBrowser=!("undefined"==typeof window||"undefined"==typeof navigator||!window.document),isWebWorker=!isBrowser&&"undefined"!=typeof importScripts,readyRegExp=isBrowser&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,defContextName="_",isOpera="undefined"!=typeof opera&&"[object Opera]"===opera.toString(),contexts={},cfg={},globalDefQueue=[],useInteractive=!1;if(void 0===define){if(void 0!==requirejs){if(isFunction(requirejs))return;cfg=requirejs,requirejs=void 0}void 0===require||isFunction(require)||(cfg=require,require=void 0),req=requirejs=function(e,t,i,r){var n,o,a=defContextName;return isArray(e)||"string"==typeof e||(o=e,isArray(t)?(e=t,t=i,i=r):e=[]),o&&o.context&&(a=o.context),(n=getOwn(contexts,a))||(n=contexts[a]=req.s.newContext(a)),o&&n.configure(o),n.require(e,t,i)},req.config=function(e){return req(e)},req.nextTick=void 0!==setTimeout?function(e){setTimeout(e,4)}:function(e){e()},require||(require=req),req.version=version,req.jsExtRegExp=/^\/|:|\?|\.js$/,req.isBrowser=isBrowser,s=req.s={contexts:contexts,newContext:newContext},req({}),each(["toUrl","undef","defined","specified"],function(e){req[e]=function(){var t=contexts[defContextName];return t.require[e].apply(t,arguments)}}),isBrowser&&(head=s.head=document.getElementsByTagName("head")[0],(baseElement=document.getElementsByTagName("base")[0])&&(head=s.head=baseElement.parentNode)),req.onError=defaultOnError,req.createNode=function(e,t,i){var r=e.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script");return r.type=e.scriptType||"text/javascript",r.charset="utf-8",r.async=!0,r},req.load=function(e,t,i){var r,n=e&&e.config||{};if(isBrowser)return(r=req.createNode(n,t,i)).setAttribute("data-requirecontext",e.contextName),r.setAttribute("data-requiremodule",t),!r.attachEvent||r.attachEvent.toString&&r.attachEvent.toString().indexOf("[native code")<0||isOpera?(r.addEventListener("load",e.onScriptLoad,!1),r.addEventListener("error",e.onScriptError,!1)):(useInteractive=!0,r.attachEvent("onreadystatechange",e.onScriptLoad)),r.src=i,n.onNodeCreated&&n.onNodeCreated(r,n,t,i),currentlyAddingScript=r,baseElement?head.insertBefore(r,baseElement):head.appendChild(r),currentlyAddingScript=null,r;if(isWebWorker)try{setTimeout(function(){},0),importScripts(i),e.completeLoad(t)}catch(r){e.onError(makeError("importscripts","importScripts failed for "+t+" at "+i,r,[t]))}},isBrowser&&!cfg.skipDataMain&&eachReverse(scripts(),function(e){if(head||(head=e.parentNode),dataMain=e.getAttribute("data-main"))return mainScript=dataMain,cfg.baseUrl||-1!==mainScript.indexOf("!")||(src=mainScript.split("/"),mainScript=src.pop(),subPath=src.length?src.join("/")+"/":"./",cfg.baseUrl=subPath),mainScript=mainScript.replace(jsSuffixRegExp,""),req.jsExtRegExp.test(mainScript)&&(mainScript=dataMain),cfg.deps=cfg.deps?cfg.deps.concat(mainScript):[mainScript],!0}),define=function(e,t,i){var r,n;"string"!=typeof e&&(i=t,t=e,e=null),isArray(t)||(i=t,t=null),!t&&isFunction(i)&&(t=[],i.length&&(i.toString().replace(commentRegExp,commentReplace).replace(cjsRequireRegExp,function(e,i){t.push(i)}),t=(1===i.length?["require"]:["require","exports","module"]).concat(t))),useInteractive&&(r=currentlyAddingScript||getInteractiveScript())&&(e||(e=r.getAttribute("data-requiremodule")),n=contexts[r.getAttribute("data-requirecontext")]),n?(n.defQueue.push([e,t,i]),n.defQueueMap[e]=!0):globalDefQueue.push([e,t,i])},define.amd={jQuery:!0},req.exec=function(text){return eval(text)},req(cfg)}}(this,"undefined"==typeof setTimeout?void 0:setTimeout);
--- END FILE: .\scripts\lib\require.js ---


--- START FILE: .\scripts\lib\saveSvgAsPng.js ---
(function() {
  var out$ = typeof exports != 'undefined' && exports || typeof define != 'undefined' && {} || this;

  var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" [<!ENTITY nbsp "&#160;">]>';

  function isElement(obj) {
    return obj instanceof HTMLElement || obj instanceof SVGElement;
  }

  function requireDomNode(el) {
    if (!isElement(el)) {
      throw new Error('an HTMLElement or SVGElement is required; got ' + el);
    }
  }

  function isExternal(url) {
    return url && url.lastIndexOf('http',0) == 0 && url.lastIndexOf(window.location.host) == -1;
  }

  function inlineImages(el, callback) {
    requireDomNode(el);

    var images = el.querySelectorAll('image'),
        left = images.length,
        checkDone = function() {
          if (left === 0) {
            callback();
          }
        };

    checkDone();
    for (var i = 0; i < images.length; i++) {
      (function(image) {
        var href = image.getAttributeNS("http://www.w3.org/1999/xlink", "href");
        if (href) {
          if (isExternal(href.value)) {
            console.warn("Cannot render embedded images linking to external hosts: "+href.value);
            return;
          }
        }
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.crossOrigin="anonymous";
        href = href || image.getAttribute('href');
        if (href) {
          img.src = href;
          img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            image.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL('image/png'));
            left--;
            checkDone();
          }
          img.onerror = function() {
            console.log("Could not load "+href);
            left--;
            checkDone();
          }
        } else {
          left--;
          checkDone();
        }
      })(images[i]);
    }
  }

  function styles(el, options, cssLoadedCallback) {
    var selectorRemap = options.selectorRemap;
    var modifyStyle = options.modifyStyle;
    var modifyCss = options.modifyCss || function(selector, properties) {
      var selector = selectorRemap ? selectorRemap(selector) : selector;
      var cssText = modifyStyle ? modifyStyle(properties) : properties;
      return selector + " { " + cssText + " }\n";
    };
    var css = "";

    // Each font that has an external link is saved into queue, and processed asynchronously.
    var fontsQueue = [];
    var sheets = document.styleSheets;
    for (var i = 0; i < sheets.length; i++) {
      try {
        var rules = sheets[i].cssRules;
      } catch (e) {
        console.warn("Stylesheet could not be loaded: "+sheets[i].href);
        continue;
      }

      if (rules != null) {
        for (var j = 0, match; j < rules.length; j++, match = null) {
          var rule = rules[j];
          if (typeof(rule.style) != "undefined") {
            var selectorText;

            try {
              selectorText = rule.selectorText;
            } catch(err) {
              console.warn('The following CSS rule has an invalid selector: "' + rule + '"', err);
            }

            try {
              if (selectorText) {
                match = el.querySelector(selectorText) || (el.parentNode && el.parentNode.querySelector(selectorText));
              }
            } catch(err) {
              console.warn('Invalid CSS selector "' + selectorText + '"', err);
            }

            if (match) {
              css += modifyCss(rule.selectorText, rule.style.cssText);
            } else if(rule.cssText.match(/^@font-face/)) {
              // below we are trying to find matches to external link. E.g.
              // @font-face {
              //   // ...
              //   src: local('Abel'), url(https://fonts.gstatic.com/s/abel/v6/UzN-iejR1VoXU2Oc-7LsbvesZW2xOQ-xsNqO47m55DA.woff2);
              // }
              //
              // This regex will save extrnal link into first capture group
              var fontUrlRegexp = /url\(["']?(.+?)["']?\)/;
              // TODO: This needs to be changed to support multiple url declarations per font.
              var fontUrlMatch = rule.cssText.match(fontUrlRegexp);

              var externalFontUrl = (fontUrlMatch && fontUrlMatch[1]) || '';
              var fontUrlIsDataURI = externalFontUrl.match(/^data:/);
              if (fontUrlIsDataURI) {
                // We should ignore data uri - they are already embedded
                externalFontUrl = '';
              }

              if (externalFontUrl === 'about:blank') {
                // no point trying to load this
                externalFontUrl = '';
              }

              if (externalFontUrl) {
                // okay, we are lucky. We can fetch this font later

                //handle url if relative
                if (externalFontUrl.startsWith('../')) {
                  externalFontUrl = sheets[i].href + '/../' + externalFontUrl
                } else if (externalFontUrl.startsWith('./')) {
                  externalFontUrl = sheets[i].href + '/.' + externalFontUrl
                }

                fontsQueue.push({
                  text: rule.cssText,
                  // Pass url regex, so that once font is downladed, we can run `replace()` on it
                  fontUrlRegexp: fontUrlRegexp,
                  format: getFontMimeTypeFromUrl(externalFontUrl),
                  url: externalFontUrl
                });
              } else {
                // otherwise, use previous logic
                css += rule.cssText + '\n';
              }
            }
          }
        }
      }
    }

    // Now all css is processed, it's time to handle scheduled fonts
    processFontQueue(fontsQueue);

    function getFontMimeTypeFromUrl(fontUrl) {
      var supportedFormats = {
        'woff2': 'font/woff2',
        'woff': 'font/woff',
        'otf': 'application/x-font-opentype',
        'ttf': 'application/x-font-ttf',
        'eot': 'application/vnd.ms-fontobject',
        'sfnt': 'application/font-sfnt',
        'svg': 'image/svg+xml'
      };
      var extensions = Object.keys(supportedFormats);
      for (var i = 0; i < extensions.length; ++i) {
        var extension = extensions[i];
        // TODO: This is not bullet proof, it needs to handle edge cases...
        if (fontUrl.indexOf('.' + extension) > 0) {
          return supportedFormats[extension];
        }
      }

      // If you see this error message, you probably need to update code above.
      console.error('Unknown font format for ' + fontUrl+ '; Fonts may not be working correctly');
      return 'application/octet-stream';
    }

    function processFontQueue(queue) {
      if (queue.length > 0) {
        // load fonts one by one until we have anything in the queue:
        var font = queue.pop();
        processNext(font);
      } else {
        // no more fonts to load.
        cssLoadedCallback(css);
      }

      function processNext(font) {
        // TODO: This could benefit from caching.
        var oReq = new XMLHttpRequest();
        oReq.addEventListener('load', fontLoaded);
        oReq.addEventListener('error', transferFailed);
        oReq.addEventListener('abort', transferFailed);
        oReq.open('GET', font.url);
        oReq.responseType = 'arraybuffer';
        oReq.send();

        function fontLoaded() {
          // TODO: it may be also worth to wait until fonts are fully loaded before
          // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet )
          var fontBits = oReq.response;
          var fontInBase64 = arrayBufferToBase64(fontBits);
          updateFontStyle(font, fontInBase64);
        }

        function transferFailed(e) {
          console.warn('Failed to load font from: ' + font.url);
          console.warn(e)
          css += font.text + '\n';
          processFontQueue(queue);
        }

        function updateFontStyle(font, fontInBase64) {
          var dataUrl = 'url("data:' + font.format + ';base64,' + fontInBase64 + '")';
          css += font.text.replace(font.fontUrlRegexp, dataUrl) + '\n';

          // schedule next font download on next tick.
          setTimeout(function() {
            processFontQueue(queue)
          }, 0);
        }

      }
    }

    function arrayBufferToBase64(buffer) {
      var binary = '';
      var bytes = new Uint8Array(buffer);
      var len = bytes.byteLength;

      for (var i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
      }

      return window.btoa(binary);
    }
  }

  function getDimension(el, clone, dim) {
    var v = (el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim]) ||
      (clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim))) ||
      el.getBoundingClientRect()[dim] ||
      parseInt(clone.style[dim]) ||
      parseInt(window.getComputedStyle(el).getPropertyValue(dim));
    return (typeof v === 'undefined' || v === null || isNaN(parseFloat(v))) ? 0 : v;
  }

  function reEncode(data) {
    data = encodeURIComponent(data);
    data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {
      var c = String.fromCharCode('0x'+p1);
      return c === '%' ? '%25' : c;
    });
    return decodeURIComponent(data);
  }

  out$.prepareSvg = function(el, options, cb) {
    requireDomNode(el);

    options = options || {};
    options.scale = options.scale || 1;
    options.responsive = options.responsive || false;
    var xmlns = "http://www.w3.org/2000/xmlns/";

    inlineImages(el, function() {
      var outer = document.createElement("div");
      var clone = el.cloneNode(true);
      var width, height;
      if(el.tagName == 'svg') {
        width = options.width || getDimension(el, clone, 'width');
        height = options.height || getDimension(el, clone, 'height');
      } else if(el.getBBox) {
        var box = el.getBBox();
        width = box.x + box.width;
        height = box.y + box.height;
        clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\(.*?\)/, ''));

        var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')
        svg.appendChild(clone)
        clone = svg;
      } else {
        console.error('Attempted to render non-SVG element', el);
        return;
      }

      clone.setAttribute("version", "1.1");
      if (!clone.getAttribute('xmlns')) {
        clone.setAttributeNS(xmlns, "xmlns", "http://www.w3.org/2000/svg");
      }
      if (!clone.getAttribute('xmlns:xlink')) {
        clone.setAttributeNS(xmlns, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      }

      if (options.responsive) {
        clone.removeAttribute('width');
        clone.removeAttribute('height');
        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      } else {
        clone.setAttribute("width", width * options.scale);
        clone.setAttribute("height", height * options.scale);
      }

      clone.setAttribute("viewBox", [
        options.left || 0,
        options.top || 0,
        width,
        height
      ].join(" "));

      var fos = clone.querySelectorAll('foreignObject > *');
      for (var i = 0; i < fos.length; i++) {
        if (!fos[i].getAttribute('xmlns')) {
          fos[i].setAttributeNS(xmlns, "xmlns", "http://www.w3.org/1999/xhtml");
        }
      }

      outer.appendChild(clone);

      // In case of custom fonts we need to fetch font first, and then inline
      // its url into data-uri format (encode as base64). That's why style
      // processing is done asynchonously. Once all inlining is finshed
      // cssLoadedCallback() is called.
      styles(el, options, cssLoadedCallback);

      function cssLoadedCallback(css) {
        // here all fonts are inlined, so that we can render them properly.
        var s = document.createElement('style');
        s.setAttribute('type', 'text/css');
        s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
        var defs = document.createElement('defs');
        defs.appendChild(s);
        clone.insertBefore(defs, clone.firstChild);

        if (cb) {
          var outHtml = outer.innerHTML;
          outHtml = outHtml.replace(/NS\d+:href/gi, 'xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href');
          cb(outHtml, width, height);
        }
      }
    });
  }

  out$.svgAsDataUri = function(el, options, cb) {
    out$.prepareSvg(el, options, function(svg) {
      var uri = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + svg));
      if (cb) {
        cb(uri);
      }
    });
  }

  out$.svgAsPngUri = function(el, options, cb) {
    requireDomNode(el);

    options = options || {};
    options.encoderType = options.encoderType || 'image/png';
    options.encoderOptions = options.encoderOptions || 0.8;

    var convertToPng = function(src, w, h) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = w;
      canvas.height = h;

      var pixelRatio = window.devicePixelRatio || 1;

      canvas.style.width = canvas.width+'px';
      canvas.style.height = canvas.height+'px';
      canvas.width *= pixelRatio;
      canvas.height *= pixelRatio;

      context.setTransform(pixelRatio,0,0,pixelRatio,0,0);

      if(options.canvg) {
        options.canvg(canvas, src);
      } else {
        context.drawImage(src, 0, 0);
      }

      if(options.backgroundColor){
        context.globalCompositeOperation = 'destination-over';
        context.fillStyle = options.backgroundColor;
        context.fillRect(0, 0, canvas.width, canvas.height);
      }

      var png;
      try {
        png = canvas.toDataURL(options.encoderType, options.encoderOptions);
      } catch (e) {
        if ((typeof SecurityError !== 'undefined' && e instanceof SecurityError) || e.name == "SecurityError") {
          console.error("Rendered SVG images cannot be downloaded in this browser.");
          return;
        } else {
          throw e;
        }
      }
      cb(png);
    }

    if(options.canvg) {
      out$.prepareSvg(el, options, convertToPng);
    } else {
      out$.svgAsDataUri(el, options, function(uri) {
        var image = new Image();

        image.onload = function() {
          convertToPng(image, image.width, image.height);
        }

        image.onerror = function() {
          console.error(
            'There was an error loading the data URI as an image on the following SVG\n',
            window.atob(uri.slice(26)), '\n',
            "Open the following link to see browser's diagnosis\n",
            uri);
        }

        image.src = uri;
      });
    }
  }

  out$.download = function(name, uri) {
    if (navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(uriToBlob(uri), name);
    } else {
      var saveLink = document.createElement('a');
      var downloadSupported = 'download' in saveLink;
      if (downloadSupported) {
        saveLink.download = name;
        saveLink.style.display = 'none';
        document.body.appendChild(saveLink);
        try {
          var blob = uriToBlob(uri);
          var url = URL.createObjectURL(blob);
          saveLink.href = url;
          saveLink.onclick = function() {
            requestAnimationFrame(function() {
              URL.revokeObjectURL(url);
            })
          };
        } catch (e) {
          console.warn('This browser does not support object URLs. Falling back to string URL.');
          saveLink.href = uri;
        }
        saveLink.click();
        document.body.removeChild(saveLink);
      }
      else {
        window.open(uri, '_temp', 'menubar=no,toolbar=no,status=no');
      }
    }
  }

  function uriToBlob(uri) {
    var byteString = window.atob(uri.split(',')[1]);
    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0]
    var buffer = new ArrayBuffer(byteString.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < byteString.length; i++) {
      intArray[i] = byteString.charCodeAt(i);
    }
    return new Blob([buffer], {type: mimeString});
  }

  out$.saveSvg = function(el, name, options) {
    requireDomNode(el);

    options = options || {};
    out$.svgAsDataUri(el, options, function(uri) {
      out$.download(name, uri);
    });
  }

  out$.saveSvgAsPng = function(el, name, options) {
    requireDomNode(el);

    options = options || {};
    out$.svgAsPngUri(el, options, function(uri) {
      out$.download(name, uri);
    });
  }

  // if define is defined create as an AMD module
  if (typeof define !== 'undefined') {
    define(function() {
      return out$;
    });
  }

})();

--- END FILE: .\scripts\lib\saveSvgAsPng.js ---


--- START FILE: .\src\colorreductionmanagement.ts ---
/**
 * Color reduction management of the process: clustering to reduce colors & creating color map
 */
import { delay, IMap, RGB } from "./common";
import { KMeans, Vector } from "./lib/clustering";
import { hslToRgb, lab2rgb, rgb2lab, rgbToHsl } from "./lib/colorconversion";
import { ClusteringColorSpace, Settings } from "./settings";
import { Uint8Array2D } from "./structs/typedarrays";
import { Random } from "./random";

export class ColorMapResult {
    public imgColorIndices!: Uint8Array2D;
    public colorsByIndex!: RGB[];
    public width!: number;
    public height!: number;
}

export class ColorReducer {

    /**
     *  Creates a map of the various colors used
     */
    public static createColorMap(kmeansImgData: ImageData) {
        const imgColorIndices = new Uint8Array2D(kmeansImgData.width, kmeansImgData.height);
        let colorIndex = 0;
        const colors: IMap<number> = {};
        const colorsByIndex: RGB[] = [];

        let idx = 0;
        for (let j: number = 0; j < kmeansImgData.height; j++) {
            for (let i: number = 0; i < kmeansImgData.width; i++) {
                const r = kmeansImgData.data[idx++];
                const g = kmeansImgData.data[idx++];
                const b = kmeansImgData.data[idx++];
                const a = kmeansImgData.data[idx++];
                let currentColorIndex;
                const color = r + "," + g + "," + b;
                if (typeof colors[color] === "undefined") {
                    currentColorIndex = colorIndex;
                    colors[color] = colorIndex;
                    colorsByIndex.push([r, g, b]);
                    colorIndex++;
                } else {
                    currentColorIndex = colors[color];
                }
                imgColorIndices.set(i, j, currentColorIndex);
            }
        }

        const result = new ColorMapResult();
        result.imgColorIndices = imgColorIndices;
        result.colorsByIndex = colorsByIndex;
        result.width = kmeansImgData.width;
        result.height = kmeansImgData.height;

        return result;
    }

    /**
     *  Applies K-means clustering on the imgData to reduce the colors to
     *  k clusters and then output the result to the given outputImgData
     */
    public static async applyKMeansClustering(imgData: ImageData, outputImgData: ImageData, ctx: CanvasRenderingContext2D, settings: Settings, onUpdate: ((kmeans: KMeans) => void) | null = null) {
        const vectors: Vector[] = [];
        let idx = 0;
        let vIdx = 0;

        const bitsToChopOff = 2; // r,g,b gets rounded to every 4 values, 0,4,8,...

        // group by color, add points as 1D index to prevent Point object allocation
        const pointsByColor: IMap<number[]> = {};
        for (let j: number = 0; j < imgData.height; j++) {
            for (let i: number = 0; i < imgData.width; i++) {
                let r = imgData.data[idx++];
                let g = imgData.data[idx++];
                let b = imgData.data[idx++];
                const a = imgData.data[idx++];

                // small performance boost: reduce bitness of colors by chopping off the last bits
                // this will group more colors with only slight variation in color together, reducing the size of the points

                r = r >> bitsToChopOff << bitsToChopOff;
                g = g >> bitsToChopOff << bitsToChopOff;
                b = b >> bitsToChopOff << bitsToChopOff;

                const color = `${r},${g},${b}`;
                if (!(color in pointsByColor)) {
                    pointsByColor[color] = [j * imgData.width + i];
                } else {
                    pointsByColor[color].push(j * imgData.width + i);
                }
            }
        }

        for (const color of Object.keys(pointsByColor)) {
            const rgb: number[] = color.split(",").map((v) => parseInt(v));

            // determine vector data based on color space conversion
            let data: number[];
            if (settings.kMeansClusteringColorSpace === ClusteringColorSpace.RGB) {
                data = rgb;
            } else if (settings.kMeansClusteringColorSpace === ClusteringColorSpace.HSL) {
                data = rgbToHsl(rgb[0], rgb[1], rgb[2]);
            } else if (settings.kMeansClusteringColorSpace === ClusteringColorSpace.LAB) {
                data = rgb2lab(rgb);
            } else {
                data = rgb;
            }
            // determine the weight (#pointsOfColor / #totalpoints) of each color
            const weight = pointsByColor[color].length / (imgData.width * imgData.height);

            const vec = new Vector(data, weight);
            vec.tag = rgb;
            vectors[vIdx++] = vec;
        }

        const random = new Random(settings.randomSeed === 0 ? new Date().getTime() : settings.randomSeed);
        // vectors of all the unique colors are built, time to cluster them
        const kmeans = new KMeans(vectors, settings.kMeansNrOfClusters, random);

        let curTime = new Date().getTime();

        kmeans.step();
        while (kmeans.currentDeltaDistanceDifference > settings.kMeansMinDeltaDifference) {
            kmeans.step();

            // update GUI every 500ms
            if (new Date().getTime() - curTime > 500) {
                curTime = new Date().getTime();

                await delay(0);
                if (onUpdate != null) {
                    ColorReducer.updateKmeansOutputImageData(kmeans, settings, pointsByColor, imgData, outputImgData, false);
                    onUpdate(kmeans);
                }
            }

        }

        // update the output image data (because it will be used for further processing)
        ColorReducer.updateKmeansOutputImageData(kmeans, settings, pointsByColor, imgData, outputImgData, true);

        if (onUpdate != null) {
            onUpdate(kmeans);
        }
    }

    /**
     *  Updates the image data from the current kmeans centroids and their respective associated colors (vectors)
     */
    public static updateKmeansOutputImageData(kmeans: KMeans, settings: Settings, pointsByColor: IMap<number[]>, imgData: ImageData, outputImgData: ImageData, restrictToSpecifiedColors: boolean) {

        for (let c: number = 0; c < kmeans.centroids.length; c++) {
            // for each cluster centroid
            const centroid = kmeans.centroids[c];

            // points per category are the different unique colors belonging to that cluster
            for (const v of kmeans.pointsPerCategory[c]) {

                // determine the rgb color value of the cluster centroid
                let rgb: number[];
                if (settings.kMeansClusteringColorSpace === ClusteringColorSpace.RGB) {
                    rgb = centroid.values;
                } else if (settings.kMeansClusteringColorSpace === ClusteringColorSpace.HSL) {
                    const hsl = centroid.values;
                    rgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
                } else if (settings.kMeansClusteringColorSpace === ClusteringColorSpace.LAB) {
                    const lab = centroid.values;
                    rgb = lab2rgb(lab);
                } else {
                    rgb = centroid.values;
                }

                 // remove decimals
                 rgb = rgb.map(v => Math.floor(v));

                if (restrictToSpecifiedColors) {
                    if (settings.kMeansColorRestrictions.length > 0) {
                        // there are color restrictions, for each centroid find the color from the color restrictions that's the closest
                        let minDistance = Number.MAX_VALUE;
                        let closestRestrictedColor: RGB | string | null = null;
                        for (const color of settings.kMeansColorRestrictions) {
                            // RGB distance is not very good for the human eye perception, convert both to lab and then calculate the distance
                            const centroidLab = rgb2lab(rgb);

                            let restrictionLab: number[];
                            if (typeof color === "string") {
                                restrictionLab = rgb2lab(settings.colorAliases[color]);
                            } else {
                                restrictionLab = rgb2lab(color);
                            }

                            const distance = Math.sqrt((centroidLab[0] - restrictionLab[0]) * (centroidLab[0] - restrictionLab[0]) +
                                (centroidLab[1] - restrictionLab[1]) * (centroidLab[1] - restrictionLab[1]) +
                                (centroidLab[2] - restrictionLab[2]) * (centroidLab[2] - restrictionLab[2]));
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestRestrictedColor = color;
                            }
                        }
                        // use this color instead
                        if (closestRestrictedColor !== null) {
                            if (typeof closestRestrictedColor === "string") {
                                rgb = settings.colorAliases[closestRestrictedColor];
                            } else {
                                rgb = closestRestrictedColor;
                            }
                        }
                    }
                }

                let pointRGB: number[] = v.tag;

                // replace all pixels of the old color by the new centroid color
                const pointColor = `${Math.floor(pointRGB[0])},${Math.floor(pointRGB[1])},${Math.floor(pointRGB[2])}`;
                for (const pt of pointsByColor[pointColor]) {
                    const ptx = pt % imgData.width;
                    const pty = Math.floor(pt / imgData.width);
                    let dataOffset = (pty * imgData.width + ptx) * 4;
                    outputImgData.data[dataOffset++] = rgb[0];
                    outputImgData.data[dataOffset++] = rgb[1];
                    outputImgData.data[dataOffset++] = rgb[2];
                }
            }
        }
    }

    /**
     *  Builds a distance matrix for each color to each other
     */
    public static buildColorDistanceMatrix(colorsByIndex: RGB[]) {
        const colorDistances: number[][] = new Array(colorsByIndex.length);
        for (let j: number = 0; j < colorsByIndex.length; j++) {
            colorDistances[j] = new Array(colorDistances.length);
        }
        for (let j: number = 0; j < colorsByIndex.length; j++) {
            for (let i: number = j; i < colorsByIndex.length; i++) {
                const c1 = colorsByIndex[j];
                const c2 = colorsByIndex[i];
                const distance = Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) +
                    (c1[1] - c2[1]) * (c1[1] - c2[1]) +
                    (c1[2] - c2[2]) * (c1[2] - c2[2]));
                colorDistances[i][j] = distance;
                colorDistances[j][i] = distance;
            }
        }
        return colorDistances;
    }

    public static async processNarrowPixelStripCleanup(colormapResult: ColorMapResult) {
        // build the color distance matrix, which describes the distance of each color to each other
        const colorDistances: number[][] = ColorReducer.buildColorDistanceMatrix(colormapResult.colorsByIndex);

        let count = 0;
        const imgColorIndices = colormapResult.imgColorIndices;
        for (let j: number = 1; j < colormapResult.height - 1; j++) {
            for (let i: number = 1; i < colormapResult.width - 1; i++) {
                const top = imgColorIndices.get(i, j - 1);
                const bottom = imgColorIndices.get(i, j + 1);
                const left = imgColorIndices.get(i - 1, j);
                const right = imgColorIndices.get(i + 1, j);
                const cur = imgColorIndices.get(i, j);
                if (cur !== top && cur !== bottom && cur !== left && cur !== right) {
                    // single pixel
                } else if (cur !== top && cur !== bottom) {
                    // check the color distance whether the top or bottom color is closer
                    const topColorDistance = colorDistances[cur][top];
                    const bottomColorDistance = colorDistances[cur][bottom];
                    imgColorIndices.set(i, j, topColorDistance < bottomColorDistance ? top : bottom);
                    count++;
                } else if (cur !== left && cur !== right) {
                    // check the color distance whether the top or bottom color is closer
                    const leftColorDistance = colorDistances[cur][left];
                    const rightColorDistance = colorDistances[cur][right];
                    imgColorIndices.set(i, j, leftColorDistance < rightColorDistance ? left : right);
                    count++;
                }
            }
        }
        console.log(count + " pixels replaced to remove narrow pixel strips");
    }
}

--- END FILE: .\src\colorreductionmanagement.ts ---


--- START FILE: .\src\common.ts ---

export type RGB = number[];

export interface IMap<T> {
    [key: string]: T;
}

export async function delay(ms: number) {
    if (typeof window !== "undefined") {
        return new Promise((exec) => (<any> window).setTimeout(exec, ms));
    } else {
        return new Promise((exec) => exec());
    }
}

export class CancellationToken {
    public isCancelled: boolean = false;
}

--- END FILE: .\src\common.ts ---


--- START FILE: .\src\facetBorderSegmenter.ts ---
import { delay } from "./common";
import { Point } from "./structs/point";
import { FacetResult, PathPoint, OrientationEnum } from "./facetmanagement";


/**
 *  Path segment is a segment of a border path that is adjacent to a specific neighbour facet
 */
export class PathSegment {
    constructor(public points: PathPoint[], public neighbour: number) {

    }
}


/**
 * Facet boundary segment describes the matched segment that is shared between 2 facets
 * When 2 segments are matched, one will be the original segment and the other one is removed
 * This ensures that all facets share the same segments, but sometimes in reverse order to ensure
 * the correct continuity of its entire oborder path
 */
export class FacetBoundarySegment {
    constructor(public originalSegment: PathSegment, public neighbour: number, public reverseOrder: boolean) {

    }
}

export class FacetBorderSegmenter {
    /**
     *  Builds border segments that are shared between facets
     *  While border paths are all nice and fancy, they are not linked to neighbour facets
     *  So any change in the paths makes a not so nice gap between the facets, which makes smoothing them out impossible
     */
    public static async buildFacetBorderSegments(facetResult: FacetResult, nrOfTimesToHalvePoints: number = 2, onUpdate: ((progress: number) => void) | null = null) {
        // first chop up the border path in segments each time the neighbour at that point changes
        // (and sometimes even when it doesn't on that side but does on the neighbour's side)
        const segmentsPerFacet: Array<Array<PathSegment | null>> = FacetBorderSegmenter.prepareSegmentsPerFacet(facetResult);
        // now reduce the segment complexity with Haar wavelet reduction to smooth them out and make them
        // more curvy with data points instead of zig zag of a grid
        FacetBorderSegmenter.reduceSegmentComplexity(facetResult, segmentsPerFacet, nrOfTimesToHalvePoints);
        // now see which segments of facets with the prepared segments of the neighbour facets
        // and point them to the same one
        await FacetBorderSegmenter.matchSegmentsWithNeighbours(facetResult, segmentsPerFacet, onUpdate);
    }

    /**
     *  Chops up the border paths per facet into segments adjacent tothe same neighbour
     */
    private static prepareSegmentsPerFacet(facetResult: FacetResult) {
        const segmentsPerFacet: Array<Array<PathSegment | null>> = new Array(facetResult.facets.length);
        for (const f of facetResult.facets) {
            if (f != null) {
                const segments: PathSegment[] = [];
                if (f.borderPath.length > 1) {
                    let currentPoints: PathPoint[] = [];
                    currentPoints.push(f.borderPath[0]);
                    for (let i: number = 1; i < f.borderPath.length; i++) {
                        const prevBorderPoint = f.borderPath[i - 1];
                        const curBorderPoint = f.borderPath[i];
                        const oldNeighbour = prevBorderPoint.getNeighbour(facetResult);
                        const curNeighbour = curBorderPoint.getNeighbour(facetResult);
                        let isTransitionPoint = false;
                        if (oldNeighbour !== curNeighbour) {
                            isTransitionPoint = true;
                        }
                        else {
                            // it's possible that due to inner facets inside the current facet that the
                            // border is interrupted on that facet's side, but not on the neighbour's side
                            if (oldNeighbour !== -1) {
                                // check for tight rotations to break path if diagonals contain a different neighbour,
                                // see https://i.imgur.com/o6Srqwj.png for visual path of the issue
                                if (prevBorderPoint.x === curBorderPoint.x &&
                                    prevBorderPoint.y === curBorderPoint.y) {
                                    // rotation turn
                                    // check the diagonal neighbour to see if it remains the same
                                    //   +---+---+
                                    //   | dN|   |
                                    //   +---xxxx> (x = wall, dN = diagNeighbour)
                                    //   |   x f |
                                    //   +---v---+
                                    if ((prevBorderPoint.orientation === OrientationEnum.Top && curBorderPoint.orientation === OrientationEnum.Left) ||
                                        (prevBorderPoint.orientation === OrientationEnum.Left && curBorderPoint.orientation === OrientationEnum.Top)) {
                                        const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x - 1, curBorderPoint.y - 1);
                                        if (diagNeighbour !== oldNeighbour) {
                                            isTransitionPoint = true;
                                        }
                                    }
                                    else if ((prevBorderPoint.orientation === OrientationEnum.Top && curBorderPoint.orientation === OrientationEnum.Right) ||
                                        (prevBorderPoint.orientation === OrientationEnum.Right && curBorderPoint.orientation === OrientationEnum.Top)) {
                                        const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x + 1, curBorderPoint.y - 1);
                                        if (diagNeighbour !== oldNeighbour) {
                                            isTransitionPoint = true;
                                        }
                                    }
                                    else if ((prevBorderPoint.orientation === OrientationEnum.Bottom && curBorderPoint.orientation === OrientationEnum.Left) ||
                                        (prevBorderPoint.orientation === OrientationEnum.Left && curBorderPoint.orientation === OrientationEnum.Bottom)) {
                                        const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x - 1, curBorderPoint.y + 1);
                                        if (diagNeighbour !== oldNeighbour) {
                                            isTransitionPoint = true;
                                        }
                                    }
                                    else if ((prevBorderPoint.orientation === OrientationEnum.Bottom && curBorderPoint.orientation === OrientationEnum.Right) ||
                                        (prevBorderPoint.orientation === OrientationEnum.Right && curBorderPoint.orientation === OrientationEnum.Bottom)) {
                                        const diagNeighbour = facetResult.facetMap.get(curBorderPoint.x + 1, curBorderPoint.y + 1);
                                        if (diagNeighbour !== oldNeighbour) {
                                            isTransitionPoint = true;
                                        }
                                    }
                                }
                            }
                        }
                        currentPoints.push(curBorderPoint);
                        if (isTransitionPoint) {
                            // aha! a transition point, create the current points as new segment
                            // and start a new list
                            if (currentPoints.length > 1) {
                                const segment = new PathSegment(currentPoints, oldNeighbour);
                                segments.push(segment);
                                currentPoints = [curBorderPoint];
                            }
                        }
                    }
                    // finally check if there is a remainder partial segment and either prepend
                    // the points to the first segment if they have the same neighbour or construct a
                    // new segment
                    if (currentPoints.length > 1) {
                        const oldNeighbour = f.borderPath[f.borderPath.length - 1].getNeighbour(facetResult);
                        if (segments.length > 0 && segments[0].neighbour === oldNeighbour) {
                            // the first segment and the remainder of the last one are the same part
                            // add the current points to the first segment by prefixing it
                            const mergedPoints = currentPoints.concat(segments[0].points);
                            segments[0].points = mergedPoints;
                        }
                        else {
                            // add the remainder as final segment
                            const segment = new PathSegment(currentPoints, oldNeighbour);
                            segments.push(segment);
                            currentPoints = [];
                        }
                    }
                }
                segmentsPerFacet[f.id] = segments;
            }
        }
        return segmentsPerFacet;
    }
    
    /**
     * Reduces each segment border path points
     */
    private static reduceSegmentComplexity(facetResult: FacetResult, segmentsPerFacet: Array<Array<PathSegment | null>>, nrOfTimesToHalvePoints: number) {
        for (const f of facetResult.facets) {
            if (f != null) {
                for (const segment of segmentsPerFacet[f.id]) {
                    for (let i: number = 0; i < nrOfTimesToHalvePoints; i++) {
                        segment!.points = FacetBorderSegmenter.reduceSegmentHaarWavelet(segment!.points, true, facetResult.width, facetResult.height);
                    }
                }
            }
        }
    }

    /**
     *  Remove the points by taking the average per pair and using that as a new point
     *  in the reduced segment. The delta values that create the Haar wavelet are not tracked
     *  because they are unneeded.
     */
    private static reduceSegmentHaarWavelet(newpath: PathPoint[], skipOutsideBorders: boolean, width: number, height: number) {
        if (newpath.length <= 5) {
            return newpath;
        }
        const reducedPath: PathPoint[] = [];
        reducedPath.push(newpath[0]);
        for (let i: number = 1; i < newpath.length - 2; i += 2) {
            if (!skipOutsideBorders || (skipOutsideBorders && !FacetBorderSegmenter.isOutsideBorderPoint(newpath[i], width, height))) {
                const cx = (newpath[i].x + newpath[i + 1].x) / 2;
                const cy = (newpath[i].y + newpath[i + 1].y) / 2;
                reducedPath.push(new PathPoint(new Point(cx, cy), OrientationEnum.Left));
            }
            else {
                reducedPath.push(newpath[i]);
                reducedPath.push(newpath[i + 1]);
            }
        }
        // close the loop
        reducedPath.push(newpath[newpath.length - 1]);
        return reducedPath;
    }

    private static isOutsideBorderPoint(point: Point, width: number, height: number) {
        return point.x === 0 || point.y === 0 || point.x === width - 1 || point.y === height - 1;
    }

    private static calculateArea(path: Point[]) {
        let total = 0;
        for (let i = 0; i < path.length; i++) {
            const addX = path[i].x;
            const addY = path[i === path.length - 1 ? 0 : i + 1].y;
            const subX = path[i === path.length - 1 ? 0 : i + 1].x;
            const subY = path[i].y;
            total += (addX * addY * 0.5);
            total -= (subX * subY * 0.5);
        }
        return Math.abs(total);
    }
    /**
     *  Matches all segments with each other between facets and their neighbour
     *  A segment matches when the start and end match or the start matches with the end and vice versa
     *  (then the segment will need to be traversed in reverse order)
     */
    private static async matchSegmentsWithNeighbours(facetResult: FacetResult, segmentsPerFacet: Array<Array<PathSegment | null>>, onUpdate: ((progress: number) => void) | null = null) {
        // max distance of the start/end points of the segment that it can be before the segments don't match up
        const MAX_DISTANCE = 4;
        // reserve room
        for (const f of facetResult.facets) {
            if (f != null) {
                f.borderSegments = new Array(segmentsPerFacet[f.id].length);
            }
        }
        let count = 0;
        // and now the fun begins to match segments from 1 facet to its neighbours and vice versa
        for (const f of facetResult.facets) {
            if (f != null) {
                const debug = false;
                for (let s: number = 0; s < segmentsPerFacet[f.id].length; s++) {
                    const segment = segmentsPerFacet[f.id][s];
                    if (segment != null && f.borderSegments[s] == null) {
                        f.borderSegments[s] = new FacetBoundarySegment(segment, segment.neighbour, false);
                        if (debug) {
                            console.log("Setting facet " + f.id + " segment " + s + " to " + f.borderSegments[s]);
                        }
                        if (segment.neighbour !== -1) {
                            const neighbourFacet = facetResult.facets[segment.neighbour];
                            // see if there is a match to be found
                            let matchFound = false;
                            if (neighbourFacet != null) {
                                const neighbourSegments = segmentsPerFacet[segment.neighbour];
                                for (let ns: number = 0; ns < neighbourSegments.length; ns++) {
                                    const neighbourSegment = neighbourSegments[ns];
                                    // only try to match against the segments that aren't processed yet
                                    // and which are adjacent to the boundary of the current facet
                                    if (neighbourSegment != null && neighbourSegment.neighbour === f.id) {
                                        const segStartPoint = segment.points[0];
                                        const segEndPoint = segment.points[segment.points.length - 1];
                                        const nSegStartPoint = neighbourSegment.points[0];
                                        const nSegEndPoint = neighbourSegment.points[neighbourSegment.points.length - 1];
                                        let matchesStraight = (segStartPoint.distanceTo(nSegStartPoint) <= MAX_DISTANCE &&
                                            segEndPoint.distanceTo(nSegEndPoint) <= MAX_DISTANCE);
                                        let matchesReverse = (segStartPoint.distanceTo(nSegEndPoint) <= MAX_DISTANCE &&
                                            segEndPoint.distanceTo(nSegStartPoint) <= MAX_DISTANCE);
                                        if (matchesStraight && matchesReverse) {
                                            // dang it , both match, it must be a tiny segment, but when placed wrongly it'll overlap in the path creating an hourglass 
                                            //  e.g. https://i.imgur.com/XZQhxRV.png
                                            // determine which is the closest
                                            if (segStartPoint.distanceTo(nSegStartPoint) + segEndPoint.distanceTo(nSegEndPoint) <
                                                segStartPoint.distanceTo(nSegEndPoint) + segEndPoint.distanceTo(nSegStartPoint)) {
                                                matchesStraight = true;
                                                matchesReverse = false;
                                            }
                                            else {
                                                matchesStraight = false;
                                                matchesReverse = true;
                                            }
                                        }
                                        if (matchesStraight) {
                                            // start & end points match
                                            if (debug) {
                                                console.log("Match found for facet " + f.id + " to neighbour " + neighbourFacet.id);
                                            }
                                            neighbourFacet!.borderSegments[ns] = new FacetBoundarySegment(segment, f.id, false);
                                            if (debug) {
                                                console.log("Setting facet " + neighbourFacet!.id + " segment " + ns + " to " + neighbourFacet!.borderSegments[ns]);
                                            }
                                            segmentsPerFacet[neighbourFacet.id][ns] = null;
                                            matchFound = true;
                                            break;
                                        }
                                        else if (matchesReverse) {
                                            // start & end points match  but in reverse order
                                            if (debug) {
                                                console.log("Reverse match found for facet " + f.id + " to neighbour " + neighbourFacet.id);
                                            }
                                            neighbourFacet!.borderSegments[ns] = new FacetBoundarySegment(segment, f.id, true);
                                            if (debug) {
                                                console.log("Setting facet " + neighbourFacet!.id + " segment " + ns + " to " + neighbourFacet!.borderSegments[ns]);
                                            }
                                            segmentsPerFacet[neighbourFacet.id][ns] = null;
                                            matchFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!matchFound && debug) {
                                // it's possible that the border is not shared with its neighbour
                                // this can happen when the segment fully falls inside the other facet
                                // though the above checks in the preparation of the segments should probably
                                // cover all cases
                                console.error("No match found for segment of " + f.id + ": " +
                                    ("siding " + segment.neighbour + " " + segment.points[0] + " -> " + segment.points[segment.points.length - 1]));
                            }
                        }
                    }
                    // clear the current segment so it can't be processed again when processing the neighbour facet
                    segmentsPerFacet[f.id][s] = null;
                }
                if (count % 100 === 0) {
                    await delay(0);
                    if (onUpdate != null) {
                        onUpdate(f.id / facetResult.facets.length);
                    }
                }
            }
            count++;
        }
        if (onUpdate != null) {
            onUpdate(1);
        }
    }
}

--- END FILE: .\src\facetBorderSegmenter.ts ---


--- START FILE: .\src\facetBorderTracer.ts ---
import { delay } from "./common";
import { Point } from "./structs/point";
import { BooleanArray2D } from "./structs/typedarrays";
import { FacetResult, PathPoint, OrientationEnum, Facet } from "./facetmanagement";

export class FacetBorderTracer {
    
    /**
     *  Traces the border path of the facet from the facet border points.
     *  Imagine placing walls around the outer side of the border points.
     */
    public static async buildFacetBorderPaths(facetResult: FacetResult, onUpdate: ((progress: number) => void) | null = null) {
        let count = 0;
        const borderMask = new BooleanArray2D(facetResult.width, facetResult.height);
        // sort by biggest facets first
        const facetProcessingOrder = facetResult.facets.filter((f) => f != null).slice(0).sort((a, b) => b!.pointCount > a!.pointCount ? 1 : (b!.pointCount < a!.pointCount ? -1 : 0)).map((f) => f!.id);
        for (let fidx: number = 0; fidx < facetProcessingOrder.length; fidx++) {
            const f = facetResult.facets[facetProcessingOrder[fidx]]!;
            if (f != null) {
                for (const bp of f.borderPoints) {
                    borderMask.set(bp.x, bp.y, true);
                }
                // keep track of which walls are already set on each pixel
                // e.g. xWall.get(x,y) is the left wall of point x,y
                // as the left wall of (x+1,y) and right wall of (x,y) is the same
                // the right wall of x,y can be set with xWall.set(x+1,y).
                // Analogous for the horizontal walls in yWall
                const xWall = new BooleanArray2D(facetResult.width + 1, facetResult.height + 1);
                const yWall = new BooleanArray2D(facetResult.width + 1, facetResult.height + 1);
                // the first border point will guaranteed be one of the outer ones because
                // it will be the first point that is encountered of the facet when building
                // them in buildFacet with DFS.
                // --> Or so I thought, which is apparently not the case in rare circumstances
                // sooooo go look for a border that edges with the bounding box, this is definitely
                // on the outer side then.
                let borderStartIndex = -1;
                for (let i: number = 0; i < f.borderPoints.length; i++) {
                    if ((f.borderPoints[i].x === f.bbox.minX || f.borderPoints[i].x === f.bbox.maxX) ||
                        (f.borderPoints[i].y === f.bbox.minY || f.borderPoints[i].y === f.bbox.maxY)) {
                        borderStartIndex = i;
                        break;
                    }
                }
                // determine the starting point orientation (the outside of facet)
                const pt = new PathPoint(f.borderPoints[borderStartIndex], OrientationEnum.Left);
                // L T R B
                if (pt.x - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y) !== f.id) {
                    pt.orientation = OrientationEnum.Left;
                }
                else if (pt.y - 1 < 0 || facetResult.facetMap.get(pt.x, pt.y - 1) !== f.id) {
                    pt.orientation = OrientationEnum.Top;
                }
                else if (pt.x + 1 >= facetResult.width || facetResult.facetMap.get(pt.x + 1, pt.y) !== f.id) {
                    pt.orientation = OrientationEnum.Right;
                }
                else if (pt.y + 1 >= facetResult.height || facetResult.facetMap.get(pt.x, pt.y + 1) !== f.id) {
                    pt.orientation = OrientationEnum.Bottom;
                }
                // build a border path from that point
                const path = FacetBorderTracer.getPath(pt, facetResult, f, borderMask, xWall, yWall);
                f.borderPath = path;
                if (count % 100 === 0) {
                    await delay(0);
                    if (onUpdate != null) {
                        onUpdate(fidx / facetProcessingOrder.length);
                    }
                }
            }
            count++;
        }
        if (onUpdate != null) {
            onUpdate(1);
        }
    }

    /**
     * Returns a border path starting from the given point
     */
    private static getPath(pt: PathPoint, facetResult: FacetResult, f: Facet, borderMask: BooleanArray2D, xWall: BooleanArray2D, yWall: BooleanArray2D) {
        const debug = false;
        let finished = false;
        const count = 0;
        const path: PathPoint[] = [];
        FacetBorderTracer.addPointToPath(path, pt, xWall, f, yWall);
        // check rotations first, then straight along the ouside and finally diagonally
        // this ensures that bends are always taken as tight as possible
        // so it doesn't skip border points to later loop back to and get stuck (hopefully)
        while (!finished) {
            if (debug) {
                console.log(pt.x + " " + pt.y + " " + pt.orientation);
            }
            // yes, technically i could do some trickery to only get the left/top cases
            // by shifting the pixels but that means some more shenanigans in correct order of things
            // so whatever. (And yes I tried it but it wasn't worth the debugging hell that ensued)
            const possibleNextPoints: PathPoint[] = [];
            //   +---+---+
            //   |  <|   |
            //   +---+---+
            if (pt.orientation === OrientationEnum.Left) {
                // check rotate to top
                //   +---+---+
                //   |   |   |
                //   +---xnnnn (x = old wall, n = new wall, F = current facet x,y)
                //   |   x F |
                //   +---x---+
                if (((pt.y - 1 >= 0 && facetResult.facetMap.get(pt.x, pt.y - 1) !== f.id) // top exists and is a neighbour facet
                    || pt.y - 1 < 0) // or top doesn't exist, which is the boundary of the image
                    && !yWall.get(pt.x, pt.y)) { // and the wall isn't set yet
                    // can place top _ wall at x,y
                    if (debug) {
                        console.log("can place top _ wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Top);
                    possibleNextPoints.push(nextpt);
                }
                // check rotate to bottom
                //   +---+---+
                //   |   |   |
                //   +---x---+ (x = old wall, n = new wall, F = current facet x,y)
                //   |   x F |
                //   +---xnnnn
                if (((pt.y + 1 < facetResult.height && facetResult.facetMap.get(pt.x, pt.y + 1) !== f.id) // bottom exists and is a neighbour facet
                    || pt.y + 1 >= facetResult.height) // or bottom doesn't exist, which is the boundary of the image
                    && !yWall.get(pt.x, pt.y + 1)) { // and the wall isn't set yet
                    // can place bottom  _ wall at x,y
                    if (debug) {
                        console.log("can place bottom _ wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Bottom);
                    possibleNextPoints.push(nextpt);
                }
                // check upwards
                //   +---n---+
                //   |   n   |
                //   +---x---+ (x = old wall, n = new wall, F = current facet x,y)
                //   |   x F |
                //   +---x---+
                if (pt.y - 1 >= 0 // top exists
                    && facetResult.facetMap.get(pt.x, pt.y - 1) === f.id // and is part of the same facet
                    && (pt.x - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y - 1) !== f.id) // and
                    && borderMask.get(pt.x, pt.y - 1)
                    && !xWall.get(pt.x, pt.y - 1)) {
                    // can place | wall at x,y-1
                    if (debug) {
                        console.log(`can place left | wall at x,y-1`);
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y - 1), OrientationEnum.Left);
                    possibleNextPoints.push(nextpt);
                }
                // check downwards
                //   +---x---+
                //   |   x F |
                //   +---x---+ (x = old wall, n = new wall, F = current facet x,y)
                //   |   n   |
                //   +---n---+
                if (pt.y + 1 < facetResult.height
                    && facetResult.facetMap.get(pt.x, pt.y + 1) === f.id
                    && (pt.x - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y + 1) !== f.id)
                    && borderMask.get(pt.x, pt.y + 1)
                    && !xWall.get(pt.x, pt.y + 1)) {
                    // can place | wall at x,y+1
                    if (debug) {
                        console.log("can place left | wall at x,y+1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y + 1), OrientationEnum.Left);
                    possibleNextPoints.push(nextpt);
                }
                // check left upwards
                //   +---+---+
                //   |   |   |
                //   nnnnx---+ (x = old wall, n = new wall, F = current facet x,y)
                //   |   x F |
                //   +---x---+
                if (pt.y - 1 >= 0 && pt.x - 1 >= 0 // there is a left upwards
                    && facetResult.facetMap.get(pt.x - 1, pt.y - 1) === f.id // and it belongs to the same facet
                    && borderMask.get(pt.x - 1, pt.y - 1) // and is on the border
                    && !yWall.get(pt.x - 1, pt.y - 1 + 1) // and the bottom wall isn't set yet
                    && !yWall.get(pt.x, pt.y) // and the path didn't come from the top of the current one to prevent getting a T shaped path (issue: https://i.imgur.com/ggUWuXi.png)
                ) {
                    // can place bottom _ wall at x-1,y-1
                    if (debug) {
                        console.log("can place bottom _ wall at x-1,y-1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x - 1, pt.y - 1), OrientationEnum.Bottom);
                    possibleNextPoints.push(nextpt);
                }
                // check left downwards
                //   +---x---+
                //   |   x F |
                //   nnnnx---+ (x = old wall, n = new wall, F = current facet x,y)
                //   |   |   |
                //   +---+---+
                if (pt.y + 1 < facetResult.height && pt.x - 1 >= 0 // there is a left downwards
                    && facetResult.facetMap.get(pt.x - 1, pt.y + 1) === f.id // and belongs to the same facet
                    && borderMask.get(pt.x - 1, pt.y + 1) // and is on the border
                    && !yWall.get(pt.x - 1, pt.y + 1) // and the top wall isn't set yet
                    && !yWall.get(pt.x, pt.y + 1) // and the path didn't come from the bottom of the current point to prevent T shape
                ) {
                    // can place top _ wall at x-1,y+1
                    if (debug) {
                        console.log("can place top _ wall at x-1,y+1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x - 1, pt.y + 1), OrientationEnum.Top);
                    possibleNextPoints.push(nextpt);
                }
            }
            else if (pt.orientation === OrientationEnum.Top) {
                // check rotate to left
                if (((pt.x - 1 >= 0
                    && facetResult.facetMap.get(pt.x - 1, pt.y) !== f.id)
                    || pt.x - 1 < 0)
                    && !xWall.get(pt.x, pt.y)) {
                    // can place left | wall at x,y
                    if (debug) {
                        console.log("can place left | wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Left);
                    possibleNextPoints.push(nextpt);
                }
                // check rotate to right
                if (((pt.x + 1 < facetResult.width
                    && facetResult.facetMap.get(pt.x + 1, pt.y) !== f.id)
                    || pt.x + 1 >= facetResult.width)
                    && !xWall.get(pt.x + 1, pt.y)) {
                    // can place right | wall at x,y
                    if (debug) {
                        console.log("can place right | wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Right);
                    possibleNextPoints.push(nextpt);
                }
                // check leftwards
                if (pt.x - 1 >= 0
                    && facetResult.facetMap.get(pt.x - 1, pt.y) === f.id
                    && (pt.y - 1 < 0 || facetResult.facetMap.get(pt.x - 1, pt.y - 1) !== f.id)
                    && borderMask.get(pt.x - 1, pt.y)
                    && !yWall.get(pt.x - 1, pt.y)) {
                    // can place top _ wall at x-1,y
                    if (debug) {
                        console.log(`can place top _ wall at x-1,y`);
                    }
                    const nextpt = new PathPoint(new Point(pt.x - 1, pt.y), OrientationEnum.Top);
                    possibleNextPoints.push(nextpt);
                }
                // check rightwards
                if (pt.x + 1 < facetResult.width
                    && facetResult.facetMap.get(pt.x + 1, pt.y) === f.id
                    && (pt.y - 1 < 0 || facetResult.facetMap.get(pt.x + 1, pt.y - 1) !== f.id)
                    && borderMask.get(pt.x + 1, pt.y)
                    && !yWall.get(pt.x + 1, pt.y)) {
                    // can place top _ wall at x+1,y
                    if (debug) {
                        console.log(`can place top _ wall at x+1,y`);
                    }
                    const nextpt = new PathPoint(new Point(pt.x + 1, pt.y), OrientationEnum.Top);
                    possibleNextPoints.push(nextpt);
                }
                // check left upwards
                if (pt.y - 1 >= 0 && pt.x - 1 >= 0 // there is a left upwards
                    && facetResult.facetMap.get(pt.x - 1, pt.y - 1) === f.id // and it belongs to the same facet
                    && borderMask.get(pt.x - 1, pt.y - 1) // and it's part of the border
                    && !xWall.get(pt.x - 1 + 1, pt.y - 1) // the right wall isn't set yet
                    && !xWall.get(pt.x, pt.y) // and the left wall of the current point isn't set yet to prevent |- path
                ) {
                    // can place right | wall at x-1,y-1
                    if (debug) {
                        console.log("can place right | wall at x-1,y-1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x - 1, pt.y - 1), OrientationEnum.Right);
                    possibleNextPoints.push(nextpt);
                }
                // check right upwards
                if (pt.y - 1 >= 0 && pt.x + 1 < facetResult.width // there is a right upwards
                    && facetResult.facetMap.get(pt.x + 1, pt.y - 1) === f.id // and it belongs to the same facet
                    && borderMask.get(pt.x + 1, pt.y - 1) // and it's on the border
                    && !xWall.get(pt.x + 1, pt.y - 1) // and the left wall isn't set yet
                    && !xWall.get(pt.x + 1, pt.y) // and the right wall of the current point isn't set yet to prevent -| path
                ) {
                    // can place left |  wall at x+1,y-1
                    if (debug) {
                        console.log("can place left |  wall at x+1,y-1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x + 1, pt.y - 1), OrientationEnum.Left);
                    possibleNextPoints.push(nextpt);
                }
            }
            else if (pt.orientation === OrientationEnum.Right) {
                // check rotate to top
                if (((pt.y - 1 >= 0
                    && facetResult.facetMap.get(pt.x, pt.y - 1) !== f.id)
                    || pt.y - 1 < 0)
                    && !yWall.get(pt.x, pt.y)) {
                    // can place top _ wall at x,y
                    if (debug) {
                        console.log("can place top _ wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Top);
                    possibleNextPoints.push(nextpt);
                }
                // check rotate to bottom
                if (((pt.y + 1 < facetResult.height
                    && facetResult.facetMap.get(pt.x, pt.y + 1) !== f.id)
                    || pt.y + 1 >= facetResult.height)
                    && !yWall.get(pt.x, pt.y + 1)) {
                    // can place bottom  _ wall at x,y
                    if (debug) {
                        console.log("can place bottom _ wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Bottom);
                    possibleNextPoints.push(nextpt);
                }
                // check upwards
                if (pt.y - 1 >= 0
                    && facetResult.facetMap.get(pt.x, pt.y - 1) === f.id
                    && (pt.x + 1 >= facetResult.width || facetResult.facetMap.get(pt.x + 1, pt.y - 1) !== f.id)
                    && borderMask.get(pt.x, pt.y - 1)
                    && !xWall.get(pt.x + 1, pt.y - 1)) {
                    // can place right | wall at x,y-1
                    if (debug) {
                        console.log(`can place right | wall at x,y-1`);
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y - 1), OrientationEnum.Right);
                    possibleNextPoints.push(nextpt);
                }
                // check downwards
                if (pt.y + 1 < facetResult.height
                    && facetResult.facetMap.get(pt.x, pt.y + 1) === f.id
                    && (pt.x + 1 >= facetResult.width || facetResult.facetMap.get(pt.x + 1, pt.y + 1) !== f.id)
                    && borderMask.get(pt.x, pt.y + 1)
                    && !xWall.get(pt.x + 1, pt.y + 1)) {
                    // can place right | wall at x,y+1
                    if (debug) {
                        console.log("can place right | wall at x,y+1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y + 1), OrientationEnum.Right);
                    possibleNextPoints.push(nextpt);
                }
                // check right upwards
                if (pt.y - 1 >= 0 && pt.x + 1 < facetResult.width // there is a right upwards
                    && facetResult.facetMap.get(pt.x + 1, pt.y - 1) === f.id // and belongs to the same facet
                    && borderMask.get(pt.x + 1, pt.y - 1) // and is on the border
                    && !yWall.get(pt.x + 1, pt.y - 1 + 1) // and the bottom wall isn't set yet
                    && !yWall.get(pt.x, pt.y) // and the top wall of the current point isn't set to prevent a T shape
                ) {
                    // can place bottom _ wall at x+1,y-1
                    if (debug) {
                        console.log("can place bottom _ wall at x+1,y-1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x + 1, pt.y - 1), OrientationEnum.Bottom);
                    possibleNextPoints.push(nextpt);
                }
                // check right downwards
                if (pt.y + 1 < facetResult.height && pt.x + 1 < facetResult.width // there is a right downwards
                    && facetResult.facetMap.get(pt.x + 1, pt.y + 1) === f.id // and belongs to the same facet
                    && borderMask.get(pt.x + 1, pt.y + 1) // and is on the border
                    && !yWall.get(pt.x + 1, pt.y + 1) // and the top wall isn't visited yet
                    && !yWall.get(pt.x, pt.y + 1) // and the bottom wall of the current point isn't set to prevent a T shape
                ) {
                    // can place top _ wall at x+1,y+1
                    if (debug) {
                        console.log("can place top _ wall at x+1,y+1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x + 1, pt.y + 1), OrientationEnum.Top);
                    possibleNextPoints.push(nextpt);
                }
            }
            else if (pt.orientation === OrientationEnum.Bottom) {
                // check rotate to left
                if (((pt.x - 1 >= 0
                    && facetResult.facetMap.get(pt.x - 1, pt.y) !== f.id)
                    || pt.x - 1 < 0)
                    && !xWall.get(pt.x, pt.y)) {
                    // can place left | wall at x,y
                    if (debug) {
                        console.log("can place left | wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Left);
                    possibleNextPoints.push(nextpt);
                }
                // check rotate to right
                if (((pt.x + 1 < facetResult.width
                    && facetResult.facetMap.get(pt.x + 1, pt.y) !== f.id)
                    || pt.x + 1 >= facetResult.width)
                    && !xWall.get(pt.x + 1, pt.y)) {
                    // can place right | wall at x,y
                    if (debug) {
                        console.log("can place right | wall at x,y");
                    }
                    const nextpt = new PathPoint(new Point(pt.x, pt.y), OrientationEnum.Right);
                    possibleNextPoints.push(nextpt);
                }
                // check leftwards
                if (pt.x - 1 >= 0
                    && facetResult.facetMap.get(pt.x - 1, pt.y) === f.id
                    && (pt.y + 1 >= facetResult.height || facetResult.facetMap.get(pt.x - 1, pt.y + 1) !== f.id)
                    && borderMask.get(pt.x - 1, pt.y)
                    && !yWall.get(pt.x - 1, pt.y + 1)) {
                    // can place bottom _ wall at x-1,y
                    if (debug) {
                        console.log(`can place bottom _ wall at x-1,y`);
                    }
                    const nextpt = new PathPoint(new Point(pt.x - 1, pt.y), OrientationEnum.Bottom);
                    possibleNextPoints.push(nextpt);
                }
                // check rightwards
                if (pt.x + 1 < facetResult.width
                    && facetResult.facetMap.get(pt.x + 1, pt.y) === f.id
                    && (pt.y + 1 >= facetResult.height || facetResult.facetMap.get(pt.x + 1, pt.y + 1) !== f.id)
                    && borderMask.get(pt.x + 1, pt.y)
                    && !yWall.get(pt.x + 1, pt.y + 1)) {
                    // can place top _ wall at x+1,y
                    if (debug) {
                        console.log(`can place bottom _ wall at x+1,y`);
                    }
                    const nextpt = new PathPoint(new Point(pt.x + 1, pt.y), OrientationEnum.Bottom);
                    possibleNextPoints.push(nextpt);
                }
                // check left downwards
                if (pt.y + 1 < facetResult.height && pt.x - 1 >= 0 // there is a left downwards
                    && facetResult.facetMap.get(pt.x - 1, pt.y + 1) === f.id // and it's the same facet
                    && borderMask.get(pt.x - 1, pt.y + 1) // and it's on the border
                    && !xWall.get(pt.x - 1 + 1, pt.y + 1) // and the right wall isn't set yet
                    && !xWall.get(pt.x, pt.y) // and the left wall of the current point isn't set yet to prevent |- path
                ) {
                    // can place right | wall at x-1,y-1
                    if (debug) {
                        console.log("can place right | wall at x-1,y+1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x - 1, pt.y + 1), OrientationEnum.Right);
                    possibleNextPoints.push(nextpt);
                }
                // check right downwards
                if (pt.y + 1 < facetResult.height && pt.x + 1 < facetResult.width // there is a right downwards
                    && facetResult.facetMap.get(pt.x + 1, pt.y + 1) === f.id // and it's the same facet
                    && borderMask.get(pt.x + 1, pt.y + 1) // and it's on the border
                    && !xWall.get(pt.x + 1, pt.y + 1) // and the left wall isn't set yet
                    && !xWall.get(pt.x + 1, pt.y) // and the right wall of the current point isn't set yet to prevent -| path
                ) {
                    // can place left |  wall at x+1,y+1
                    if (debug) {
                        console.log("can place left |  wall at x+1,y+1");
                    }
                    const nextpt = new PathPoint(new Point(pt.x + 1, pt.y + 1), OrientationEnum.Left);
                    possibleNextPoints.push(nextpt);
                }
            }

            if (possibleNextPoints.length > 1) {
                // TODO it's now not necessary anymore to aggregate all possibilities, the first one is going to be the correct
                // selection to trace the entire border, so the if checks above can include a skip once ssible point is found again
                pt = possibleNextPoints[0];
                FacetBorderTracer.addPointToPath(path, pt, xWall, f, yWall);
            }
            else if (possibleNextPoints.length === 1) {
                pt = possibleNextPoints[0];
                FacetBorderTracer.addPointToPath(path, pt, xWall, f, yWall);
            }
            else {
                finished = true;
            }
        }
        // clear up the walls set for the path so the array can be reused
        for (const pathPoint of path) {
            switch (pathPoint.orientation) {
                case OrientationEnum.Left:
                    xWall.set(pathPoint.x, pathPoint.y, false);
                    break;
                case OrientationEnum.Top:
                    yWall.set(pathPoint.x, pathPoint.y, false);
                    break;
                case OrientationEnum.Right:
                    xWall.set(pathPoint.x + 1, pathPoint.y, false);
                    break;
                case OrientationEnum.Bottom:
                    yWall.set(pathPoint.x, pathPoint.y + 1, false);
                    break;
            }
        }
        return path;
    }

    /**
     * Add a point to the border path and ensure the correct xWall/yWalls is set
     */
    private static addPointToPath(path: PathPoint[], pt: PathPoint, xWall: BooleanArray2D, f: Facet, yWall: BooleanArray2D) {
        path.push(pt);
        switch (pt.orientation) {
            case OrientationEnum.Left:
                xWall.set(pt.x, pt.y, true);
                break;
            case OrientationEnum.Top:
                yWall.set(pt.x, pt.y, true);
                break;
            case OrientationEnum.Right:
                xWall.set(pt.x + 1, pt.y, true);
                break;
            case OrientationEnum.Bottom:
                yWall.set(pt.x, pt.y + 1, true);
                break;
        }
    }
}

--- END FILE: .\src\facetBorderTracer.ts ---


--- START FILE: .\src\facetCreator.ts ---
import { delay, IMap, RGB } from "./common";
import { fill } from "./lib/fill";
import { BoundingBox } from "./structs/boundingbox";
import { Point } from "./structs/point";
import { BooleanArray2D, Uint32Array2D, Uint8Array2D } from "./structs/typedarrays";
import { FacetResult, Facet } from "./facetmanagement";
import { FacetReducer } from "./facetReducer";

export class FacetCreator {
    /**
     *  Constructs the facets with its border points for each area of pixels of the same color
     */
    public static async getFacets(width: number, height: number, imgColorIndices: Uint8Array2D, onUpdate: ((progress: number) => void) | null = null): Promise<FacetResult> {
        const result = new FacetResult();
        result.width = width;
        result.height = height;
        // setup visited mask
        const visited = new BooleanArray2D(result.width, result.height);
        // setup facet map & array
        result.facetMap = new Uint32Array2D(result.width, result.height);
        result.facets = [];
        // depth first traversal to find the different facets
        let count = 0;
        for (let j: number = 0; j < result.height; j++) {
            for (let i: number = 0; i < result.width; i++) {
                const colorIndex = imgColorIndices.get(i, j);
                if (!visited.get(i, j)) {
                    const facetIndex = result.facets.length;
                    // build a facet starting at point i,j
                    const facet = FacetCreator.buildFacet(facetIndex, colorIndex, i, j, visited, imgColorIndices, result);
                    result.facets.push(facet);
                    if (count % 100 === 0) {
                        await delay(0);
                        if (onUpdate != null) {
                            onUpdate(count / (result.width * result.height));
                        }
                    }
                }
                count++;
            }
        }
        await delay(0);
        // fill in the neighbours of all facets by checking the neighbours of the border points
        for (const f of result.facets) {
            if (f != null) {
                FacetCreator.buildFacetNeighbour(f, result);
            }
        }
        if (onUpdate != null) {
            onUpdate(1);
        }
        return result;
    }

    /**
     *  Builds a facet at given x,y using depth first search to visit all pixels of the same color
     */
    public static buildFacet(facetIndex: number, facetColorIndex: number, x: number, y: number, visited: BooleanArray2D, imgColorIndices: Uint8Array2D, facetResult: FacetResult) {
        const facet = new Facet();
        facet.id = facetIndex;
        facet.color = facetColorIndex;
        facet.bbox = new BoundingBox();
        facet.borderPoints = [];
        
        facet.neighbourFacetsIsDirty = true; // not built neighbours yet
        facet.neighbourFacets = null;

        fill(x, y, facetResult.width, facetResult.height, (ptx, pty) => visited.get(ptx, pty) || imgColorIndices.get(ptx, pty) !== facetColorIndex, (ptx, pty) => {
            visited.set(ptx, pty, true);
            facetResult.facetMap.set(ptx, pty, facetIndex);
            facet.pointCount++;
            // determine if the point is a border or not
            /*  const isInnerPoint = (ptx - 1 >= 0 && imgColorIndices.get(ptx - 1, pty) === facetColorIndex) &&
                  (pty - 1 >= 0 && imgColorIndices.get(ptx, pty - 1) === facetColorIndex) &&
                  (ptx + 1 < facetResult.width && imgColorIndices.get(ptx + 1, pty) === facetColorIndex) &&
                  (pty + 1 < facetResult.height && imgColorIndices.get(ptx, pty + 1) === facetColorIndex);
            */
            const isInnerPoint = imgColorIndices.matchAllAround(ptx, pty, facetColorIndex);
            if (!isInnerPoint) {
                facet.borderPoints.push(new Point(ptx, pty));
            }
            // update bounding box of facet
            if (ptx > facet.bbox.maxX) {
                facet.bbox.maxX = ptx;
            }
            if (pty > facet.bbox.maxY) {
                facet.bbox.maxY = pty;
            }
            if (ptx < facet.bbox.minX) {
                facet.bbox.minX = ptx;
            }
            if (pty < facet.bbox.minY) {
                facet.bbox.minY = pty;
            }
        });
        /*
           // using a 1D flattened stack (x*width+y), we can avoid heap allocations of Point objects, which halves the garbage collection time
         let stack: number[] = [];
         stack.push(y * facetResult.width + x);

         while (stack.length > 0) {
             let pt = stack.pop()!;
             let ptx = pt % facetResult.width;
             let pty = Math.floor(pt / facetResult.width);

             // if the point wasn't visited before and matches
             // the same color
             if (!visited.get(ptx, pty) &&
                 imgColorIndices.get(ptx, pty) == facetColorIndex) {

                 visited.set(ptx, pty, true);
                 facetResult.facetMap.set(ptx, pty, facetIndex);
                 facet.pointCount++;

                 // determine if the point is a border or not
                 let isInnerPoint = (ptx - 1 >= 0 && imgColorIndices.get(ptx - 1, pty) == facetColorIndex) &&
                     (pty - 1 >= 0 && imgColorIndices.get(ptx, pty - 1) == facetColorIndex) &&
                     (ptx + 1 < facetResult.width && imgColorIndices.get(ptx + 1, pty) == facetColorIndex) &&
                     (pty + 1 < facetResult.height && imgColorIndices.get(ptx, pty + 1) == facetColorIndex);

                 if (!isInnerPoint)
                     facet.borderPoints.push(new Point(ptx, pty));

                 // update bounding box of facet
                 if (ptx > facet.bbox.maxX) facet.bbox.maxX = ptx;
                 if (pty > facet.bbox.maxY) facet.bbox.maxY = pty;
                 if (ptx < facet.bbox.minX) facet.bbox.minX = ptx;
                 if (pty < facet.bbox.minY) facet.bbox.minY = pty;

                 // visit direct adjacent points
                 if (ptx - 1 >= 0 && !visited.get(ptx - 1, pty))
                     stack.push(pty * facetResult.width + (ptx - 1)); //stack.push(new Point(pt.x - 1, pt.y));
                 if (pty - 1 >= 0 && !visited.get(ptx, pty - 1))
                     stack.push((pty - 1) * facetResult.width + ptx); //stack.push(new Point(pt.x, pt.y - 1));
                 if (ptx + 1 < facetResult.width && !visited.get(ptx + 1, pty))
                     stack.push(pty * facetResult.width + (ptx + 1));//stack.push(new Point(pt.x + 1, pt.y));
                 if (pty + 1 < facetResult.height && !visited.get(ptx, pty + 1))
                     stack.push((pty + 1) * facetResult.width + ptx); //stack.push(new Point(pt.x, pt.y + 1));
             }
         }
         */
        return facet;
    }

    /**
     * Check which neighbour facets the given facet has by checking the neighbour facets at each border point
     */
    public static buildFacetNeighbour(facet: Facet, facetResult: FacetResult) {
        facet.neighbourFacets = [];
        const uniqueFacets: IMap<boolean> = {}; // poor man's set
        for (const pt of facet.borderPoints) {
            if (pt.x - 1 >= 0) {
                const leftFacetId = facetResult.facetMap.get(pt.x - 1, pt.y);
                if (leftFacetId !== facet.id) {
                    uniqueFacets[leftFacetId] = true;
                }
            }
            if (pt.y - 1 >= 0) {
                const topFacetId = facetResult.facetMap.get(pt.x, pt.y - 1);
                if (topFacetId !== facet.id) {
                    uniqueFacets[topFacetId] = true;
                }
            }
            if (pt.x + 1 < facetResult.width) {
                const rightFacetId = facetResult.facetMap.get(pt.x + 1, pt.y);
                if (rightFacetId !== facet.id) {
                    uniqueFacets[rightFacetId] = true;
                }
            }
            if (pt.y + 1 < facetResult.height) {
                const bottomFacetId = facetResult.facetMap.get(pt.x, pt.y + 1);
                if (bottomFacetId !== facet.id) {
                    uniqueFacets[bottomFacetId] = true;
                }
            }
        }
        for (const k of Object.keys(uniqueFacets)) {
            if (uniqueFacets.hasOwnProperty(k)) {
                facet.neighbourFacets.push(parseInt(k));
            }
        }
        // the neighbour array is updated so it's not dirty anymore
        facet.neighbourFacetsIsDirty = false;
    }
}

--- END FILE: .\src\facetCreator.ts ---


--- START FILE: .\src\facetLabelPlacer.ts ---
import { delay } from "./common";
import { pointToPolygonDist, polylabel } from "./lib/polylabel";
import { BoundingBox } from "./structs/boundingbox";
import { Point } from "./structs/point";
import { FacetResult, Facet } from "./facetmanagement";
import { FacetCreator } from "./facetCreator";


export class FacetLabelPlacer {
    /**
     *  Determines where to place the labels for each facet. This is done by calculating where
     *  in the polygon the largest circle can be contained, also called the pole of inaccessibility
     *  That's the spot where there will be the most room for the label.
     *  One tricky gotcha: neighbour facets can lay completely inside other facets and can overlap the label
     *  if only the outer border of the facet is taken in account. This is solved by adding the neighbours facet polygon that fall
     *  within the facet as additional polygon rings (why does everything look so easy to do yet never is under the hood :/)
     */
    public static async buildFacetLabelBounds(facetResult: FacetResult, onUpdate: ((progress: number) => void) | null = null) {
        let count = 0;
        for (const f of facetResult.facets) {
            if (f != null) {
                const polyRings: Point[][] = [];
                // get the border path from the segments (that can have been reduced compared to facet actual border path)
                const borderPath = f.getFullPathFromBorderSegments(true);
                // outer path must be first ring
                polyRings.push(borderPath);
                const onlyOuterRing = [borderPath];
                // now add all the neighbours of the facet as "inner" rings,
                // regardless if they are inner or not. These are seen as areas where the label
                // cannot be placed
                if (f.neighbourFacetsIsDirty) {
                    FacetCreator.buildFacetNeighbour(f, facetResult);
                }
                for (const neighbourIdx of f.neighbourFacets!) {
                    const neighbourPath = facetResult.facets[neighbourIdx]!.getFullPathFromBorderSegments(true);
                    const fallsInside: boolean = FacetLabelPlacer.doesNeighbourFallInsideInCurrentFacet(neighbourPath, f, onlyOuterRing);
                    if (fallsInside) {
                        polyRings.push(neighbourPath);
                    }
                }
                const result = polylabel(polyRings);
                f.labelBounds = new BoundingBox();
                // determine inner square within the circle
                const innerPadding = 2 * Math.sqrt(2 * result.distance);
                f.labelBounds.minX = result.pt.x - innerPadding;
                f.labelBounds.maxX = result.pt.x + innerPadding;
                f.labelBounds.minY = result.pt.y - innerPadding;
                f.labelBounds.maxY = result.pt.y + innerPadding;
                if (count % 100 === 0) {
                    await delay(0);
                    if (onUpdate != null) {
                        onUpdate(f.id / facetResult.facets.length);
                    }
                }
            }
            count++;
        }
        if (onUpdate != null) {
            onUpdate(1);
        }
    }
    
    /**
     *  Checks whether a neighbour border path is fully within the current facet border path
     */
    private static doesNeighbourFallInsideInCurrentFacet(neighbourPath: Point[], f: Facet, onlyOuterRing: Point[][]) {
        let fallsInside: boolean = true;
        // fast test to see if the neighbour falls inside the bbox of the facet
        for (let i: number = 0; i < neighbourPath.length && fallsInside; i++) {
            if (neighbourPath[i].x >= f.bbox.minX && neighbourPath[i].x <= f.bbox.maxX &&
                neighbourPath[i].y >= f.bbox.minY && neighbourPath[i].y <= f.bbox.maxY) {
                // ok
            }
            else {
                fallsInside = false;
            }
        }
        if (fallsInside) {
            // do a more fine grained but more expensive check to see if each of the points fall within the polygon
            for (let i: number = 0; i < neighbourPath.length && fallsInside; i++) {
                const distance = pointToPolygonDist(neighbourPath[i].x, neighbourPath[i].y, onlyOuterRing);
                if (distance < 0) {
                    // falls outside
                    fallsInside = false;
                }
            }
        }
        return fallsInside;
    }
}

--- END FILE: .\src\facetLabelPlacer.ts ---


--- START FILE: .\src\facetmanagement.ts ---
/**
 * Facet management from the process, anything from construction, reduction and border tracing etc.
 */
import { FacetBoundarySegment } from "./FacetBorderSegmenter";
import { BoundingBox } from "./structs/boundingbox";
import { Point } from "./structs/point";
import { Uint32Array2D } from "./structs/typedarrays";

export enum OrientationEnum {
    Left,
    Top,
    Right,
    Bottom,
}

/**
 * PathPoint is a point with an orientation that indicates which wall border is set
 */
export class PathPoint extends Point {

    constructor(pt: Point, public orientation: OrientationEnum) {
        super(pt.x, pt.y);
    }

    public getWallX() {
        let x = this.x;
        if (this.orientation === OrientationEnum.Left) {
            x -= 0.5;
        } else if (this.orientation === OrientationEnum.Right) {
            x += 0.5;
        }
        return x;
    }

    public getWallY() {
        let y = this.y;
        if (this.orientation === OrientationEnum.Top) {
            y -= 0.5;
        } else if (this.orientation === OrientationEnum.Bottom) {
            y += 0.5;
        }
        return y;
    }

    public getNeighbour(facetResult: FacetResult) {
        switch (this.orientation) {
            case OrientationEnum.Left:
                if (this.x - 1 >= 0) {
                    return facetResult.facetMap.get(this.x - 1, this.y);
                }
                break;
            case OrientationEnum.Right:
                if (this.x + 1 < facetResult.width) {
                    return facetResult.facetMap.get(this.x + 1, this.y);
                }
                break;
            case OrientationEnum.Top:
                if (this.y - 1 >= 0) {
                    return facetResult.facetMap.get(this.x, this.y - 1);
                }
                break;
            case OrientationEnum.Bottom:
                if (this.y + 1 < facetResult.height) {
                    return facetResult.facetMap.get(this.x, this.y + 1);
                }
                break;
        }
        return -1;
    }

    public toString() {
        return this.x + "," + this.y + " " + this.orientation;
    }
}

/**
 *  A facet that represents an area of pixels of the same color
 */
export class Facet {

    /**
     *  The id of the facet, is always the same as the actual index of the facet in the facet array
     */
    public id!: number;
    public color!: number;
    public pointCount: number = 0;
    public borderPoints!: Point[];
    public neighbourFacets!: number[] | null;
    /**
     * Flag indicating if the neighbourfacets array is dirty. If it is, the neighbourfacets *have* to be rebuild
     * Before it can be used. This is useful to defer the rebuilding of the array until it's actually needed
     * and can remove a lot of duplicate building of the array because multiple facets were hitting the same neighbour
     * (over 50% on test images)
     */
    public neighbourFacetsIsDirty: boolean = false;

    public bbox!: BoundingBox;

    public borderPath!: PathPoint[];
    public borderSegments!: FacetBoundarySegment[];

    public labelBounds!: BoundingBox;

    public getFullPathFromBorderSegments(useWalls: boolean) {
        const newpath: Point[] = [];

        const addPoint = (pt: PathPoint) => {
            if (useWalls) {
                newpath.push(new Point(pt.getWallX(), pt.getWallY()));
            } else {
                newpath.push(new Point(pt.x, pt.y));
            }
        };

        let lastSegment: FacetBoundarySegment | null = null;
        for (const seg of this.borderSegments) {

            // fix for the continuitity of the border segments. If transition points between border segments on the path aren't repeated, the
            // borders of the facets aren't always matching up leaving holes when rendered
            if (lastSegment != null) {
                if (lastSegment.reverseOrder) {
                    addPoint(lastSegment.originalSegment.points[0]);
                } else {
                    addPoint(lastSegment.originalSegment.points[lastSegment.originalSegment.points.length - 1]);
                }
            }

            for (let i: number = 0; i < seg.originalSegment.points.length; i++) {
                const idx = seg.reverseOrder ? (seg.originalSegment.points.length - 1 - i) : i;
                addPoint(seg.originalSegment.points[idx]);
            }

            lastSegment = seg;
        }
        return newpath;
    }

}

/**
 *  Result of the facet construction, both as a map and as an array.
 *  Facets in the array can be null when they've been deleted
 */
export class FacetResult {
    public facetMap!: Uint32Array2D;
    public facets!: Array<Facet | null>;

    public width!: number;
    public height!: number;
}

--- END FILE: .\src\facetmanagement.ts ---


--- START FILE: .\src\facetReducer.ts ---
import { ColorReducer } from "./colorreductionmanagement";
import { delay, IMap, RGB } from "./common";
import { FacetCreator } from "./facetCreator";
import { Facet, FacetResult } from "./facetmanagement";
import { BooleanArray2D, Uint8Array2D } from "./structs/typedarrays";

export class FacetReducer {

    /**
     *  Remove all facets that have a pointCount smaller than the given number.
     */
    public static async reduceFacets(smallerThan: number, removeFacetsFromLargeToSmall: boolean, maximumNumberOfFacets: number, colorsByIndex: RGB[], facetResult: FacetResult, imgColorIndices: Uint8Array2D, onUpdate: ((progress: number) => void) | null = null) {
        const visitedCache = new BooleanArray2D(facetResult.width, facetResult.height);

        // build the color distance matrix, which describes the distance of each color to each other
        const colorDistances: number[][] = ColorReducer.buildColorDistanceMatrix(colorsByIndex);

        // process facets from large to small. This results in better consistency with the original image
        // because the small facets act as boundary for the large merges keeping them mostly in place of where they should remain
        // then afterwards the smaller ones are deleted which will just end up completely isolated and thus entirely replaced
        // with the outer facet. But then again, what do I know, I'm just a comment.
        const facetProcessingOrder = facetResult.facets.filter((f) => f != null).slice(0).sort((a, b) => b!.pointCount > a!.pointCount ? 1 : (b!.pointCount < a!.pointCount ? -1 : 0)).map((f) => f!.id);

        if (!removeFacetsFromLargeToSmall) {
            facetProcessingOrder.reverse();
        }

        let curTime = new Date().getTime();
        for (let fidx: number = 0; fidx < facetProcessingOrder.length; fidx++) {
            const f = facetResult.facets[facetProcessingOrder[fidx]];
            // facets can be removed by merging by others due to a previous facet deletion
            if (f != null && f.pointCount < smallerThan) {
                FacetReducer.deleteFacet(f.id, facetResult, imgColorIndices, colorDistances, visitedCache);

                if (new Date().getTime() - curTime > 500) {
                    curTime = new Date().getTime();
                    await delay(0);
                    if (onUpdate != null) {
                        onUpdate(0.5 * fidx / facetProcessingOrder.length);
                    }
                }
            }

        }

        let facetCount = facetResult.facets.filter(f => f != null).length;
        if (facetCount > maximumNumberOfFacets) {
            console.log(`There are still ${facetCount} facets, more than the maximum of ${maximumNumberOfFacets}. Removing the smallest facets`);
        }

        const startFacetCount = facetCount;
        while (facetCount > maximumNumberOfFacets) {

            // because facets can be merged, reevaluate the order of facets to make sure the smallest one is removed 
            // this is slower but more accurate
            const facetProcessingOrder = facetResult.facets.filter((f) => f != null).slice(0)
                .sort((a, b) => b!.pointCount > a!.pointCount ? 1 : (b!.pointCount < a!.pointCount ? -1 : 0))
                .map((f) => f!.id)
                .reverse();

            const facetToRemove = facetResult.facets[facetProcessingOrder[0]];

            FacetReducer.deleteFacet(facetToRemove!.id, facetResult, imgColorIndices, colorDistances, visitedCache);
            facetCount = facetResult.facets.filter(f => f != null).length;

            if (new Date().getTime() - curTime > 500) {
                curTime = new Date().getTime();
                await delay(0);
                if (onUpdate != null) {
                    onUpdate(0.5 + 0.5 - (facetCount - maximumNumberOfFacets) / (startFacetCount - maximumNumberOfFacets));
                }
            }
        }
        // this.trimFacets(facetResult, imgColorIndices, colorDistances, visitedCache);

        if (onUpdate != null) {
            onUpdate(1);
        }
    }

    // /**
    //  * Trims facets with narrow paths either horizontally or vertically, potentially splitting the facet into multiple facets
    //  */
    // public static trimFacets(facetResult: FacetResult, imgColorIndices: Uint8Array2D, colorDistances: number[][], visitedArrayCache: BooleanArray2D) {
    //     for (const facet of facetResult.facets) {
    //         if (facet !== null) {

    //             const facetPointsToReallocate: Point[] = [];

    //             for (let y: number = facet.bbox.minY; y <= facet.bbox.maxY; y++) {
    //                 for (let x: number = facet.bbox.minX; x <= facet.bbox.maxX; x++) {
    //                     if (x > 0 && y > 0 && x < facetResult.width - 1 && y < facetResult.height - 1 &&
    //                         facetResult.facetMap.get(x, y) === facet.id) {

    //                         // check if isolated horizontally
    //                         const top = facetResult.facetMap.get(x, y - 1);
    //                         const bottom = facetResult.facetMap.get(x, y + 1);

    //                         if (top !== facet.id && bottom !== facet.id) {
    //                             // . ? .
    //                             // . F .
    //                             // . ? .
    //                             // mark pixel of facet that it should be removed
    //                             facetPointsToReallocate.push(new Point(x, y));

    //                             const closestNeighbour = FacetReducer.getClosestNeighbourForPixel(facet, facetResult, x, y, colorDistances);
    //                             // copy over color of closest neighbour
    //                             imgColorIndices.set(x, y, facetResult.facets[closestNeighbour]!.color);
    //                             console.log("Flagged " + x + "," + y + " to trim");
    //                         }
    //                     }
    //                 }
    //             }

    //             if (facetPointsToReallocate.length > 0) {
    //                 FacetReducer.rebuildForFacetChange(visitedArrayCache, facet, imgColorIndices, facetResult);
    //             }
    //         }
    //     }
    // }

    /**
     * Deletes a facet. All points belonging to the facet are moved to the nearest neighbour facet
     * based on the distance of the neighbour border points. This results in a voronoi like filling in of the
     * void the deletion made
     */
    private static deleteFacet(facetIdToRemove: number, facetResult: FacetResult, imgColorIndices: Uint8Array2D, colorDistances: number[][], visitedArrayCache: BooleanArray2D) {
        const facetToRemove = facetResult.facets[facetIdToRemove];
        if (facetToRemove === null) { // already removed
            return;
        }

        if (facetToRemove.neighbourFacetsIsDirty) {
            FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
        }

        if (facetToRemove.neighbourFacets!.length > 0) {
            // there are many small facets, it's faster to just iterate over all points within its bounding box
            // and seeing which belong to the facet than to keep track of the inner points (along with the border points)
            // per facet, because that generates a lot of extra heap objects that need to be garbage collected each time
            // a facet is rebuilt
            for (let j: number = facetToRemove.bbox.minY; j <= facetToRemove.bbox.maxY; j++) {
                for (let i: number = facetToRemove.bbox.minX; i <= facetToRemove.bbox.maxX; i++) {
                    if (facetResult.facetMap.get(i, j) === facetToRemove.id) {
                        const closestNeighbour = FacetReducer.getClosestNeighbourForPixel(facetToRemove, facetResult, i, j, colorDistances);
                        if (closestNeighbour !== -1) {
                            // copy over color of closest neighbour
                            imgColorIndices.set(i, j, facetResult.facets[closestNeighbour]!.color);
                        } else {
                            console.warn(`No closest neighbour found for point ${i},${j}`);
                        }
                    }
                }
            }
        } else {
            console.warn(`Facet ${facetToRemove.id} does not have any neighbours`);
        }

        // Rebuild all the neighbour facets that have been changed. While it could probably be faster by just adding the points manually
        // to the facet map and determine if the border points are still valid, it's more complex than that. It's possible that due to the change in points
        // that 2 neighbours of the same colors have become linked and need to merged as well. So it's easier to just rebuild the entire facet
        FacetReducer.rebuildForFacetChange(visitedArrayCache, facetToRemove, imgColorIndices, facetResult);

        // now mark the facet to remove as deleted
        facetResult.facets[facetToRemove.id] = null;
    }

    private static rebuildForFacetChange(visitedArrayCache: BooleanArray2D, facet: Facet, imgColorIndices: Uint8Array2D, facetResult: FacetResult) {
        FacetReducer.rebuildChangedNeighbourFacets(visitedArrayCache, facet, imgColorIndices, facetResult);

        // sanity check: make sure that all points have been replaced by neighbour facets. It's possible that some points will have
        // been left out because there is no continuity with the neighbour points
        // this occurs for diagonal points to the neighbours and more often when the closest
        // color is chosen when distances are equal.
        // It's probably possible to enforce that this will never happen in the above code but
        // this is a constraint that is expensive to enforce and doesn't happen all that much
        // so instead try and merge if with any of its direct neighbours if possible
        let needsToRebuild = false;
        for (let y: number = facet.bbox.minY; y <= facet.bbox.maxY; y++) {
            for (let x: number = facet.bbox.minX; x <= facet.bbox.maxX; x++) {
                if (facetResult.facetMap.get(x, y) === facet.id) {
                    console.warn(`Point ${x},${y} was reallocated to neighbours for facet ${facet.id}`);
                    needsToRebuild = true;
                    if (x - 1 >= 0 && facetResult.facetMap.get(x - 1, y) !== facet.id && facetResult.facets[facetResult.facetMap.get(x - 1, y)] !== null) {
                        imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x - 1, y)]!.color);
                    } else if (y - 1 >= 0 && facetResult.facetMap.get(x, y - 1) !== facet.id && facetResult.facets[facetResult.facetMap.get(x, y - 1)] !== null) {
                        imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x, y - 1)]!.color);
                    } else if (x + 1 < facetResult.width && facetResult.facetMap.get(x + 1, y) !== facet.id && facetResult.facets[facetResult.facetMap.get(x + 1, y)] !== null) {
                        imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x + 1, y)]!.color);
                    } else if (y + 1 < facetResult.height && facetResult.facetMap.get(x, y + 1) !== facet.id && facetResult.facets[facetResult.facetMap.get(x, y + 1)] !== null) {
                        imgColorIndices.set(x, y, facetResult.facets[facetResult.facetMap.get(x, y + 1)]!.color);
                    } else {
                        console.error(`Unable to reallocate point ${x},${y}`);
                    }
                }
            }
        }
        // now we need to go through the thing again to build facets and update the neighbours
        if (needsToRebuild) {
            FacetReducer.rebuildChangedNeighbourFacets(visitedArrayCache, facet, imgColorIndices, facetResult);
        }
    }

    /**
     * Determines the closest neighbour for a given pixel of a facet, based on the closest distance to the neighbour AND the when tied, the closest color
     */
    private static getClosestNeighbourForPixel(facetToRemove: Facet, facetResult: FacetResult, x: number, y: number, colorDistances: number[][]) {
        let closestNeighbour = -1;
        let minDistance = Number.MAX_VALUE;
        let minColorDistance = Number.MAX_VALUE;
        // ensure the neighbour facets is up to date if it was marked as dirty
        if (facetToRemove.neighbourFacetsIsDirty) {
            FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
        }
        // determine which neighbour will receive the current point based on the distance, and if there are more with the same
        // distance, then take the neighbour with the closes color
        for (const neighbourIdx of facetToRemove.neighbourFacets!) {
            const neighbour = facetResult.facets[neighbourIdx];
            if (neighbour != null) {
                for (const bpt of neighbour.borderPoints) {
                    const distance = bpt.distanceToCoord(x, y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestNeighbour = neighbourIdx;
                        minColorDistance = Number.MAX_VALUE; // reset color distance
                    } else if (distance === minDistance) {
                        // if the distance is equal as the min distance
                        // then see if the neighbour's color is closer to the current color
                        // note: this causes morepoints to be reallocated to different neighbours
                        // in the sanity check later, but still yields a better visual result
                        const colorDistance = colorDistances[facetToRemove.color][neighbour.color];
                        if (colorDistance < minColorDistance) {
                            minColorDistance = colorDistance;
                            closestNeighbour = neighbourIdx;
                        }
                    }
                }
            }
        }
        return closestNeighbour;
    }

    /**
     *  Rebuilds the given changed facets
     */
    private static rebuildChangedNeighbourFacets(visitedArrayCache: BooleanArray2D, facetToRemove: Facet, imgColorIndices: Uint8Array2D, facetResult: FacetResult) {
        const changedNeighboursSet: IMap<boolean> = {};

        if (facetToRemove.neighbourFacetsIsDirty) {
            FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
        }

        for (const neighbourIdx of facetToRemove.neighbourFacets!) {
            const neighbour = facetResult.facets[neighbourIdx];
            if (neighbour != null) {
                // re-evaluate facet
                // track all the facets that needs to have their neighbour list updated, which is also going to be all the neighbours of the neighbours that are being updated
                changedNeighboursSet[neighbourIdx] = true;

                if (neighbour.neighbourFacetsIsDirty) {
                    FacetCreator.buildFacetNeighbour(neighbour, facetResult);
                }

                for (const n of neighbour.neighbourFacets!) {
                    changedNeighboursSet[n] = true;
                }

                // rebuild the neighbour facet
                const newFacet = FacetCreator.buildFacet(neighbourIdx, neighbour.color, neighbour.borderPoints[0].x, neighbour.borderPoints[0].y, visitedArrayCache, imgColorIndices, facetResult);
                facetResult.facets[neighbourIdx] = newFacet;

                // it's possible that any of the neighbour facets are now overlapping
                // because if for example facet Red - Green - Red, Green is removed
                // then it will become Red - Red and both facets will overlap
                // this means the facet will have 0 points remaining
                if (newFacet.pointCount === 0) {
                    // remove the empty facet as well
                    facetResult.facets[neighbourIdx] = null;
                }
            }
        }
        // reset the visited array for all neighbours
        // while the visited array could be recreated per facet to remove, it's quite big and introduces
        // a lot of allocation / cleanup overhead. Due to the size of the facets it's usually faster
        // to just flag every point of the facet as false again
        if (facetToRemove.neighbourFacetsIsDirty) {
            FacetCreator.buildFacetNeighbour(facetToRemove, facetResult);
        }

        for (const neighbourIdx of facetToRemove.neighbourFacets!) {
            const neighbour = facetResult.facets[neighbourIdx];
            if (neighbour != null) {
                for (let y: number = neighbour.bbox.minY; y <= neighbour.bbox.maxY; y++) {
                    for (let x: number = neighbour.bbox.minX; x <= neighbour.bbox.maxX; x++) {
                        if (facetResult.facetMap.get(x, y) === neighbour.id) {
                            visitedArrayCache.set(x, y, false);
                        }
                    }
                }
            }
        }
        // rebuild neighbour array for affected neighbours
        for (const k of Object.keys(changedNeighboursSet)) {
            if (changedNeighboursSet.hasOwnProperty(k)) {
                const neighbourIdx = parseInt(k);
                const f = facetResult.facets[neighbourIdx];
                if (f != null) {
                    // it's a lot faster when deferring the neighbour array updates
                    // because a lot of facets that are deleted share the same facet neighbours
                    // and removing the unnecessary neighbour array checks until they it's needed
                    // speeds things up significantly
                    // FacetCreator.buildFacetNeighbour(f, facetResult);
                    f.neighbourFacets = null;
                    f.neighbourFacetsIsDirty = true;
                }
            }
        }
    }

}


--- END FILE: .\src\facetReducer.ts ---


--- START FILE: .\src\gui.ts ---
/**
 * Module that provides function the GUI uses and updates the DOM accordingly
 */

import { CancellationToken, IMap, RGB } from "./common";
import { GUIProcessManager, ProcessResult } from "./guiprocessmanager";
import { ClusteringColorSpace, Settings } from "./settings";

declare function saveSvgAsPng(el: Node, filename: string): void;

let processResult: ProcessResult | null = null;
let cancellationToken: CancellationToken = new CancellationToken();

const timers: IMap<Date> = {};
export function time(name: string) {
    console.time(name);
    timers[name] = new Date();
}

export function timeEnd(name: string) {
    console.timeEnd(name);
    const ms = new Date().getTime() - timers[name].getTime();
    log(name + ": " + ms + "ms");
    delete timers[name];
}

export function log(str: string) {
    $("#log").append("<br/><span>" + str + "</span>");
}

export function parseSettings(): Settings {
    const settings = new Settings();

    if ($("#optColorSpaceRGB").prop("checked")) {
        settings.kMeansClusteringColorSpace = ClusteringColorSpace.RGB;
    } else if ($("#optColorSpaceHSL").prop("checked")) {
        settings.kMeansClusteringColorSpace = ClusteringColorSpace.HSL;
    } else if ($("#optColorSpaceRGB").prop("checked")) {
        settings.kMeansClusteringColorSpace = ClusteringColorSpace.LAB;
    }

    if ($("#optFacetRemovalLargestToSmallest").prop("checked")) {
        settings.removeFacetsFromLargeToSmall = true;
    } else {
        settings.removeFacetsFromLargeToSmall = false;
    }

    settings.randomSeed = parseInt($("#txtRandomSeed").val() + "");
    settings.kMeansNrOfClusters = parseInt($("#txtNrOfClusters").val() + "");
    settings.kMeansMinDeltaDifference = parseFloat($("#txtClusterPrecision").val() + "");

    settings.removeFacetsSmallerThanNrOfPoints = parseInt($("#txtRemoveFacetsSmallerThan").val() + "");
    settings.maximumNumberOfFacets = parseInt($("#txtMaximumNumberOfFacets").val() + "");

    settings.nrOfTimesToHalveBorderSegments = parseInt($("#txtNrOfTimesToHalveBorderSegments").val() + "");

    settings.narrowPixelStripCleanupRuns = parseInt($("#txtNarrowPixelStripCleanupRuns").val() + "");

    settings.resizeImageIfTooLarge = $("#chkResizeImage").prop("checked");
    settings.resizeImageWidth = parseInt($("#txtResizeWidth").val() + "");
    settings.resizeImageHeight = parseInt($("#txtResizeHeight").val() + "");

    const restrictedColorLines = ($("#txtKMeansColorRestrictions").val() + "").split("\n");
    for (const line of restrictedColorLines) {
        const tline = line.trim();
        if (tline.indexOf("//") === 0) {
            // comment, skip
        } else {
            const rgbparts = tline.split(",");
            if (rgbparts.length === 3) {
                let red = parseInt(rgbparts[0]);
                let green = parseInt(rgbparts[1]);
                let blue = parseInt(rgbparts[2]);
                if (red < 0) red = 0;
                if (red > 255) red = 255;
                if (green < 0) green = 0;
                if (green > 255) green = 255;
                if (blue < 0) blue = 0;
                if (blue > 255) blue = 255;

                if (!isNaN(red) && !isNaN(green) && !isNaN(blue)) {
                    settings.kMeansColorRestrictions.push([red, green, blue]);
                }
            }
        }
    }

    return settings;
}

export async function process() {
    try {
        const settings: Settings = parseSettings();
        // cancel old process & create new
        cancellationToken.isCancelled = true;
        cancellationToken = new CancellationToken();
        processResult = await GUIProcessManager.process(settings, cancellationToken);
        await updateOutput();
        const tabsOutput = M.Tabs.getInstance(document.getElementById("tabsOutput")!);
        tabsOutput.select("output-pane");
    } catch (e) {
        log("Error: " + e.message + " at " + e.stack);
    }
}

export async function updateOutput() {

    if (processResult != null) {
        const showLabels = $("#chkShowLabels").prop("checked");
        const fill = $("#chkFillFacets").prop("checked");
        const stroke = $("#chkShowBorders").prop("checked");

        const sizeMultiplier = parseInt($("#txtSizeMultiplier").val() + "");
        const fontSize = parseInt($("#txtLabelFontSize").val() + "");

        const fontColor = $("#txtLabelFontColor").val() + "";

        $("#statusSVGGenerate").css("width", "0%");

        $(".status.SVGGenerate").removeClass("complete");
        $(".status.SVGGenerate").addClass("active");

        const svg = await GUIProcessManager.createSVG(processResult.facetResult, processResult.colorsByIndex, sizeMultiplier, fill, stroke, showLabels, fontSize, fontColor, (progress) => {
            if (cancellationToken.isCancelled) { throw new Error("Cancelled"); }
            $("#statusSVGGenerate").css("width", Math.round(progress * 100) + "%");
        });
        $("#svgContainer").empty().append(svg);
        $("#palette").empty().append(createPaletteHtml(processResult.colorsByIndex));
        ($("#palette .color") as any).tooltip();
        $(".status").removeClass("active");
        $(".status.SVGGenerate").addClass("complete");
    }
}

function createPaletteHtml(colorsByIndex: RGB[]) {
    let html = "";
    for (let c: number = 0; c < colorsByIndex.length; c++) {
        const style = "background-color: " + `rgb(${colorsByIndex[c][0]},${colorsByIndex[c][1]},${colorsByIndex[c][2]})`;
        html += `<div class="color" class="tooltipped" style="${style}" data-tooltip="${colorsByIndex[c][0]},${colorsByIndex[c][1]},${colorsByIndex[c][2]}">${c}</div>`;
    }
    return $(html);
}

export function downloadPalettePng() {
    if (processResult == null) { return; }
    const colorsByIndex: RGB[] = processResult.colorsByIndex;

    const canvas = document.createElement("canvas");

    const nrOfItemsPerRow = 10;
    const nrRows = Math.ceil(colorsByIndex.length / nrOfItemsPerRow);
    const margin = 10;
    const cellWidth = 80;
    const cellHeight = 70;

    canvas.width = margin + nrOfItemsPerRow * (cellWidth + margin);
    canvas.height = margin + nrRows * (cellHeight + margin);
    const ctx = canvas.getContext("2d")!;
    ctx.translate(0.5, 0.5);

    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < colorsByIndex.length; i++) {
        const color = colorsByIndex[i];

        const x = margin + (i % nrOfItemsPerRow) * (cellWidth + margin);
        const y = margin + Math.floor(i / nrOfItemsPerRow) * (cellHeight + margin);

        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx.fillRect(x, y, cellWidth, cellHeight - 20);
        ctx.strokeStyle = "#888";
        ctx.strokeRect(x, y, cellWidth, cellHeight - 20);

        const nrText = i + "";
        ctx.fillStyle = "black";
        ctx.strokeStyle = "#CCC";
        ctx.font = "20px Tahoma";
        const nrTextSize = ctx.measureText(nrText);
        ctx.lineWidth = 2;
        ctx.strokeText(nrText, x + cellWidth / 2 - nrTextSize.width / 2, y + cellHeight / 2 - 5);
        ctx.fillText(nrText, x + cellWidth / 2 - nrTextSize.width / 2, y + cellHeight / 2 - 5);
        ctx.lineWidth = 1;

        ctx.font = "10px Tahoma";
        const rgbText = "RGB: " + Math.floor(color[0]) + "," + Math.floor(color[1]) + "," + Math.floor(color[2]);
        const rgbTextSize = ctx.measureText(rgbText);
        ctx.fillStyle = "black";
        ctx.fillText(rgbText, x + cellWidth / 2 - rgbTextSize.width / 2, y + cellHeight - 10);
    }

    const dataURL = canvas.toDataURL("image/png");
    const dl = document.createElement("a");
    document.body.appendChild(dl);
    dl.setAttribute("href", dataURL);
    dl.setAttribute("download", "palette.png");
    dl.click();
}

export function downloadPNG() {
    if ($("#svgContainer svg").length > 0) {
        saveSvgAsPng($("#svgContainer svg").get(0), "paintbynumbers.png");
    }
}

export function downloadSVG() {
    if ($("#svgContainer svg").length > 0) {
        const svgEl = $("#svgContainer svg").get(0) as any;

        svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        const svgData = svgEl.outerHTML;
        const preface = '<?xml version="1.0" standalone="no"?>\r\n';
        const svgBlob = new Blob([preface, svgData], { type: "image/svg+xml;charset=utf-8" });
        const svgUrl = URL.createObjectURL(svgBlob);
        const downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;
        downloadLink.download = "paintbynumbers.svg";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);

        /*
        var svgAsXML = (new XMLSerializer).serializeToString(<any>$("#svgContainer svg").get(0));
        let dataURL = "data:image/svg+xml," + encodeURIComponent(svgAsXML);
        var dl = document.createElement("a");
        document.body.appendChild(dl);
        dl.setAttribute("href", dataURL);
        dl.setAttribute("download", "paintbynumbers.svg");
        dl.click();
        */
    }
}

export function loadExample(imgId: string) {
    // load image
    const img = document.getElementById(imgId) as HTMLImageElement;
    const c = document.getElementById("canvas") as HTMLCanvasElement;
    const ctx = c.getContext("2d")!;
    c.width = img.naturalWidth;
    c.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);
}

--- END FILE: .\src\gui.ts ---


--- START FILE: .\src\guiprocessmanager.ts ---
/**
 * Module that manages the GUI when processing
 */

import { ColorMapResult, ColorReducer } from "./colorreductionmanagement";
import { CancellationToken, delay, IMap, RGB } from "./common";
import { FacetBorderSegmenter } from "./facetBorderSegmenter";
import { FacetBorderTracer } from "./facetBorderTracer";
import { FacetCreator } from "./facetCreator";
import { FacetLabelPlacer } from "./facetLabelPlacer";
import { FacetResult } from "./facetmanagement";
import { FacetReducer } from "./facetReducer";
import { time, timeEnd } from "./gui";
import { Settings } from "./settings";
import { Point } from "./structs/point";

export class ProcessResult {
    public facetResult!: FacetResult;
    public colorsByIndex!: RGB[];
}

/**
 *  Manages the GUI states & processes the image step by step
 */
export class GUIProcessManager {

    public static async process(settings: Settings, cancellationToken: CancellationToken): Promise<ProcessResult> {
        const c = document.getElementById("canvas") as HTMLCanvasElement;
        const ctx = c.getContext("2d")!;
        let imgData = ctx.getImageData(0, 0, c.width, c.height);

        if (settings.resizeImageIfTooLarge && (c.width > settings.resizeImageWidth || c.height > settings.resizeImageHeight)) {
            let width = c.width;
            let height = c.height;
            if (width > settings.resizeImageWidth) {
                const newWidth = settings.resizeImageWidth;
                const newHeight = c.height / c.width * settings.resizeImageWidth;
                width = newWidth;
                height = newHeight;
            }
            if (height > settings.resizeImageHeight) {
                const newHeight = settings.resizeImageHeight;
                const newWidth = width / height * newHeight;
                width = newWidth;
                height = newHeight;
            }

            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCanvas.getContext("2d")!.drawImage(c, 0, 0, width, height);
            c.width = width;
            c.height = height;
            ctx.drawImage(tempCanvas, 0, 0, width, height);
            imgData = ctx.getImageData(0, 0, c.width, c.height);
        }

        // reset progress
        $(".status .progress .determinate").css("width", "0px");
        $(".status").removeClass("complete");

        const tabsOutput = M.Tabs.getInstance(document.getElementById("tabsOutput")!);

        // k-means clustering
        const kmeansImgData = await GUIProcessManager.processKmeansClustering(imgData, tabsOutput, ctx, settings, cancellationToken);

        let facetResult: FacetResult = new FacetResult();
        let colormapResult: ColorMapResult = new ColorMapResult();

        // build color map
        colormapResult = ColorReducer.createColorMap(kmeansImgData);

        if (settings.narrowPixelStripCleanupRuns === 0) {
            // facet building
            facetResult = await GUIProcessManager.processFacetBuilding(colormapResult, cancellationToken);

            // facet reduction
            await GUIProcessManager.processFacetReduction(facetResult, tabsOutput, settings, colormapResult, cancellationToken);
        } else {
            for (let run = 0; run < settings.narrowPixelStripCleanupRuns; run++) {

                // clean up narrow pixel strips
                await ColorReducer.processNarrowPixelStripCleanup(colormapResult);

                // facet building
                facetResult = await GUIProcessManager.processFacetBuilding(colormapResult, cancellationToken);

                // facet reduction
                await GUIProcessManager.processFacetReduction(facetResult, tabsOutput, settings, colormapResult, cancellationToken);

                // the colormapResult.imgColorIndices get updated as the facets are reduced, so just do a few runs of pixel cleanup
            }
        }

        // facet border tracing
        await GUIProcessManager.processFacetBorderTracing(tabsOutput, facetResult, cancellationToken);

        // facet border segmentation
        const cBorderSegment = await GUIProcessManager.processFacetBorderSegmentation(facetResult, tabsOutput, settings, cancellationToken);

        // facet label placement
        await GUIProcessManager.processFacetLabelPlacement(facetResult, cBorderSegment, tabsOutput, cancellationToken);

        // everything is now ready to generate the SVG, return the result
        const processResult = new ProcessResult();
        processResult.facetResult = facetResult;
        processResult.colorsByIndex = colormapResult.colorsByIndex;
        return processResult;
    }

    private static async processKmeansClustering(imgData: ImageData, tabsOutput: M.Tabs, ctx: CanvasRenderingContext2D,
        settings: Settings, cancellationToken: CancellationToken) {
        time("K-means clustering");

        const cKmeans = document.getElementById("cKMeans") as HTMLCanvasElement;
        cKmeans.width = imgData.width;
        cKmeans.height = imgData.height;

        const ctxKmeans = cKmeans.getContext("2d")!;
        ctxKmeans.fillStyle = "white";
        ctxKmeans.fillRect(0, 0, cKmeans.width, cKmeans.height);

        const kmeansImgData = ctxKmeans.getImageData(0, 0, cKmeans.width, cKmeans.height);

        tabsOutput.select("kmeans-pane");
        $(".status.kMeans").addClass("active");

        await ColorReducer.applyKMeansClustering(imgData, kmeansImgData, ctx, settings, (kmeans) => {
            const progress = (100 - (kmeans.currentDeltaDistanceDifference > 100 ? 100 : kmeans.currentDeltaDistanceDifference)) / 100;
            $("#statusKMeans").css("width", Math.round(progress * 100) + "%");
            ctxKmeans.putImageData(kmeansImgData, 0, 0);
            console.log(kmeans.currentDeltaDistanceDifference);
            if (cancellationToken.isCancelled) {
                throw new Error("Cancelled");
            }
        });

        $(".status").removeClass("active");
        $(".status.kMeans").addClass("complete");
        timeEnd("K-means clustering");
        return kmeansImgData;
    }


    private static async  processFacetBuilding(colormapResult: ColorMapResult, cancellationToken: CancellationToken) {
        time("Facet building");
        $(".status.facetBuilding").addClass("active");
        const facetResult = await FacetCreator.getFacets(colormapResult.width, colormapResult.height, colormapResult.imgColorIndices, (progress) => {
            if (cancellationToken.isCancelled) {
                throw new Error("Cancelled");
            }
            $("#statusFacetBuilding").css("width", Math.round(progress * 100) + "%");
        });
        $(".status").removeClass("active");
        $(".status.facetBuilding").addClass("complete");
        timeEnd("Facet building");
        return facetResult;
    }

    private static async processFacetReduction(facetResult: FacetResult, tabsOutput: M.Tabs, settings: Settings, colormapResult: ColorMapResult, cancellationToken: CancellationToken) {
        time("Facet reduction");
        const cReduction = document.getElementById("cReduction") as HTMLCanvasElement;
        cReduction.width = facetResult.width;
        cReduction.height = facetResult.height;
        const ctxReduction = cReduction.getContext("2d")!;
        ctxReduction.fillStyle = "white";
        ctxReduction.fillRect(0, 0, cReduction.width, cReduction.height);
        const reductionImgData = ctxReduction.getImageData(0, 0, cReduction.width, cReduction.height);
        tabsOutput.select("reduction-pane");
        $(".status.facetReduction").addClass("active");
        await FacetReducer.reduceFacets(settings.removeFacetsSmallerThanNrOfPoints, settings.removeFacetsFromLargeToSmall, settings.maximumNumberOfFacets, colormapResult.colorsByIndex, facetResult, colormapResult.imgColorIndices, (progress) => {
            if (cancellationToken.isCancelled) {
                throw new Error("Cancelled");
            }
            // update status & image
            $("#statusFacetReduction").css("width", Math.round(progress * 100) + "%");
            let idx = 0;
            for (let j: number = 0; j < facetResult.height; j++) {
                for (let i: number = 0; i < facetResult.width; i++) {
                    const facet = facetResult.facets[facetResult.facetMap.get(i, j)];
                    const rgb = colormapResult.colorsByIndex[facet!.color];
                    reductionImgData.data[idx++] = rgb[0];
                    reductionImgData.data[idx++] = rgb[1];
                    reductionImgData.data[idx++] = rgb[2];
                    idx++;
                }
            }
            ctxReduction.putImageData(reductionImgData, 0, 0);
        });
        $(".status").removeClass("active");
        $(".status.facetReduction").addClass("complete");
        timeEnd("Facet reduction");
    }

    private static async processFacetBorderTracing(tabsOutput: M.Tabs, facetResult: FacetResult, cancellationToken: CancellationToken) {
        time("Facet border tracing");
        tabsOutput.select("borderpath-pane");
        const cBorderPath = document.getElementById("cBorderPath") as HTMLCanvasElement;
        cBorderPath.width = facetResult.width;
        cBorderPath.height = facetResult.height;
        const ctxBorderPath = cBorderPath.getContext("2d")!;
        $(".status.facetBorderPath").addClass("active");
        await FacetBorderTracer.buildFacetBorderPaths(facetResult, (progress) => {
            if (cancellationToken.isCancelled) {
                throw new Error("Cancelled");
            }
            // update status & image
            $("#statusFacetBorderPath").css("width", Math.round(progress * 100) + "%");
            ctxBorderPath.fillStyle = "white";
            ctxBorderPath.fillRect(0, 0, cBorderPath.width, cBorderPath.height);
            for (const f of facetResult.facets) {
                if (f != null && f.borderPath != null) {
                    ctxBorderPath.beginPath();
                    ctxBorderPath.moveTo(f.borderPath[0].getWallX(), f.borderPath[0].getWallY());
                    for (let i: number = 1; i < f.borderPath.length; i++) {
                        ctxBorderPath.lineTo(f.borderPath[i].getWallX(), f.borderPath[i].getWallY());
                    }
                    ctxBorderPath.stroke();
                }
            }
        });
        $(".status").removeClass("active");
        $(".status.facetBorderPath").addClass("complete");
        timeEnd("Facet border tracing");
    }

    private static async processFacetBorderSegmentation(facetResult: FacetResult, tabsOutput: M.Tabs, settings: Settings, cancellationToken: CancellationToken) {
        time("Facet border segmentation");
        const cBorderSegment = document.getElementById("cBorderSegmentation") as HTMLCanvasElement;
        cBorderSegment.width = facetResult.width;
        cBorderSegment.height = facetResult.height;
        const ctxBorderSegment = cBorderSegment.getContext("2d")!;
        tabsOutput.select("bordersegmentation-pane");
        $(".status.facetBorderSegmentation").addClass("active");

        await FacetBorderSegmenter.buildFacetBorderSegments(facetResult, settings.nrOfTimesToHalveBorderSegments, (progress) => {
            if (cancellationToken.isCancelled) {
                throw new Error("Cancelled");
            }

            // update status & image
            $("#statusFacetBorderSegmentation").css("width", Math.round(progress * 100) + "%");
            ctxBorderSegment.fillStyle = "white";
            ctxBorderSegment.fillRect(0, 0, cBorderSegment.width, cBorderSegment.height);
            for (const f of facetResult.facets) {
                if (f != null && progress > f.id / facetResult.facets.length) {
                    ctxBorderSegment.beginPath();
                    const path = f.getFullPathFromBorderSegments(false);
                    ctxBorderSegment.moveTo(path[0].x, path[0].y);
                    for (let i: number = 1; i < path.length; i++) {
                        ctxBorderSegment.lineTo(path[i].x, path[i].y);
                    }
                    ctxBorderSegment.stroke();
                }
            }
        });
        $(".status").removeClass("active");
        $(".status.facetBorderSegmentation").addClass("complete");
        timeEnd("Facet border segmentation");
        return cBorderSegment;
    }

    private static async processFacetLabelPlacement(facetResult: FacetResult, cBorderSegment: HTMLCanvasElement, tabsOutput: M.Tabs, cancellationToken: CancellationToken) {
        time("Facet label placement");
        const cLabelPlacement = document.getElementById("cLabelPlacement") as HTMLCanvasElement;
        cLabelPlacement.width = facetResult.width;
        cLabelPlacement.height = facetResult.height;
        const ctxLabelPlacement = cLabelPlacement.getContext("2d")!;
        ctxLabelPlacement.fillStyle = "white";
        ctxLabelPlacement.fillRect(0, 0, cBorderSegment.width, cBorderSegment.height);
        ctxLabelPlacement.drawImage(cBorderSegment, 0, 0);
        tabsOutput.select("labelplacement-pane");
        $(".status.facetLabelPlacement").addClass("active");
        await FacetLabelPlacer.buildFacetLabelBounds(facetResult, (progress) => {
            if (cancellationToken.isCancelled) {
                throw new Error("Cancelled");
            }

            // update status & image
            $("#statusFacetLabelPlacement").css("width", Math.round(progress * 100) + "%");
            for (const f of facetResult.facets) {
                if (f != null && f.labelBounds != null) {
                    ctxLabelPlacement.fillStyle = "red";
                    ctxLabelPlacement.fillRect(f.labelBounds.minX, f.labelBounds.minY, f.labelBounds.width, f.labelBounds.height);
                }
            }
        });
        $(".status").removeClass("active");
        $(".status.facetLabelPlacement").addClass("complete");
        timeEnd("Facet label placement");
    }

    /**
     *  Creates a vector based SVG image of the facets with the given configuration
     */
    public static async createSVG(facetResult: FacetResult, colorsByIndex: RGB[], sizeMultiplier: number, fill: boolean, stroke: boolean, addColorLabels: boolean, fontSize: number = 50, fontColor: string = "black", onUpdate: ((progress: number) => void) | null = null) {
        const xmlns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(xmlns, "svg");
        svg.setAttribute("width", sizeMultiplier * facetResult.width + "");
        svg.setAttribute("height", sizeMultiplier * facetResult.height + "");

        let count = 0;
        for (const f of facetResult.facets) {

            if (f != null && f.borderSegments.length > 0) {
                let newpath: Point[] = [];
                const useSegments = true;
                if (useSegments) {
                    newpath = f.getFullPathFromBorderSegments(false);
                    // shift from wall coordinates to pixel centers
                    /*for (const p of newpath) {
                        p.x+=0.5;
                        p.y+=0.5;
                    }*/
                } else {
                    for (let i: number = 0; i < f.borderPath.length; i++) {
                        newpath.push(new Point(f.borderPath[i].getWallX() + 0.5, f.borderPath[i].getWallY() + 0.5));
                    }
                }
                if (newpath[0].x !== newpath[newpath.length - 1].x || newpath[0].y !== newpath[newpath.length - 1].y) {
                    newpath.push(newpath[0]);
                } // close loop if necessary

                // Create a path in SVG's namespace
                // using quadratic curve absolute positions
                const svgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                let data = "M ";
                data += newpath[0].x * sizeMultiplier + " " + newpath[0].y * sizeMultiplier + " ";
                for (let i: number = 1; i < newpath.length; i++) {
                    const midpointX = (newpath[i].x + newpath[i - 1].x) / 2;
                    const midpointY = (newpath[i].y + newpath[i - 1].y) / 2;
                    data += "Q " + (midpointX * sizeMultiplier) + " " + (midpointY * sizeMultiplier) + " " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
                    // data += "L " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
                }
                data += "Z";

                svgPath.setAttribute("data-facetId", f.id + "");
                // Set path's data
                svgPath.setAttribute("d", data);

                if (stroke) {
                    svgPath.style.stroke = "#000";
                } else {
                    // make the border the same color as the fill color if there is no border stroke
                    // to not have gaps in between facets
                    if (fill) {
                        svgPath.style.stroke = `rgb(${colorsByIndex[f.color][0]},${colorsByIndex[f.color][1]},${colorsByIndex[f.color][2]})`;
                    }
                }
                svgPath.style.strokeWidth = "1px"; // Set stroke width

                if (fill) {
                    svgPath.style.fill = `rgb(${colorsByIndex[f.color][0]},${colorsByIndex[f.color][1]},${colorsByIndex[f.color][2]})`;
                } else {
                    svgPath.style.fill = "none";
                }

                svg.appendChild(svgPath);

                /*  for (const seg of f.borderSegments) {
                      const svgSegPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                      let segData = "M ";
                      const segPoints = seg.originalSegment.points;
                      segData += segPoints[0].x * sizeMultiplier + " " + segPoints[0].y * sizeMultiplier + " ";
                      for (let i: number = 1; i < segPoints.length; i++) {
                          const midpointX = (segPoints[i].x + segPoints[i - 1].x) / 2;
                          const midpointY = (segPoints[i].y + segPoints[i - 1].y) / 2;
                          //data += "Q " + (midpointX * sizeMultiplier) + " " + (midpointY * sizeMultiplier) + " " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
                          segData += "L " + (segPoints[i].x * sizeMultiplier) + " " + (segPoints[i].y * sizeMultiplier) + " ";
                      }

                      console.log("Facet " + f.id + ", segment " + segPoints[0].x + "," + segPoints[0].y + " -> " + segPoints[segPoints.length-1].x + "," +  segPoints[segPoints.length-1].y);

                      svgSegPath.setAttribute("data-segmentFacet", f.id + "");
                      // Set path's data
                      svgSegPath.setAttribute("d", segData);
                      svgSegPath.style.stroke = "#FF0";
                      svgSegPath.style.fill = "none";
                      svg.appendChild(svgSegPath);
                  }
                  */

                // add the color labels if necessary. I mean, this is the whole idea behind the paint by numbers part
                // so I don't know why you would hide them
                if (addColorLabels) {
                    const txt = document.createElementNS(xmlns, "text");
                    txt.setAttribute("font-family", "Tahoma");
                    const nrOfDigits = (f.color + "").length;
                    txt.setAttribute("font-size", (fontSize / nrOfDigits) + "");
                    txt.setAttribute("dominant-baseline", "middle");
                    txt.setAttribute("text-anchor", "middle");
                    txt.setAttribute("fill", fontColor);

                    txt.textContent = f.color + "";

                    const subsvg = document.createElementNS(xmlns, "svg");
                    subsvg.setAttribute("width", f.labelBounds.width * sizeMultiplier + "");
                    subsvg.setAttribute("height", f.labelBounds.height * sizeMultiplier + "");
                    subsvg.setAttribute("overflow", "visible");
                    subsvg.setAttribute("viewBox", "-50 -50 100 100");
                    subsvg.setAttribute("preserveAspectRatio", "xMidYMid meet");

                    subsvg.appendChild(txt);

                    const g = document.createElementNS(xmlns, "g");
                    g.setAttribute("class", "label");
                    g.setAttribute("transform", "translate(" + f.labelBounds.minX * sizeMultiplier + "," + f.labelBounds.minY * sizeMultiplier + ")");
                    g.appendChild(subsvg);
                    svg.appendChild(g);
                }

                if (count % 100 === 0) {
                    await delay(0);
                    if (onUpdate != null) {
                        onUpdate(f.id / facetResult.facets.length);
                    }
                }
            }

            count++;
        }

        if (onUpdate != null) {
            onUpdate(1);
        }

        return svg;
    }
}

--- END FILE: .\src\guiprocessmanager.ts ---


--- START FILE: .\src\main.ts ---
import { downloadPalettePng, downloadPNG, downloadSVG, loadExample, process, updateOutput } from "./gui";
import { Clipboard } from "./lib/clipboard";

$(document).ready(function () {

    $(".tabs").tabs();
    $(".tooltipped").tooltip();

    const clip = new Clipboard("canvas", true);

    $("#file").change(function (ev) {
        const files = (<HTMLInputElement>$("#file").get(0)).files;
        if (files !== null && files.length > 0) {
            const reader = new FileReader();
            reader.onloadend = function () {
                const img = document.createElement("img");
                img.onload = () => {
                    const c = document.getElementById("canvas") as HTMLCanvasElement;
                    const ctx = c.getContext("2d")!;
                    c.width = img.naturalWidth;
                    c.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                };
                img.onerror = () => {
                    alert("Unable to load image");
                }
                img.src = <string>reader.result;
            }
            reader.readAsDataURL(files[0]);
        }
    });

    loadExample("imgSmall");

    $("#btnProcess").click(async function () {
        try {
            await process();
        } catch (err) {
            alert("Error: " + err);
        }
    });

    $("#chkShowLabels, #chkFillFacets, #chkShowBorders, #txtSizeMultiplier, #txtLabelFontSize, #txtLabelFontColor").change(async () => {
        await updateOutput();
    });

    $("#btnDownloadSVG").click(function () {
        downloadSVG();
    });

    $("#btnDownloadPNG").click(function () {
        downloadPNG();
    });

    $("#btnDownloadPalettePNG").click(function () {
        downloadPalettePng();
    });

    $("#lnkTrivial").click(() => { loadExample("imgTrivial"); return false; });
    $("#lnkSmall").click(() => { loadExample("imgSmall"); return false; });
    $("#lnkMedium").click(() => { loadExample("imgMedium"); return false; });
});

--- END FILE: .\src\main.ts ---


--- START FILE: .\src\random.ts ---

export class Random {

    private seed: number;
    public constructor(seed?: number) {
        if (typeof seed === "undefined") {
            this.seed = new Date().getTime();
        } else {
            this.seed = seed;
        }
    }

    public next(): number {
        const x = Math.sin(this.seed++) * 10000;
        return x - Math.floor(x);
    }
}

--- END FILE: .\src\random.ts ---


--- START FILE: .\src\settings.ts ---
import { RGB } from "./common";

export enum ClusteringColorSpace {
    RGB = 0,
    HSL = 1,
    LAB = 2,
}

export class Settings {
    public kMeansNrOfClusters: number = 16;
    public kMeansMinDeltaDifference: number = 1;
    public kMeansClusteringColorSpace: ClusteringColorSpace = ClusteringColorSpace.RGB;

    public kMeansColorRestrictions: Array<RGB | string> = [];

    public colorAliases: { [key: string]: RGB } = {};

    public narrowPixelStripCleanupRuns: number = 3; // 3 seems like a good compromise between removing enough narrow pixel strips to convergence. This fixes e.g. https://i.imgur.com/dz4ANz1.png

    public removeFacetsSmallerThanNrOfPoints: number = 20;
    public removeFacetsFromLargeToSmall: boolean = true;
    public maximumNumberOfFacets: number = Number.MAX_VALUE;

    public nrOfTimesToHalveBorderSegments: number = 2;

    public resizeImageIfTooLarge: boolean = true;
    public resizeImageWidth: number = 1024;
    public resizeImageHeight: number = 1024;

    public randomSeed: number = new Date().getTime();
}

--- END FILE: .\src\settings.ts ---


--- START FILE: .\src\tsconfig.json ---
{
    "compilerOptions": {
        "outFile": "../scripts/main.js",
        "noImplicitAny": true,
        "strict": true,
        "noImplicitReturns": true,
        "noImplicitThis": true,
        "strictNullChecks": true,
        "removeComments": false,
        "sourceMap": false,
        "module": "amd",
        "target": "es6",
        "lib": [
            "dom",
            "es2015",
            "es2015.promise"
        ],
        "moduleResolution": "node",
    }
}
--- END FILE: .\src\tsconfig.json ---


--- START FILE: .\src\tslint.json ---
{
    "extends": "tslint:recommended",
    "rulesDirectory": [],
    "rules": {
       "max-classes-per-file":false,
       "max-line-length":false,
       "no-console":false,
       "no-bitwise":false,
       "member-ordering":false,
       "promise-function-async":true,
       "await-promise":true,
       "only-arrow-functions":false,
       "variable-name": [ false ],
       "no-angle-bracket-type-assertion": false,
       "space-before-function-paren": false
    },
    "jsRules": {
       
    }
}
--- END FILE: .\src\tslint.json ---


--- START FILE: .\src\lib\clipboard.ts ---
// From https://stackoverflow.com/a/35576409/694640
/**
 * image pasting into canvas
 *
 * @param {string} canvas_id - canvas id
 * @param {boolean} autoresize - if canvas will be resized
 */
export class Clipboard {

    private ctrl_pressed = false;
    private command_pressed = false;
    private pasteCatcher: any;
    private paste_event_support: boolean = false;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private autoresize: boolean;

    constructor(canvas_id: string, autoresize: boolean) {
        const _self: any = this;
        this.canvas = <HTMLCanvasElement>document.getElementById(canvas_id);
        this.ctx = this.canvas.getContext("2d")!;
        this.autoresize = autoresize;

        // handlers
        // document.addEventListener("keydown", function (e) {
        //     _self.on_keyboard_action(e);
        // }, false); // firefox fix
        // document.addEventListener("keyup", function (e) {
        //     _self.on_keyboardup_action(e);
        // }, false); // firefox fix
  
        document.addEventListener("paste", function (e) {
            _self.paste_auto(e);
        }, false); // official paste handler

        this.init();
    }

    // constructor - we ignore security checks here
    public init() {
        this.pasteCatcher = document.createElement("div");
        this.pasteCatcher.setAttribute("id", "paste_ff");
        this.pasteCatcher.setAttribute("contenteditable", "");
        this.pasteCatcher.style.cssText = "opacity:0;position:fixed;top:0px;left:0px;width:10px;margin-left:-20px;";
        document.body.appendChild(this.pasteCatcher);

        const _self = this;
        // create an observer instance
        const observer = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
                if (_self.paste_event_support === true || _self.ctrl_pressed === false || mutation.type !== "childList") {
                    // we already got data in paste_auto()
                    return true;
                }

                // if paste handle failed - capture pasted object manually
                if (mutation.addedNodes.length === 1) {
                    if ((mutation.addedNodes[0] as HTMLImageElement).src !== undefined) {
                        // image
                        _self.paste_createImage((mutation.addedNodes[0] as HTMLImageElement).src);
                    }
                    // register cleanup after some time.
                    setTimeout(function () {
                        _self.pasteCatcher.innerHTML = "";
                    }, 20);
                }

                return false;
            });
        });
        const target = document.getElementById("paste_ff");
        const config = { attributes: true, childList: true, characterData: true };
        observer.observe(target as any, config);
    }

    // default paste action
    private paste_auto(e: any) {
        this.paste_event_support = false;
        if (this.pasteCatcher !== undefined) {
            this.pasteCatcher.innerHTML = "";
        }
        if (e.clipboardData) {
            const items = e.clipboardData.items;
            if (items) {
                this.paste_event_support = true;
                // access data directly
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") !== -1) {
                        // image
                        const blob = items[i].getAsFile();
                        const URLObj = window.URL || (window as any).webkitURL;
                        const source = URLObj.createObjectURL(blob);
                        this.paste_createImage(source);
                        e.preventDefault();
                        return false;
                    }
                }
            } else {
                // wait for DOMSubtreeModified event
                // https://bugzilla.mozilla.org/show_bug.cgi?id=891247
            }
        }
        return true;
    }

    // on keyboard press
    private on_keyboard_action(event: any) {
        const k = event.keyCode;
        // ctrl
        if (k === 17 || event.metaKey || event.ctrlKey) {
            if (this.ctrl_pressed === false) {
                this.ctrl_pressed = true;
            }
        }
        // v
        if (k === 86) {
            if (document.activeElement !== undefined && (document.activeElement as any).type === "text") {
                // let user paste into some input
                return false;
            }

            if (this.ctrl_pressed === true && this.pasteCatcher !== undefined) {
                this.pasteCatcher.focus();
            }
        }

        return true;
    }

    // on keyboard release
    private on_keyboardup_action(event: any) {
        // ctrl
        if (event.ctrlKey === false && this.ctrl_pressed === true) {
            this.ctrl_pressed = false;
        } else if (event.metaKey === false && this.command_pressed === true) {
            this.command_pressed = false;
            this.ctrl_pressed = false;
        }
    }
    // draw pasted image to canvas
    private paste_createImage(source: any) {
        const pastedImage = new Image();
        const self = this;
        pastedImage.onload = function () {
            if (self.autoresize === true) {
                // resize
                self.canvas.width = pastedImage.width;
                self.canvas.height = pastedImage.height;
            } else {
                // clear canvas
                self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);
            }
            self.ctx.drawImage(pastedImage, 0, 0);
        };
        pastedImage.src = source;
    }
}

--- END FILE: .\src\lib\clipboard.ts ---


--- START FILE: .\src\lib\clustering.ts ---
import { Random } from "../random";

export class Vector {

    public tag:any;
    
    constructor(public values: number[], public weight: number = 1) { }

    public distanceTo(p: Vector): number {
        let sumSquares = 0;
        for (let i: number = 0; i < this.values.length; i++) {
            sumSquares += (p.values[i] - this.values[i]) * (p.values[i] - this.values[i]);
        }

        return Math.sqrt(sumSquares);
    }

    /**
     *  Calculates the weighted average of the given points
     */
    public static average(pts: Vector[]): Vector {
        if (pts.length === 0) {
            throw Error("Can't average 0 elements");
        }

        const dims = pts[0].values.length;
        const values = [];
        for (let i: number = 0; i < dims; i++) {
            values.push(0);
        }

        let weightSum = 0;
        for (const p of pts) {
            weightSum += p.weight;

            for (let i: number = 0; i < dims; i++) {
                values[i] += p.weight * p.values[i];
            }
        }

        for (let i: number = 0; i < values.length; i++) {
            values[i] /= weightSum;
        }

        return new Vector(values);
    }
}

export class KMeans {

    public currentIteration: number = 0;
    public pointsPerCategory: Vector[][] = [];

    public centroids: Vector[] = [];
    public currentDeltaDistanceDifference: number = 0;

    constructor(private points: Vector[], public k: number, private random:Random, centroids: Vector[] | null = null) {

        if (centroids != null) {
            this.centroids = centroids;
            for (let i: number = 0; i < this.k; i++) {
                this.pointsPerCategory.push([]);
            }
        } else {
            this.initCentroids();
        }
    }

    private initCentroids() {
        for (let i: number = 0; i < this.k; i++) {
            this.centroids.push(this.points[Math.floor(this.points.length * this.random.next())]);
            this.pointsPerCategory.push([]);
        }
    }

    public step() {
        // clear category
        for (let i: number = 0; i < this.k; i++) {
            this.pointsPerCategory[i] = [];
        }

        // calculate points per centroid
        for (const p of this.points) {
            let minDist = Number.MAX_VALUE;
            let centroidIndex: number = -1;
            for (let k: number = 0; k < this.k; k++) {
                const dist = this.centroids[k].distanceTo(p);
                if (dist < minDist) {
                    centroidIndex = k;
                    minDist = dist;

                }
            }
            this.pointsPerCategory[centroidIndex].push(p);
        }

        let totalDistanceDiff = 0;

        // adjust centroids
        for (let k: number = 0; k < this.pointsPerCategory.length; k++) {
            const cat = this.pointsPerCategory[k];
            if (cat.length > 0) {
                const avg = Vector.average(cat);

                const dist = this.centroids[k].distanceTo(avg);
                totalDistanceDiff += dist;
                this.centroids[k] = avg;
            }
        }
        this.currentDeltaDistanceDifference = totalDistanceDiff;

        this.currentIteration++;
    }
}

--- END FILE: .\src\lib\clustering.ts ---


--- START FILE: .\src\lib\colorconversion.ts ---
// From https://stackoverflow.com/a/9493060/694640

/**
  * Converts an RGB color value to HSL. Conversion formula
  * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
  * Assumes r, g, and b are contained in the set [0, 255] and
  * returns h, s, and l in the set [0, 1].
  *
  * @param   Number  r       The red color value
  * @param   Number  g       The green color value
  * @param   Number  b       The blue color value
  * @return  Array           The HSL representation
  */
export function rgbToHsl(r: number, g: number, b: number) {
    r /= 255, g /= 255, b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
            default: h = 0;
        }
        h /= 6;
    }

    return [h, s, l];
}

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
export function hslToRgb(h: number, s: number, l: number) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hue2rgb = (p: number, q: number, t: number) => {
            if (t < 0) { t += 1; }
            if (t > 1) { t -= 1; }
            if (t < 1 / 6) { return p + (q - p) * 6 * t; }
            if (t < 1 / 2) { return q; }
            if (t < 2 / 3) { return p + (q - p) * (2 / 3 - t) * 6; }
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

// From https://github.com/antimatter15/rgb-lab/blob/master/color.js

export function lab2rgb(lab: number[]) {
    let y = (lab[0] + 16) / 116,
        x = lab[1] / 500 + y,
        z = y - lab[2] / 200,
        r, g, b;

    x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16 / 116) / 7.787);
    y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16 / 116) / 7.787);
    z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16 / 116) / 7.787);

    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

    r = (r > 0.0031308) ? (1.055 * Math.pow(r, 1 / 2.4) - 0.055) : 12.92 * r;
    g = (g > 0.0031308) ? (1.055 * Math.pow(g, 1 / 2.4) - 0.055) : 12.92 * g;
    b = (b > 0.0031308) ? (1.055 * Math.pow(b, 1 / 2.4) - 0.055) : 12.92 * b;

    return [Math.max(0, Math.min(1, r)) * 255,
    Math.max(0, Math.min(1, g)) * 255,
    Math.max(0, Math.min(1, b)) * 255];
}

export function rgb2lab(rgb: number[]) {
    let r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        x, y, z;

    r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

    x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
    y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
    z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;

    x = (x > 0.008856) ? Math.pow(x, 1 / 3) : (7.787 * x) + 16 / 116;
    y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y) + 16 / 116;
    z = (z > 0.008856) ? Math.pow(z, 1 / 3) : (7.787 * z) + 16 / 116;

    return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
}

--- END FILE: .\src\lib\colorconversion.ts ---


--- START FILE: .\src\lib\datastructs.ts ---

export interface IComparable {
    compareTo(other: IComparable): number;
}
export interface IHashable {
    getKey(): string;
}

export interface IHeapItem extends IComparable, IHashable {

}

export class Map<TValue> {
    private obj: any;

    constructor() {
        this.obj = {};
    }

    public containsKey(key: string): boolean {
        return key in this.obj;
    }

    public getKeys(): string[] {
        const keys: string[] = [];
        for (const el in this.obj) {
            if (this.obj.hasOwnProperty(el)) {
                keys.push(el);
            }
        }
        return keys;
    }

    public get(key: string): TValue | null {
        const o = this.obj[key];
        if (typeof o === "undefined") {
            return null;
        } else {
            return o as TValue;
        }
    }

    public put(key: string, value: TValue): void {
        this.obj[key] = value;
    }

    public remove(key: string) {
        delete this.obj[key];
    }

    public clone(): Map<TValue> {
        const m = new Map<TValue>();
        m.obj = {};
        for (const p in this.obj) {
            m.obj[p] = this.obj[p];
        }
        return m;
    }
}
class Heap<T extends IHeapItem> {

    private array: T[];
    private keyMap: Map<number>;

    constructor() {
        this.array = [];
        this.keyMap = new Map<number>();
    }

    public add(obj: T): void {
        if (this.keyMap.containsKey(obj.getKey())) {
            throw new Error("Item with key " + obj.getKey() + " already exists in the heap");
        }

        this.array.push(obj);
        this.keyMap.put(obj.getKey(), this.array.length - 1);
        this.checkParentRequirement(this.array.length - 1);
    }

    public replaceAt(idx: number, newobj: T): void {
        this.array[idx] = newobj;
        this.keyMap.put(newobj.getKey(), idx);
        this.checkParentRequirement(idx);
        this.checkChildrenRequirement(idx);
    }

    public shift(): T {
        return this.removeAt(0);
    }

    public remove(obj: T): void {
        const idx = this.keyMap.get(obj.getKey());

        if (idx === -1) {
            return;
        }
        this.removeAt(idx!);
    }

    public removeWhere(predicate: (el: T) => boolean) {
        const itemsToRemove: T[] = [];
        for (let i: number = this.array.length - 1; i >= 0; i--) {
            if (predicate(this.array[i])) {
                itemsToRemove.push(this.array[i]);
            }
        }
        for (const el of itemsToRemove) {
            this.remove(el);
        }
        for (const el of this.array) {
            if (predicate(el)) {
                console.log("Idx of element not removed: " + this.keyMap.get(el.getKey()));
                throw new Error("element not removed: " + el.getKey());
            }
        }
    }

    private removeAt(idx: number): T {
        const obj: any = this.array[idx];
        this.keyMap.remove(obj.getKey());
        const isLastElement: boolean = idx === this.array.length - 1;
        if (this.array.length > 0) {
            const newobj: any = this.array.pop();
            if (!isLastElement && this.array.length > 0) {
                this.replaceAt(idx, newobj);
            }
        }
        return obj;
    }

    public foreach(func: (el: T) => void) {
        const arr = this.array.sort((e, e2) => e.compareTo(e2));
        for (const el of arr) {
            func(el);
        }
    }

    public peek(): T {
        return this.array[0];
    }

    public contains(key: string) {
        return this.keyMap.containsKey(key);
    }

    public at(key: string): T | null {
        const obj = this.keyMap.get(key);
        if (typeof obj === "undefined") {
            return null;
        } else {
            return this.array[obj as number];
        }
    }

    public size(): number {
        return this.array.length;
    }

    public checkHeapRequirement(item: T) {
        const idx = this.keyMap.get(item.getKey()) as number;
        if (idx != null) {
            this.checkParentRequirement(idx);
            this.checkChildrenRequirement(idx);
        }
    }

    private checkChildrenRequirement(idx: number): void {
        let stop: boolean = false;
        while (!stop) {
            const left: number = this.getLeftChildIndex(idx);
            let right: number = left === -1 ? -1 : left + 1;

            if (left === -1) {
                return;
            }
            if (right >= this.size()) {
                right = -1;
            }

            let minIdx: number;
            if (right === -1) {
                minIdx = left;
            } else {
                minIdx = (this.array[left].compareTo(this.array[right]) < 0) ? left : right;
            }

            if (this.array[idx].compareTo(this.array[minIdx]) > 0) {
                this.swap(idx, minIdx);
                idx = minIdx; // iteratively instead of recursion for this.checkChildrenRequirement(minIdx);
            } else {
                stop = true;
            }
        }
    }

    private checkParentRequirement(idx: number): void {
        let curIdx: number = idx;
        let parentIdx: number = Heap.getParentIndex(curIdx);
        while (parentIdx >= 0 && this.array[parentIdx].compareTo(this.array[curIdx]) > 0) {
            this.swap(curIdx, parentIdx);

            curIdx = parentIdx;
            parentIdx = Heap.getParentIndex(curIdx);
        }
    }

    public dump(): void {
        if (this.size() === 0) {
            return;
        }

        const idx = 0;
        const leftIdx = this.getLeftChildIndex(idx);
        const rightIdx = leftIdx + 1;

        console.log(this.array);
        console.log("--- keymap ---");
        console.log(this.keyMap);
    }

    private swap(i: number, j: number): void {
        this.keyMap.put(this.array[i].getKey(), j);
        this.keyMap.put(this.array[j].getKey(), i);

        const tmp: T = this.array[i];
        this.array[i] = this.array[j];
        this.array[j] = tmp;
    }

    private getLeftChildIndex(curIdx: number): number {
        const idx: number = ((curIdx + 1) * 2) - 1;
        if (idx >= this.array.length) {
            return -1;
        } else {
            return idx;
        }
    }

    private static getParentIndex(curIdx: number): number {
        if (curIdx === 0) {
            return -1;
        }

        return Math.floor((curIdx + 1) / 2) - 1;
    }

    public clone(): Heap<T> {
        const h = new Heap<T>();
        h.array = this.array.slice(0);
        h.keyMap = this.keyMap.clone();
        return h;
    }
}

export class PriorityQueue<T extends IHeapItem> {

    private heap: Heap<T> = new Heap<T>();

    public enqueue(obj: T): void {
        this.heap.add(obj);
    }

    public peek(): T {
        return this.heap.peek();
    }

    public updatePriority(key: T) {
        this.heap.checkHeapRequirement(key);
    }

    public get(key: string): T | null {
        return this.heap.at(key);
    }

    get size(): number {
        return this.heap.size();
    }

    public dequeue(): T {
        return this.heap.shift();
    }

    public dump() {
        this.heap.dump();
    }

    public contains(key: string) {
        return this.heap.contains(key);
    }
    public removeWhere(predicate: (el: T) => boolean) {
        this.heap.removeWhere(predicate);
    }

    public foreach(func: (el: T) => void) {
        this.heap.foreach(func);
    }

    public clone(): PriorityQueue<T> {
        const p = new PriorityQueue<T>();
        p.heap = this.heap.clone();
        return p;
    }
}

--- END FILE: .\src\lib\datastructs.ts ---


--- START FILE: .\src\lib\fill.ts ---

// Faster flood fill from
// http://www.adammil.net/blog/v126_A_More_Efficient_Flood_Fill.html

export function fill(x: number, y: number, width: number, height: number, visited: ((i: number, j: number) => boolean), setFill: ((i: number, j: number) => void)) {

    // at this point, we know array[y,x] is clear, and we want to move as far as possible to the upper-left. moving
    // up is much more important than moving left, so we could try to make this smarter by sometimes moving to
    // the right if doing so would allow us to move further up, but it doesn't seem worth the complexit
    let xx = x;
    let yy = y;
    while (true) {
        const ox = xx;
        const oy = yy;
        while (yy !== 0 && !visited(xx, yy - 1)) { yy--; }
        while (xx !== 0 && !visited(xx - 1, yy)) { xx--; }
        if (xx === ox && yy === oy) { break; }
    }
    fillCore(xx, yy, width, height, visited, setFill);

}

function fillCore(x: number, y: number, width: number, height: number, visited: ((i: number, j: number) => boolean), setFill: ((i: number, j: number) => void)) {

    // at this point, we know that array[y,x] is clear, and array[y-1,x] and array[y,x-1] are set.
    // we'll begin scanning down and to the right, attempting to fill an entire rectangular block
    let lastRowLength = 0; // the number of cells that were clear in the last row we scanned
    do {
        let rowLength = 0;
        let sx = x; // keep track of how long this row is. sx is the starting x for the main scan below
        // now we want to handle a case like |***|, where we fill 3 cells in the first row and then after we move to
        // the second row we find the first  | **| cell is filled, ending our rectangular scan. rather than handling
        // this via the recursion below, we'll increase the starting value of 'x' and reduce the last row length to
        // match. then we'll continue trying to set the narrower rectangular block
        if (lastRowLength !== 0 && visited(x, y)) {
            do {
                if (--lastRowLength === 0) { return; } // shorten the row. if it's full, we're done
            } while (visited(++x, y)); // otherwise, update the starting point of the main scan to match
            sx = x;
        } else {
            for (; x !== 0 && !visited(x - 1, y); rowLength++ , lastRowLength++) {
                x--;
                setFill(x, y); // to avoid scanning the cells twice, we'll fill them and update rowLength here
                // if there's something above the new starting point, handle that recursively. this deals with cases
                // like |* **| when we begin filling from (2,0), move down to (2,1), and then move left to (0,1).
                // the  |****| main scan assumes the portion of the previous row from x to x+lastRowLength has already
                // been filled. adjusting x and lastRowLength breaks that assumption in this case, so we must fix it
                if (y !== 0 && !visited(x, y - 1)) { fill(x, y - 1, width, height, visited, setFill); } // use _Fill since there may be more up and left
            }
        }

        // now at this point we can begin to scan the current row in the rectangular block. the span of the previous
        // row from x (inclusive) to x+lastRowLength (exclusive) has already been filled, so we don't need to
        // check it. so scan across to the right in the current row
        for (; sx < width && !visited(sx, y); rowLength++ , sx++) { setFill(sx, y); }
        // now we've scanned this row. if the block is rectangular, then the previous row has already been scanned,
        // so we don't need to look upwards and we're going to scan the next row in the next iteration so we don't
        // need to look downwards. however, if the block is not rectangular, we may need to look upwards or rightwards
        // for some portion of the row. if this row was shorter than the last row, we may need to look rightwards near
        // the end, as in the case of |*****|, where the first row is 5 cells long and the second row is 3 cells long.
        // we must look to the right  |*** *| of the single cell at the end of the second row, i.e. at (4,1)
        if (rowLength < lastRowLength) {
            for (const end = x + lastRowLength; ++sx < end;) {                                          // there. any clear cells would have been connected to the previous
                if (!visited(sx, y)) { fillCore(sx, y, width, height, visited, setFill); } // row. the cells up and left must be set so use FillCore
            }
        } else if (rowLength > lastRowLength && y !== 0) {
            for (let ux = x + lastRowLength; ++ux < sx;) {
                if (!visited(ux, y - 1)) { fill(ux, y - 1, width, height, visited, setFill); } // since there may be clear cells up and left, use _Fill
            }
        }
        lastRowLength = rowLength; // record the new row length
    } while (lastRowLength !== 0 && ++y < height); // if we get to a full row or to the bottom, we're done

}

--- END FILE: .\src\lib\fill.ts ---


--- START FILE: .\src\lib\polylabel.ts ---
import { IComparable, IHeapItem, PriorityQueue } from "./datastructs";

// This is a typescript port of https://github.com/mapbox/polylabel to calculate the pole of inaccessibility quickly

type Polygon = PolygonRing[];
type PolygonRing = Point[];

interface Point {
    x: number;
    y: number;
}
interface PointResult {
    pt: Point;
    distance: number;
}

export function polylabel(polygon: Polygon, precision: number = 1.0): PointResult {

    // find the bounding box of the outer ring
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = Number.MIN_VALUE;
    let maxY = Number.MIN_VALUE;

    for (let i = 0; i < polygon[0].length; i++) {
        const p = polygon[0][i];
        if (p.x < minX) { minX = p.x; }
        if (p.y < minY) { minY = p.y; }
        if (p.x > maxX) { maxX = p.x; }
        if (p.y > maxY) { maxY = p.y; }
    }

    const width = maxX - minX;
    const height = maxY - minY;
    const cellSize = Math.min(width, height);
    let h = cellSize / 2;

    // a priority queue of cells in order of their "potential" (max distance to polygon)
    const cellQueue = new PriorityQueue<Cell>();

    if (cellSize === 0) { return { pt: { x: minX, y: minY }, distance: 0 }; }

    // cover polygon with initial cells
    for (let x = minX; x < maxX; x += cellSize) {
        for (let y = minY; y < maxY; y += cellSize) {
            cellQueue.enqueue(new Cell(x + h, y + h, h, polygon));
        }
    }

    // take centroid as the first best guess
    let bestCell = getCentroidCell(polygon);

    // special case for rectangular polygons
    const bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
    if (bboxCell.d > bestCell.d) { bestCell = bboxCell; }

    let numProbes = cellQueue.size;

    while (cellQueue.size > 0) {
        // pick the most promising cell from the queue
        const cell = cellQueue.dequeue();

        // update the best cell if we found a better one
        if (cell.d > bestCell.d) {
            bestCell = cell;
        }

        // do not drill down further if there's no chance of a better solution
        if (cell.max - bestCell.d <= precision) { continue; }

        // split the cell into four cells
        h = cell.h / 2;
        cellQueue.enqueue(new Cell(cell.x - h, cell.y - h, h, polygon));
        cellQueue.enqueue(new Cell(cell.x + h, cell.y - h, h, polygon));
        cellQueue.enqueue(new Cell(cell.x - h, cell.y + h, h, polygon));
        cellQueue.enqueue(new Cell(cell.x + h, cell.y + h, h, polygon));
        numProbes += 4;
    }

    return { pt: { x: bestCell.x, y: bestCell.y }, distance: bestCell.d };
}

class Cell implements IHeapItem {
    public x: number; // cell center x
    public y: number; // cell center y
    public h: number; // half the cell size
    public d: number; // distance from cell center to polygon
    public max: number; // max distance to polygon within a cell
    constructor(x: number, y: number, h: number, polygon: Polygon) {
        this.x = x;
        this.y = y;
        this.h = h;
        this.d = pointToPolygonDist(x, y, polygon);
        this.max = this.d + this.h * Math.SQRT2;
    }

    public compareTo(other: IComparable): number {
        return (other as Cell).max - this.max;
    }

    public getKey() {
        return this.x + "," + this.y;
    }
}

// get squared distance from a point px,py to a segment [a-b]
function getSegDistSq(px: number, py: number, a: Point, b: Point) {

    let x = a.x;
    let y = a.y;
    let dx = b.x - x;
    let dy = b.y - y;

    if (dx !== 0 || dy !== 0) {
        const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = b.x;
            y = b.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

/**
 * Signed distance from point to polygon outline (negative if point is outside)
 */
export function pointToPolygonDist(x: number, y: number, polygon: Polygon): number {
    let inside = false;
    let minDistSq = Infinity;

    for (let k = 0; k < polygon.length; k++) {
        const ring = polygon[k];

        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            const a = ring[i];
            const b = ring[j];

            if ((a.y > y !== b.y > y) &&
                (x < (b.x - a.x) * (y - a.y) / (b.y - a.y) + a.x)) { inside = !inside; }

            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
        }
    }

    return (inside ? 1 : -1) * Math.sqrt(minDistSq);
}

// get polygon centroid
function getCentroidCell(polygon: Polygon) {
    let area = 0;
    let x = 0;
    let y = 0;
    const points = polygon[0];

    for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        const a = points[i];
        const b = points[j];
        const f = a.x * b.y - b.x * a.y;
        x += (a.x + b.x) * f;
        y += (a.y + b.y) * f;
        area += f * 3;
    }
    if (area === 0) { return new Cell(points[0].x, points[0].y, 0, polygon); }
    return new Cell(x / area, y / area, 0, polygon);
}

--- END FILE: .\src\lib\polylabel.ts ---


--- START FILE: .\src\lib\strokeFont.ts ---
// Single-line stroke font utilities for laser-friendly SVG labels.
// Generates centerline strokes (no outline contours).

export type Vec2 = [number, number];
export type Stroke = Vec2[];

export interface Glyph {
  width: number;      // glyph width in font units
  strokes: Stroke[];  // each stroke is a polyline
}

/**
 * Minimal single-line digit set in a 0..10 coordinate system.
 * Designed for laser/plotter use.
 */
export const SIMPLE_DIGITS: Record<string, Glyph> = {
  "0": { width: 8, strokes: [
    [[1,1],[7,1],[7,9],[1,9],[1,1]]
  ]},
  "1": { width: 6, strokes: [
    [[3,1],[3,9]]
  ]},
  "2": { width: 8, strokes: [
    [[1,2],[7,2],[7,5],[1,9],[7,9]]
  ]},
  "3": { width: 8, strokes: [
    [[1,2],[7,2],[4,5],[7,5],[4,5],[7,9],[1,9]]
  ]},
  "4": { width: 8, strokes: [
    [[7,9],[7,1]],
    [[1,6],[7,6]],
    [[1,9],[1,6]]
  ]},
  "5": { width: 8, strokes: [
    [[7,2],[1,2],[1,5],[7,5],[7,9],[1,9]]
  ]},
  "6": { width: 8, strokes: [
    [[7,2],[2,2],[1,5],[1,9],[7,9],[7,5],[1,5]]
  ]},
  "7": { width: 8, strokes: [
    [[1,2],[7,2],[3,9]]
  ]},
  "8": { width: 8, strokes: [
    [[1,5],[1,2],[7,2],[7,5],[1,5],[1,9],[7,9],[7,5]]
  ]},
  "9": { width: 8, strokes: [
    [[7,6],[1,6],[1,2],[7,2],[7,9],[2,9]]
  ]},
  " ": { width: 4, strokes: [] },
};

export interface StrokeTextPath {
  d: string;      // SVG path data in font units
  width: number;  // width in font units
  height: number; // height in font units
}

/**
 * Converts a string to SVG path data using a single-line stroke font.
 * Pen-up between strokes: each stroke starts with 'M'.
 */
export function strokeTextToPath(
  text: string,
  letterSpacing: number = 1,
  font: Record<string, Glyph> = SIMPLE_DIGITS
): StrokeTextPath {
  const height = 10;
  let x = 0;
  const parts: string[] = [];

  for (const ch of text) {
    const g = font[ch];
    if (!g) continue;

    for (const stroke of g.strokes) {
      if (stroke.length < 2) continue;
      const [p0x, p0y] = stroke[0];
      parts.push(`M ${x + p0x} ${p0y}`);
      for (let i = 1; i < stroke.length; i++) {
        const [px, py] = stroke[i];
        parts.push(`L ${x + px} ${py}`);
      }
    }

    x += g.width + letterSpacing;
  }

  const width = Math.max(0, x - letterSpacing);
  return { d: parts.join(" "), width, height };
}

--- END FILE: .\src\lib\strokeFont.ts ---


--- START FILE: .\src\lib\svgLaserPrep.ts ---
// Prepare SVG for laser engraving: keep strokes (borders + single-line labels), remove fills.

export interface LaserPrepOptions {
  removeFills?: boolean;
  forceStrokeColor?: string;
  removeText?: boolean;
}

function isNone(v: string | null | undefined): boolean {
  if (v == null) return true;
  const t = v.trim().toLowerCase();
  return t === "" || t === "none";
}

function numAttr(el: Element, name: string, fallback: number): number {
  const v = el.getAttribute(name);
  if (v == null) return fallback;
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : fallback;
}

export function prepareSvgForLaser(svgMarkup: string, options: LaserPrepOptions = {}): string {
  const opts: Required<LaserPrepOptions> = {
    removeFills: options.removeFills ?? true,
    forceStrokeColor: options.forceStrokeColor ?? "",
    removeText: options.removeText ?? true,
  };

  const parser = new DOMParser();
  const doc = parser.parseFromString(svgMarkup, "image/svg+xml");
  const svgEl = doc.documentElement;

  if (opts.removeText) {
    const texts = Array.from(svgEl.getElementsByTagName("text"));
    for (const t of texts) t.parentNode?.removeChild(t);
  }

  const candidates = Array.from(svgEl.querySelectorAll("path, rect, circle, ellipse, polygon, polyline"));

  for (const el of candidates) {
    const fill = el.getAttribute("fill");
    const stroke = el.getAttribute("stroke");
    const strokeWidth = numAttr(el, "stroke-width", 1);

    const hasStroke = !isNone(stroke) && strokeWidth > 0;
    const hasFill = !isNone(fill);

    if (opts.removeFills && hasFill) {
      if (!hasStroke) {
        el.parentNode?.removeChild(el);
        continue;
      }
      el.setAttribute("fill", "none");
    }

    if (opts.forceStrokeColor && hasStroke) {
      el.setAttribute("stroke", opts.forceStrokeColor);
    }
  }

  svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");

  const serializer = new XMLSerializer();
  return serializer.serializeToString(svgEl);
}

--- END FILE: .\src\lib\svgLaserPrep.ts ---


--- START FILE: .\src\lib\svgTextToSingleLine.ts ---
// Converts SVG <text> numeric labels into single-line <path> strokes.
// Tuned for paint-by-numbers labels 0â€“50 (multi-digit): tighter spacing for 2-digit.

import { strokeTextToPath } from "./strokeFont";

export interface SingleLineLabelOptions {
  strokeWidth?: number;          // SVG user units
  strokeColor?: string;          // optional override
  preserveOriginalColor?: boolean;
  letterSpacing?: number;        // font units
}

function numAttr(el: Element, name: string, fallback: number): number {
  const v = el.getAttribute(name);
  if (v == null) return fallback;
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : fallback;
}

/**
 * Replace all <text> elements that contain only digits with single-line <path>.
 */
export function convertSvgTextToSingleLine(svgMarkup: string, options: SingleLineLabelOptions = {}): string {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgMarkup, "image/svg+xml");
  const svgEl = doc.documentElement;

  const texts = Array.from(svgEl.getElementsByTagName("text"));

  for (const t of texts) {
    const label = (t.textContent ?? "").trim();
    if (!label) continue;
    if (!/^\d+$/.test(label)) continue;

    const x = numAttr(t, "x", 0);
    const y = numAttr(t, "y", 0);

    const fontSize = numAttr(t, "font-size", 12);
    const fill = t.getAttribute("fill") || "black";

    // default: tighter spacing for 2+ digits, looser for 1 digit
    const defaultSpacing = label.length > 1 ? 1 : 2;
    const letterSpacing = options.letterSpacing ?? defaultSpacing;

    const { d, width, height } = strokeTextToPath(label, letterSpacing);
    if (!d) continue;

    // Scale so that glyph height equals fontSize.
    const scale = fontSize / height;

    // Keep horizontal alignment similar to <text>.
    const anchor = (t.getAttribute("text-anchor") || "start").toLowerCase();
    let xOffset = 0;
    const scaledW = width * scale;
    if (anchor === "middle") xOffset = -scaledW / 2;
    else if (anchor === "end") xOffset = -scaledW;

    // Approximate vertical baseline.
    const dominant = (t.getAttribute("dominant-baseline") || "").toLowerCase();
    let yOffset = 0;
    const scaledH = height * scale;
    if (dominant.includes("middle") || dominant.includes("central")) yOffset = -scaledH / 2;
    else yOffset = -scaledH * 0.8;

    const path = doc.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d);
    path.setAttribute("fill", "none");

    const stroke = (options.preserveOriginalColor ?? true) ? fill : (options.strokeColor || fill);
    path.setAttribute("stroke", stroke);
    path.setAttribute("stroke-width", String(options.strokeWidth ?? 0.4));

    // Keep stroke width constant even when scaled.
    path.setAttribute("vector-effect", "non-scaling-stroke");
    path.setAttribute("stroke-linecap", "round");
    path.setAttribute("stroke-linejoin", "round");

    path.setAttribute("transform", `translate(${x + xOffset},${y + yOffset}) scale(${scale})`);

    t.parentNode?.replaceChild(path, t);
  }

  const serializer = new XMLSerializer();
  return serializer.serializeToString(svgEl);
}

--- END FILE: .\src\lib\svgTextToSingleLine.ts ---


--- START FILE: .\src\structs\boundingbox.ts ---
export class BoundingBox {

    public minX: number = Number.MAX_VALUE;
    public minY: number = Number.MAX_VALUE;
    public maxX: number = Number.MIN_VALUE;
    public maxY: number = Number.MIN_VALUE;

    get width(): number {
        return this.maxX - this.minX + 1;
    }
    get height(): number {
        return this.maxY - this.minY + 1;
    }
}

--- END FILE: .\src\structs\boundingbox.ts ---


--- START FILE: .\src\structs\point.ts ---

export class Point {
    constructor(public x: number, public y: number) { }

    public distanceTo(pt: Point): number {

        // don't do euclidean because then neighbours should be diagonally as well
        // because sqrt(2) < 2
        //  return Math.sqrt((pt.x - this.x) * (pt.x - this.x) + (pt.y - this.y) * (pt.y - this.y));
        return Math.abs(pt.x - this.x) + Math.abs(pt.y - this.y);
    }

    public distanceToCoord(x: number, y: number): number {
        // don't do euclidean because then neighbours should be diagonally as well
        // because sqrt(2) < 2
        //  return Math.sqrt((pt.x - this.x) * (pt.x - this.x) + (pt.y - this.y) * (pt.y - this.y));
        return Math.abs(x - this.x) + Math.abs(y - this.y);
    }
}

--- END FILE: .\src\structs\point.ts ---


--- START FILE: .\src\structs\typedarrays.ts ---

export class Uint32Array2D {
    private arr: Uint32Array;
    constructor(private width: number, private height: number) {
        this.arr = new Uint32Array(width * height);
    }

    public get(x: number, y: number) {
        return this.arr[y * this.width + x];
    }
    public set(x: number, y: number, value: number) {
        this.arr[y * this.width + x] = value;
    }
}

export class Uint8Array2D {
    private arr: Uint8Array;
    constructor(private width: number, private height: number) {
        this.arr = new Uint8Array(width * height);
    }
    public get(x: number, y: number) {
        return this.arr[y * this.width + x];
    }

    public set(x: number, y: number, value: number) {
        this.arr[y * this.width + x] = value;
    }

    public matchAllAround(x: number, y: number, value: number) {
        const idx = y * this.width + x;
        return (x - 1 >= 0 && this.arr[idx - 1] === value) &&
            (y - 1 >= 0 && this.arr[idx - this.width] === value) &&
            (x + 1 < this.width && this.arr[idx + 1] === value) &&
            (y + 1 < this.height && this.arr[idx + this.width] === value);
    }
}

export class BooleanArray2D {
    private arr: Uint8Array;
    constructor(private width: number, private height: number) {
        this.arr = new Uint8Array(width * height);
    }

    public get(x: number, y: number) {
        return this.arr[y * this.width + x] !== 0;
    }
    public set(x: number, y: number, value: boolean) {
        this.arr[y * this.width + x] = value ? 1 : 0;
    }
}

--- END FILE: .\src\structs\typedarrays.ts ---


--- START FILE: .\src-cli\main.js.map ---
{"version":3,"file":"main.js","sourceRoot":"","sources":["main.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+BAAiC;AACjC,uBAAyB;AACzB,mCAAqC;AACrC,2BAA6B;AAC7B,iCAAmC;AACnC,4EAA+D;AAE/D,oEAAmE;AACnE,8DAA6D;AAC7D,oDAAmD;AACnD,4DAA2D;AAC3D,0DAAqD;AACrD,oDAAmD;AACnD,4CAA2C;AAC3C,8CAA6C;AAC7C,IAAM,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AAEnC;IAAA;QACW,SAAI,GAAW,EAAE,CAAC;QAClB,kBAAa,GAAY,IAAI,CAAC;QAC9B,kBAAa,GAAY,IAAI,CAAC;QAC9B,mBAAc,GAAY,IAAI,CAAC;QAC/B,sBAAiB,GAAW,CAAC,CAAC;QAE9B,gBAAW,GAAW,EAAE,CAAC;QACzB,iBAAY,GAAW,OAAO,CAAC;QAE/B,aAAQ,GAA0B,KAAK,CAAC;QACxC,oBAAe,GAAW,EAAE,CAAC;IACxC,CAAC;IAAD,+BAAC;AAAD,CAAC,AAZD,IAYC;AAED;IAA0B,+BAAQ;IAAlC;QAAA,qEAIC;QAFU,oBAAc,GAA+B,EAAE,CAAC;;IAE3D,CAAC;IAAD,kBAAC;AAAD,CAAC,AAJD,CAA0B,mBAAQ,GAIjC;AAED,SAAe,IAAI;;;;;;oBACT,IAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvC,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC;oBACnB,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC;oBAEvB,IAAI,OAAO,SAAS,KAAK,WAAW,IAAI,OAAO,OAAO,KAAK,WAAW,EAAE;wBACpE,OAAO,CAAC,GAAG,CAAC,kEAAkE,CAAC,CAAC;wBAChF,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACnB;oBAEG,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC;oBACxB,IAAI,OAAO,UAAU,KAAK,WAAW,EAAE;wBACnC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,eAAe,CAAC,CAAC;qBAC1D;yBAAM;wBACH,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;4BAC9B,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,UAAU,CAAC,CAAC;yBACrD;qBACJ;oBAEK,QAAQ,GAAgB,OAAO,CAAC,UAAU,CAAC,CAAC;oBAEtC,qBAAM,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,EAAA;;oBAAvC,GAAG,GAAG,SAAiC;oBACvC,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;oBAC/C,GAAG,GAAG,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAC/B,GAAG,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;oBACxC,OAAO,GAAG,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;oBAExD,qBAAqB;oBACrB,IAAI,QAAQ,CAAC,qBAAqB,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC,gBAAgB,IAAI,CAAC,CAAC,MAAM,GAAG,QAAQ,CAAC,iBAAiB,CAAC,EAAE;wBAC9G,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;wBAChB,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;wBACtB,IAAI,KAAK,GAAG,QAAQ,CAAC,gBAAgB,EAAE;4BAC7B,QAAQ,GAAG,QAAQ,CAAC,gBAAgB,CAAC;4BACrC,SAAS,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC,gBAAgB,CAAC;4BACjE,KAAK,GAAG,QAAQ,CAAC;4BACjB,MAAM,GAAG,SAAS,CAAC;yBACtB;wBACD,IAAI,MAAM,GAAG,QAAQ,CAAC,iBAAiB,EAAE;4BAC/B,SAAS,GAAG,QAAQ,CAAC,iBAAiB,CAAC;4BACvC,QAAQ,GAAG,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;4BAC5C,KAAK,GAAG,QAAQ,CAAC;4BACjB,MAAM,GAAG,SAAS,CAAC;yBACtB;wBAEK,UAAU,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;wBACtD,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC;wBACzB,UAAU,CAAC,MAAM,GAAG,MAAM,CAAC;wBAC3B,UAAU,CAAC,UAAU,CAAC,IAAI,CAAE,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;wBAC/D,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC;wBAChB,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC;wBAClB,GAAG,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;wBAC/C,OAAO,GAAG,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;wBAEpD,OAAO,CAAC,GAAG,CAAC,sBAAoB,KAAK,SAAI,MAAQ,CAAC,CAAC;qBACtD;oBAED,OAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;oBACpC,OAAO,GAAG,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;oBAC7D,SAAS,GAAG,OAAO,CAAC,UAAU,CAAC,IAAI,CAAE,CAAC;oBAC5C,SAAS,CAAC,SAAS,GAAG,OAAO,CAAC;oBAC9B,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;oBAElD,aAAa,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;oBAClF,qBAAM,uCAAY,CAAC,qBAAqB,CAAC,OAAO,EAAE,aAAa,EAAE,GAAG,EAAE,QAAQ,EAAE,UAAC,MAAM;4BACnF,IAAM,QAAQ,GAAG,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,8BAA8B,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,8BAA8B,CAAC,CAAC,GAAG,GAAG,CAAC;4BAC3H,SAAS,CAAC,YAAY,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;wBAChD,CAAC,CAAC,EAAA;;oBAHF,SAGE,CAAC;oBAEG,cAAc,GAAG,uCAAY,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC;oBAE9D,WAAW,GAAG,IAAI,6BAAW,EAAE,CAAC;yBAChC,CAAA,OAAO,QAAQ,CAAC,2BAA2B,KAAK,WAAW,IAAI,QAAQ,CAAC,2BAA2B,KAAK,CAAC,CAAA,EAAzG,wBAAyG;oBACzG,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;oBACjB,qBAAM,2BAAY,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,EAAE,cAAc,CAAC,eAAe,EAAE,UAAC,QAAQ;4BAC/G,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,WAAW,GAAG,SAEZ,CAAC;oBAEH,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;oBAC/B,qBAAM,2BAAY,CAAC,YAAY,CAAC,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC,qBAAqB,EAAE,cAAc,CAAC,aAAa,EAAE,WAAW,EAAE,cAAc,CAAC,eAAe,EAAE,UAAC,QAAQ;4BACnO,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,SAEE,CAAC;;;oBAEM,GAAG,GAAG,CAAC;;;yBAAE,CAAA,GAAG,GAAG,QAAQ,CAAC,2BAA2B,CAAA;oBACxD,OAAO,CAAC,GAAG,CAAC,8BAA8B,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;oBACxD,+BAA+B;oBAC/B,qBAAM,uCAAY,CAAC,8BAA8B,CAAC,cAAc,CAAC,EAAA;;oBADjE,+BAA+B;oBAC/B,SAAiE,CAAC;oBAElE,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;oBACjB,qBAAM,2BAAY,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,EAAE,cAAc,CAAC,eAAe,EAAE,UAAC,QAAQ;4BAC/G,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,WAAW,GAAG,SAEZ,CAAC;oBAEH,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;oBAC/B,qBAAM,2BAAY,CAAC,YAAY,CAAC,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC,qBAAqB,EAAE,cAAc,CAAC,aAAa,EAAE,WAAW,EAAE,cAAc,CAAC,eAAe,EAAE,UAAC,QAAQ;4BACnO,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,SAEE,CAAC;;;oBAbuD,GAAG,EAAE,CAAA;;;oBAmBvE,OAAO,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC;oBAClC,qBAAM,qCAAiB,CAAC,qBAAqB,CAAC,WAAW,EAAE,UAAC,QAAQ;4BAChE,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,SAEE,CAAC;oBAEH,OAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;oBAC1C,qBAAM,2CAAoB,CAAC,wBAAwB,CAAC,WAAW,EAAE,QAAQ,CAAC,8BAA8B,EAAE,UAAC,QAAQ;4BAC/G,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,SAEE,CAAC;oBAEH,OAAO,CAAC,GAAG,CAAC,2BAA2B,CAAC,CAAC;oBACzC,qBAAM,mCAAgB,CAAC,qBAAqB,CAAC,WAAW,EAAE,UAAC,QAAQ;4BAC/D,WAAW;wBACf,CAAC,CAAC,EAAA;;oBAFF,SAEE,CAAC;wCAEQ,OAAO;;;;;oCACd,OAAO,CAAC,GAAG,CAAC,wBAAwB,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;oCAErD,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,WAAW,EAAE;wCACzC,OAAO,CAAC,QAAQ,GAAG,KAAK,CAAC;qCAC5B;oCAEK,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,OAAO,CAAC,QAAQ,CAAC;oCACpL,qBAAM,SAAS,CAAC,WAAW,EAAE,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,iBAAiB,EAAE,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,cAAc,EAAE,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,YAAY,CAAC,EAAA;;oCAAlN,SAAS,GAAG,SAAsM;yCAEpN,CAAA,OAAO,CAAC,QAAQ,KAAK,KAAK,CAAA,EAA1B,wBAA0B;oCAC1B,EAAE,CAAC,aAAa,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;;;yCACrC,CAAA,OAAO,CAAC,QAAQ,KAAK,KAAK,CAAA,EAA1B,wBAA0B;oCAEb,qBAAM,IAAI,OAAO,CAAS,UAAC,IAAI,EAAE,MAAM;4CACvD,OAAO,CAAC,SAAS,EAAE,UAAU,KAAY,EAAE,MAAc;gDACrD,IAAI,KAAK,EAAE;oDACP,MAAM,CAAC,KAAK,CAAC,CAAC;iDACjB;qDAAM;oDACH,IAAI,CAAC,MAAM,CAAC,CAAC;iDAChB;4CACL,CAAC,CAAC,CAAC;wCACP,CAAC,CAAC,EAAA;;oCARI,WAAW,GAAG,SAQlB;oCACF,EAAE,CAAC,aAAa,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;;;yCACvC,CAAA,OAAO,CAAC,QAAQ,KAAK,KAAK,CAAA,EAA1B,wBAA0B;oCACb,qBAAM,IAAI,OAAO,CAAS,UAAC,IAAI,EAAE,MAAM;4CACvD,OAAO,CAAC,SAAS,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,eAAe,EAAE,EAAE,UAAU,KAAY,EAAE,MAAc;gDAC1G,IAAI,KAAK,EAAE;oDACP,MAAM,CAAC,KAAK,CAAC,CAAC;iDACjB;qDAAM;oDACH,IAAI,CAAC,MAAM,CAAC,CAAC;iDAChB;4CACL,CAAC,CAAC,CAAC;wCACP,CAAC,CAAC,EAAA;;oCARI,WAAW,GAAG,SAQlB;oCACF,EAAE,CAAC,aAAa,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;;;;;;0BAlCT,EAAvB,KAAA,QAAQ,CAAC,cAAc;;;yBAAvB,CAAA,cAAuB,CAAA;oBAAlC,OAAO;kDAAP,OAAO;;;;;oBAAI,IAAuB,CAAA;;;oBAsC7C,OAAO,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAC;oBACjC,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC;oBAEzJ,cAAc,GAAa,EAAE,CAAC;oBACpC,WAAgD,EAA5B,KAAA,cAAc,CAAC,aAAa,EAA5B,cAA4B,EAA5B,IAA4B,EAAE;wBAAvC,KAAK;wBACZ,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBAC1B;oBAED,WAAsC,EAAlB,KAAA,WAAW,CAAC,MAAM,EAAlB,cAAkB,EAAlB,IAAkB,EAAE;wBAA7B,KAAK;wBACZ,IAAI,KAAK,KAAK,IAAI,EAAE;4BAChB,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC;yBACnD;qBACJ;oBAEK,mBAAmB,GAA8B,EAAE,CAAC;oBAC1D,WAAsD,EAAlC,KAAA,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAlC,cAAkC,EAAlC,IAAkC,EAAE;wBAA7C,KAAK;wBACZ,mBAAmB,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;qBACvE;oBAEK,cAAc,GAAG,cAAc,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,GAAG,IAAK,OAAA,GAAG,GAAG,GAAG,EAAT,CAAS,CAAC,CAAC;oBAEhE,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,aAAa,CAAC,GAAG,CAAC,UAAC,KAAK,EAAE,KAAK;wBAC7E,OAAO;4BACH,cAAc,EAAE,cAAc,CAAC,KAAK,CAAC,GAAG,cAAc;4BACtD,KAAK,OAAA;4BACL,UAAU,EAAE,mBAAmB,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;4BAChD,SAAS,EAAE,cAAc,CAAC,KAAK,CAAC;4BAChC,KAAK,OAAA;yBACR,CAAC;oBACN,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;oBAEb,EAAE,CAAC,aAAa,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;;;;;CAC9C;AAED,SAAe,SAAS,CAAC,WAAwB,EAAE,aAAoB,EAAE,cAAsB,EAAE,IAAa,EAAE,MAAe,EAAE,cAAuB,EAAE,QAAqB,EAAE,SAA2B,EAAE,QAAoD;IAAxG,yBAAA,EAAA,aAAqB;IAAE,0BAAA,EAAA,mBAA2B;IAAE,yBAAA,EAAA,eAAoD;;;;YAE1P,SAAS,GAAG,EAAE,CAAC;YACb,KAAK,GAAG,4BAA4B,CAAC;YAErC,QAAQ,GAAG,cAAc,GAAG,WAAW,CAAC,KAAK,CAAC;YAC9C,SAAS,GAAG,cAAc,GAAG,WAAW,CAAC,MAAM,CAAC;YACtD,SAAS,IAAI,+EACe,QAAQ,oBAAa,SAAS,mBAAY,KAAK,QAAI,CAAC;YAEhF,WAAkC,EAAlB,KAAA,WAAW,CAAC,MAAM,EAAlB,cAAkB,EAAlB,IAAkB,EAAE;gBAAzB,CAAC;gBAER,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;oBACtC,OAAO,GAAY,EAAE,CAAC;oBACpB,WAAW,GAAG,IAAI,CAAC;oBACzB,IAAI,WAAW,EAAE;wBACb,OAAO,GAAG,CAAC,CAAC,6BAA6B,CAAC,KAAK,CAAC,CAAC;qBACpD;yBAAM;wBACH,KAAS,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BAClD,OAAO,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,GAAG,GAAG,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;yBAC/F;qBACJ;oBACD,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;wBAClG,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC5B,CAAC,0BAA0B;oBAKxB,aAAa,GAAG,EAAE,CAAC;oBAEnB,IAAI,GAAG,IAAI,CAAC;oBAChB,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,cAAc,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,cAAc,GAAG,GAAG,CAAC;oBAClF,KAAS,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBACvC,SAAS,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;wBAClD,SAAS,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;wBACxD,IAAI,IAAI,IAAI,GAAG,CAAC,SAAS,GAAG,cAAc,CAAC,GAAG,GAAG,GAAG,CAAC,SAAS,GAAG,cAAc,CAAC,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,GAAG,GAAG,CAAC;qBAC1K;oBAEG,SAAS,GAAG,EAAE,CAAC;oBACnB,IAAI,MAAM,EAAE;wBACR,SAAS,GAAG,MAAM,CAAC;qBACtB;yBAAM;wBACH,gFAAgF;wBAChF,qCAAqC;wBACrC,IAAI,IAAI,EAAE;4BACN,SAAS,GAAG,SAAO,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAI,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAI,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAG,CAAC;yBAC7G;qBACJ;oBAEG,OAAO,GAAG,EAAE,CAAC;oBACjB,IAAI,IAAI,EAAE;wBACN,OAAO,GAAG,SAAO,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAI,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAI,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAG,CAAC;qBAC3G;yBAAM;wBACH,OAAO,GAAG,MAAM,CAAC;qBACpB;oBAED,aAAa,GAAG,0BAAuB,CAAC,CAAC,EAAE,eAAQ,IAAI,QAAI,CAAC;oBAE5D,aAAa,IAAI,UAAS,CAAC;oBAC3B,aAAa,IAAI,WAAS,OAAO,MAAG,CAAC;oBACrC,IAAI,SAAS,KAAK,EAAE,EAAE;wBAClB,aAAa,IAAI,aAAW,SAAS,uBAAoB,CAAC;qBAC7D;oBACD,aAAa,IAAI,IAAG,CAAC;oBAErB,aAAa,IAAI,GAAG,CAAC;oBAErB,aAAa,IAAI,SAAS,CAAC;oBAE3B,SAAS,IAAI,aAAa,CAAC;oBAE3B,qGAAqG;oBACrG,0CAA0C;oBAC1C,IAAI,cAAc,EAAE;wBAEV,YAAY,GAAG,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,cAAc,CAAC;wBACnD,YAAY,GAAG,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,cAAc,CAAC;wBACnD,UAAU,GAAG,CAAC,CAAC,WAAW,CAAC,KAAK,GAAG,cAAc,CAAC;wBAClD,WAAW,GAAG,CAAC,CAAC,WAAW,CAAC,MAAM,GAAG,cAAc,CAAC;wBASpD,UAAU,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC,CAAC,MAAM,CAAC;wBACnC,cAAc,GAAG,8CAAyC,YAAY,SAAI,YAAY,mEACtD,UAAU,oBAAa,WAAW,yLACJ,CAAC,QAAQ,GAAG,UAAU,CAAC,sEAA2D,SAAS,WAAK,CAAC,CAAC,KAAK,yGAE/I,CAAC;wBAE7B,SAAS,IAAI,cAAc,CAAC;qBAC/B;iBACJ;aACJ;YAED,SAAS,IAAI,QAAQ,CAAC;YAEtB,sBAAO,SAAS,EAAC;;;CACpB;AAED,IAAI,EAAE,CAAC,IAAI,CAAC;IACR,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,KAAK,CAAC,UAAC,GAAG;IACT,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,OAAO,GAAG,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;AAC9E,CAAC,CAAC,CAAC"}
--- END FILE: .\src-cli\main.js.map ---


--- START FILE: .\src-cli\main.ts ---
import * as canvas from "canvas";
import * as fs from "fs";
import * as minimist from "minimist";
import * as path from "path";
import * as process from "process";
import { ColorReducer } from "../src/colorreductionmanagement";
import { RGB } from "../src/common";
import { FacetBorderSegmenter } from "../src/facetBorderSegmenter";
import { FacetBorderTracer } from "../src/facetBorderTracer";
import { FacetCreator } from "../src/facetCreator";
import { FacetLabelPlacer } from "../src/facetLabelPlacer";
import { FacetResult } from "../src/facetmanagement";
import { FacetReducer } from "../src/facetReducer";
import { Settings } from "../src/settings";
import { Point } from "../src/structs/point";
const svg2img = require("svg2img");

class CLISettingsOutputProfile {
    public name: string = "";
    public svgShowLabels: boolean = true;
    public svgFillFacets: boolean = true;
    public svgShowBorders: boolean = true;
    public svgSizeMultiplier: number = 3;

    public svgFontSize: number = 60;
    public svgFontColor: string = "black";

    public filetype: "svg" | "png" | "jpg" = "svg";
    public filetypeQuality: number = 95;
}

class CLISettings extends Settings {

    public outputProfiles: CLISettingsOutputProfile[] = [];

}

async function main() {
    const args = minimist(process.argv.slice(2));
    const imagePath = args.i;
    const svgPath = args.o;

    if (typeof imagePath === "undefined" || typeof svgPath === "undefined") {
        console.log("Usage: exe -i <input_image> -o <output_svg> [-c <settings_json>]");
        process.exit(1);
    }

    let configPath = args.c;
    if (typeof configPath === "undefined") {
        configPath = path.join(process.cwd(), "settings.json");
    } else {
        if (!path.isAbsolute(configPath)) {
            configPath = path.join(process.cwd(), configPath);
        }
    }

    const settings: CLISettings = require(configPath);

    const img = await canvas.loadImage(imagePath);
    const c = canvas.createCanvas(img.width, img.height);
    const ctx = c.getContext("2d");
    ctx.drawImage(img, 0, 0, c.width, c.height);
    let imgData = ctx.getImageData(0, 0, c.width, c.height);

    // resize if required
    if (settings.resizeImageIfTooLarge && (c.width > settings.resizeImageWidth || c.height > settings.resizeImageHeight)) {
        let width = c.width;
        let height = c.height;
        if (width > settings.resizeImageWidth) {
            const newWidth = settings.resizeImageWidth;
            const newHeight = c.height / c.width * settings.resizeImageWidth;
            width = newWidth;
            height = newHeight;
        }
        if (height > settings.resizeImageHeight) {
            const newHeight = settings.resizeImageHeight;
            const newWidth = width / height * newHeight;
            width = newWidth;
            height = newHeight;
        }

        const tempCanvas = canvas.createCanvas(width, height);
        tempCanvas.width = width;
        tempCanvas.height = height;
        tempCanvas.getContext("2d")!.drawImage(c, 0, 0, width, height);
        c.width = width;
        c.height = height;
        ctx.drawImage(tempCanvas, 0, 0, width, height);
        imgData = ctx.getImageData(0, 0, c.width, c.height);

        console.log(`Resized image to ${width}x${height}`);
    }

    console.log("Running k-means clustering");
    const cKmeans = canvas.createCanvas(imgData.width, imgData.height);
    const ctxKmeans = cKmeans.getContext("2d")!;
    ctxKmeans.fillStyle = "white";
    ctxKmeans.fillRect(0, 0, cKmeans.width, cKmeans.height);

    const kmeansImgData = ctxKmeans.getImageData(0, 0, cKmeans.width, cKmeans.height);
    await ColorReducer.applyKMeansClustering(imgData, kmeansImgData, ctx, settings, (kmeans) => {
        const progress = (100 - (kmeans.currentDeltaDistanceDifference > 100 ? 100 : kmeans.currentDeltaDistanceDifference)) / 100;
        ctxKmeans.putImageData(kmeansImgData, 0, 0);
    });

    const colormapResult = ColorReducer.createColorMap(kmeansImgData);

    let facetResult = new FacetResult();
    if (typeof settings.narrowPixelStripCleanupRuns === "undefined" || settings.narrowPixelStripCleanupRuns === 0) {
        console.log("Creating facets");
        facetResult = await FacetCreator.getFacets(imgData.width, imgData.height, colormapResult.imgColorIndices, (progress) => {
            // progress
        });

        console.log("Reducing facets");
        await FacetReducer.reduceFacets(settings.removeFacetsSmallerThanNrOfPoints, settings.removeFacetsFromLargeToSmall, settings.maximumNumberOfFacets, colormapResult.colorsByIndex, facetResult, colormapResult.imgColorIndices, (progress) => {
            // progress
        });
    } else {
        for (let run = 0; run < settings.narrowPixelStripCleanupRuns; run++) {
            console.log("Removing narrow pixels run #" + (run + 1));
            // clean up narrow pixel strips
            await ColorReducer.processNarrowPixelStripCleanup(colormapResult);

            console.log("Creating facets");
            facetResult = await FacetCreator.getFacets(imgData.width, imgData.height, colormapResult.imgColorIndices, (progress) => {
                // progress
            });

            console.log("Reducing facets");
            await FacetReducer.reduceFacets(settings.removeFacetsSmallerThanNrOfPoints, settings.removeFacetsFromLargeToSmall, settings.maximumNumberOfFacets, colormapResult.colorsByIndex, facetResult, colormapResult.imgColorIndices, (progress) => {
                // progress
            });

            // the colormapResult.imgColorIndices get updated as the facets are reduced, so just do a few runs of pixel cleanup
        }
    }

    console.log("Build border paths");
    await FacetBorderTracer.buildFacetBorderPaths(facetResult, (progress) => {
        // progress
    });

    console.log("Build border path segments");
    await FacetBorderSegmenter.buildFacetBorderSegments(facetResult, settings.nrOfTimesToHalveBorderSegments, (progress) => {
        // progress
    });

    console.log("Determine label placement");
    await FacetLabelPlacer.buildFacetLabelBounds(facetResult, (progress) => {
        // progress
    });

    for (const profile of settings.outputProfiles) {
        console.log("Generating output for " + profile.name);

        if (typeof profile.filetype === "undefined") {
            profile.filetype = "svg";
        }

        const svgProfilePath = path.join(path.dirname(svgPath), path.basename(svgPath).substr(0, path.basename(svgPath).length - path.extname(svgPath).length) + "-" + profile.name) + "." + profile.filetype;
        const svgString = await createSVG(facetResult, colormapResult.colorsByIndex, profile.svgSizeMultiplier, profile.svgFillFacets, profile.svgShowBorders, profile.svgShowLabels, profile.svgFontSize, profile.svgFontColor);

        if (profile.filetype === "svg") {
            fs.writeFileSync(svgProfilePath, svgString);
        } else if (profile.filetype === "png") {

            const imageBuffer = await new Promise<Buffer>((then, reject) => {
                svg2img(svgString, function (error: Error, buffer: Buffer) {
                    if (error) {
                        reject(error);
                    } else {
                        then(buffer);
                    }
                });
            });
            fs.writeFileSync(svgProfilePath, imageBuffer);
        } else if (profile.filetype === "jpg") {
            const imageBuffer = await new Promise<Buffer>((then, reject) => {
                svg2img(svgString, { format: "jpg", quality: profile.filetypeQuality }, function (error: Error, buffer: Buffer) {
                    if (error) {
                        reject(error);
                    } else {
                        then(buffer);
                    }
                });
            });
            fs.writeFileSync(svgProfilePath, imageBuffer);
        }
    }

    console.log("Generating palette info");
    const palettePath = path.join(path.dirname(svgPath), path.basename(svgPath).substr(0, path.basename(svgPath).length - path.extname(svgPath).length) + ".json");

    const colorFrequency: number[] = [];
    for (const color of colormapResult.colorsByIndex) {
        colorFrequency.push(0);
    }

    for (const facet of facetResult.facets) {
        if (facet !== null) {
            colorFrequency[facet.color] += facet.pointCount;
        }
    }

    const colorAliasesByColor: { [key: string]: string } = {};
    for (const alias of Object.keys(settings.colorAliases)) {
        colorAliasesByColor[settings.colorAliases[alias].join(",")] = alias;
    }

    const totalFrequency = colorFrequency.reduce((sum, val) => sum + val);

    const paletteInfo = JSON.stringify(colormapResult.colorsByIndex.map((color, index) => {
        return {
            areaPercentage: colorFrequency[index] / totalFrequency,
            color,
            colorAlias: colorAliasesByColor[color.join(",")],
            frequency: colorFrequency[index],
            index,
        };
    }), null, 2);

    fs.writeFileSync(palettePath, paletteInfo);
}

async function createSVG(facetResult: FacetResult, colorsByIndex: RGB[], sizeMultiplier: number, fill: boolean, stroke: boolean, addColorLabels: boolean, fontSize: number = 60, fontColor: string = "black", onUpdate: ((progress: number) => void) | null = null) {

    let svgString = "";
    const xmlns = "http://www.w3.org/2000/svg";

    const svgWidth = sizeMultiplier * facetResult.width;
    const svgHeight = sizeMultiplier * facetResult.height;
    svgString += `<?xml version="1.0" standalone="no"?>
                  <svg width="${svgWidth}" height="${svgHeight}" xmlns="${xmlns}">`;

    for (const f of facetResult.facets) {

        if (f != null && f.borderSegments.length > 0) {
            let newpath: Point[] = [];
            const useSegments = true;
            if (useSegments) {
                newpath = f.getFullPathFromBorderSegments(false);
            } else {
                for (let i: number = 0; i < f.borderPath.length; i++) {
                    newpath.push(new Point(f.borderPath[i].getWallX() + 0.5, f.borderPath[i].getWallY() + 0.5));
                }
            }
            if (newpath[0].x !== newpath[newpath.length - 1].x || newpath[0].y !== newpath[newpath.length - 1].y) {
                newpath.push(newpath[0]);
            } // close loop if necessary

            // Create a path in SVG's namespace
            // using quadratic curve absolute positions

            let svgPathString = "";

            let data = "M ";
            data += newpath[0].x * sizeMultiplier + " " + newpath[0].y * sizeMultiplier + " ";
            for (let i: number = 1; i < newpath.length; i++) {
                const midpointX = (newpath[i].x + newpath[i - 1].x) / 2;
                const midpointY = (newpath[i].y + newpath[i - 1].y) / 2;
                data += "Q " + (midpointX * sizeMultiplier) + " " + (midpointY * sizeMultiplier) + " " + (newpath[i].x * sizeMultiplier) + " " + (newpath[i].y * sizeMultiplier) + " ";
            }

            let svgStroke = "";
            if (stroke) {
                svgStroke = "#000";
            } else {
                // make the border the same color as the fill color if there is no border stroke
                // to not have gaps in between facets
                if (fill) {
                    svgStroke = `rgb(${colorsByIndex[f.color][0]},${colorsByIndex[f.color][1]},${colorsByIndex[f.color][2]})`;
                }
            }

            let svgFill = "";
            if (fill) {
                svgFill = `rgb(${colorsByIndex[f.color][0]},${colorsByIndex[f.color][1]},${colorsByIndex[f.color][2]})`;
            } else {
                svgFill = "none";
            }

            svgPathString = `<path data-facetId="${f.id}" d="${data}" `;

            svgPathString += `style="`;
            svgPathString += `fill: ${svgFill};`;
            if (svgStroke !== "") {
                svgPathString += `stroke: ${svgStroke}; stroke-width:1px`;
            }
            svgPathString += `"`;

            svgPathString += `>`;

            svgPathString += `</path>`;

            svgString += svgPathString;

            // add the color labels if necessary. I mean, this is the whole idea behind the paint by numbers part
            // so I don't know why you would hide them
            if (addColorLabels) {

                const labelOffsetX = f.labelBounds.minX * sizeMultiplier;
                const labelOffsetY = f.labelBounds.minY * sizeMultiplier;
                const labelWidth = f.labelBounds.width * sizeMultiplier;
                const labelHeight = f.labelBounds.height * sizeMultiplier;

                //     const svgLabelString = `<g class="label" transform="translate(${labelOffsetX},${labelOffsetY})">
                //     <svg width="${labelWidth}" height="${labelHeight}" overflow="visible" viewBox="-50 -50 100 100" preserveAspectRatio="xMidYMid meet">
                //         <rect xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" fill="rgb(255,255,255,0.5)" x="-50" y="-50"/>
                //         <text font-family="Tahoma" font-size="60" dominant-baseline="middle" text-anchor="middle">${f.color}</text>
                //     </svg>
                //    </g>`;

                const nrOfDigits = (f.color + "").length;
                const svgLabelString = `<g class="label" transform="translate(${labelOffsetX},${labelOffsetY})">
                                        <svg width="${labelWidth}" height="${labelHeight}" overflow="visible" viewBox="-50 -50 100 100" preserveAspectRatio="xMidYMid meet">
                                            <text font-family="Tahoma" font-size="${(fontSize / nrOfDigits)}" dominant-baseline="middle" text-anchor="middle" fill="${fontColor}">${f.color}</text>
                                        </svg>
                                       </g>`;

                svgString += svgLabelString;
            }
        }
    }

    svgString += `</svg>`;

    return svgString;
}

main().then(() => {
    console.log("Finished");
}).catch((err) => {
    console.error("Error: " + err.name + " " + err.message + " " + err.stack);
});

--- END FILE: .\src-cli\main.ts ---


--- START FILE: .\src-cli\settings.json ---
{
    "randomSeed": 7707,
    "kMeansNrOfClusters": 16,
    "kMeansMinDeltaDifference": 1,
    "kMeansClusteringColorSpace": 0,
    "kMeansColorRestrictions": [],
    "colorAliases": {
        "A1": [            0,            0,            0        ],
        "A2": [            255,            0,            0        ],
        "A3": [            0,            255,            0        ],
        "A4": [            0,            0,            255        ],
        "B1": [            64,            64,            64        ],
        "B2": [            128,            128,            128        ],
        "B3": [            192,            192,            192        ]
    },
    "removeFacetsSmallerThanNrOfPoints": 20,
    "removeFacetsFromLargeToSmall": true,
    "maximumNumberOfFacets": 100,
    "nrOfTimesToHalveBorderSegments": 2,
    "narrowPixelStripCleanupRuns": 3,
    "resizeImageIfTooLarge": true,
    "resizeImageWidth": 1024,
    "resizeImageHeight": 1024,
    "outputProfiles": [
        {
            "name": "full",
            "svgShowLabels": true,
            "svgFillFacets": true,
            "svgShowBorders": true,
            "svgSizeMultiplier": 3,
            "svgFontSize": 50,
            "svgFontColor": "#333",
            "filetype": "png"
        },
        {
            "name": "bordersLabels",
            "svgShowLabels": true,
            "svgFillFacets": false,
            "svgShowBorders": true,
            "svgSizeMultiplier": 3,
            "svgFontSize": 50,
            "svgFontColor": "#333",
            "filetype": "svg"
        },
        {
            "name": "jpgtest",
            "svgShowLabels": false,
            "svgFillFacets": true,
            "svgShowBorders": false,
            "svgSizeMultiplier": 3,
            "svgFontSize": 50,
            "svgFontColor": "#333",
            "filetype": "jpg",
            "filetypeQuality": 80
        }
    ]
}
--- END FILE: .\src-cli\settings.json ---


--- START FILE: .\src-cli\tsconfig.json ---
{
    "compilerOptions": {
        "noImplicitAny": true,
        "strict": true,
        "noImplicitReturns": true,
        "noImplicitThis": true,
        "strictNullChecks": true,
        "removeComments": false,
        "sourceMap": true,
        "target": "es5",
        "lib": [
            "dom",
            "es2015",
            "es2015.promise"
        ],
    }
}
--- END FILE: .\src-cli\tsconfig.json ---


--- START FILE: .\src-cli\tslint.json ---
{
    "extends": "tslint:recommended",
    "rulesDirectory": [],
    "rules": {
       "max-classes-per-file":false,
       "max-line-length":false,
       "no-console":false,
       "no-bitwise":false,
       "member-ordering":false,
       "promise-function-async":true,
       "await-promise":true,
       "only-arrow-functions":false,
       "variable-name": [ false ],
       "no-angle-bracket-type-assertion": false,
       "space-before-function-paren": false
    },
    "jsRules": {
       
    }
}
--- END FILE: .\src-cli\tslint.json ---


--- START FILE: .\styles\main.css ---
.status {
    background-color: white;
    padding: 10px;
    overflow: hidden;
}

.status.active {
    animation-name: color;
    animation-duration: 4s;
    animation-iteration-count: infinite;
}

.status.complete {
    background-color: #CCFFC6;
}

@keyframes color {
    0% {
        background-color: #FFF;
    }
    50% {
        background-color: #CCFFC6;
    }
    100% {
        background-color: #FFF;
    }
}

.palette .color {
    float: left;
    width: 40px;
    height: 40px;
    border: 1px solid #AAA;
    border-radius: 5px;
    text-align: center;
    padding: 5px;
    font-weight: 600;
    margin: 5px;
    text-shadow: #FFF 0px 0px 5px;
}

.collection-item > .row {
    margin-bottom:0px;
}

#input-pane {
    overflow: auto;
    max-width: 100%;
    max-height: 500px;
}

#svgContainer {
    overflow: auto;
    max-width: 100%;
    max-height: 500px;
}
--- END FILE: .\styles\main.css ---


--- START FILE: .\styles\lib\materialize.min.css ---
/*!
 * Materialize v1.0.0-beta (http://materializecss.com)
 * Copyright 2014-2017 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */
.materialize-red{background-color:#e51c23 !important}.materialize-red-text{color:#e51c23 !important}.materialize-red.lighten-5{background-color:#fdeaeb !important}.materialize-red-text.text-lighten-5{color:#fdeaeb !important}.materialize-red.lighten-4{background-color:#f8c1c3 !important}.materialize-red-text.text-lighten-4{color:#f8c1c3 !important}.materialize-red.lighten-3{background-color:#f3989b !important}.materialize-red-text.text-lighten-3{color:#f3989b !important}.materialize-red.lighten-2{background-color:#ee6e73 !important}.materialize-red-text.text-lighten-2{color:#ee6e73 !important}.materialize-red.lighten-1{background-color:#ea454b !important}.materialize-red-text.text-lighten-1{color:#ea454b !important}.materialize-red.darken-1{background-color:#d0181e !important}.materialize-red-text.text-darken-1{color:#d0181e !important}.materialize-red.darken-2{background-color:#b9151b !important}.materialize-red-text.text-darken-2{color:#b9151b !important}.materialize-red.darken-3{background-color:#a21318 !important}.materialize-red-text.text-darken-3{color:#a21318 !important}.materialize-red.darken-4{background-color:#8b1014 !important}.materialize-red-text.text-darken-4{color:#8b1014 !important}.red{background-color:#F44336 !important}.red-text{color:#F44336 !important}.red.lighten-5{background-color:#FFEBEE !important}.red-text.text-lighten-5{color:#FFEBEE !important}.red.lighten-4{background-color:#FFCDD2 !important}.red-text.text-lighten-4{color:#FFCDD2 !important}.red.lighten-3{background-color:#EF9A9A !important}.red-text.text-lighten-3{color:#EF9A9A !important}.red.lighten-2{background-color:#E57373 !important}.red-text.text-lighten-2{color:#E57373 !important}.red.lighten-1{background-color:#EF5350 !important}.red-text.text-lighten-1{color:#EF5350 !important}.red.darken-1{background-color:#E53935 !important}.red-text.text-darken-1{color:#E53935 !important}.red.darken-2{background-color:#D32F2F !important}.red-text.text-darken-2{color:#D32F2F !important}.red.darken-3{background-color:#C62828 !important}.red-text.text-darken-3{color:#C62828 !important}.red.darken-4{background-color:#B71C1C !important}.red-text.text-darken-4{color:#B71C1C !important}.red.accent-1{background-color:#FF8A80 !important}.red-text.text-accent-1{color:#FF8A80 !important}.red.accent-2{background-color:#FF5252 !important}.red-text.text-accent-2{color:#FF5252 !important}.red.accent-3{background-color:#FF1744 !important}.red-text.text-accent-3{color:#FF1744 !important}.red.accent-4{background-color:#D50000 !important}.red-text.text-accent-4{color:#D50000 !important}.pink{background-color:#e91e63 !important}.pink-text{color:#e91e63 !important}.pink.lighten-5{background-color:#fce4ec !important}.pink-text.text-lighten-5{color:#fce4ec !important}.pink.lighten-4{background-color:#f8bbd0 !important}.pink-text.text-lighten-4{color:#f8bbd0 !important}.pink.lighten-3{background-color:#f48fb1 !important}.pink-text.text-lighten-3{color:#f48fb1 !important}.pink.lighten-2{background-color:#f06292 !important}.pink-text.text-lighten-2{color:#f06292 !important}.pink.lighten-1{background-color:#ec407a !important}.pink-text.text-lighten-1{color:#ec407a !important}.pink.darken-1{background-color:#d81b60 !important}.pink-text.text-darken-1{color:#d81b60 !important}.pink.darken-2{background-color:#c2185b !important}.pink-text.text-darken-2{color:#c2185b !important}.pink.darken-3{background-color:#ad1457 !important}.pink-text.text-darken-3{color:#ad1457 !important}.pink.darken-4{background-color:#880e4f !important}.pink-text.text-darken-4{color:#880e4f !important}.pink.accent-1{background-color:#ff80ab !important}.pink-text.text-accent-1{color:#ff80ab !important}.pink.accent-2{background-color:#ff4081 !important}.pink-text.text-accent-2{color:#ff4081 !important}.pink.accent-3{background-color:#f50057 !important}.pink-text.text-accent-3{color:#f50057 !important}.pink.accent-4{background-color:#c51162 !important}.pink-text.text-accent-4{color:#c51162 !important}.purple{background-color:#9c27b0 !important}.purple-text{color:#9c27b0 !important}.purple.lighten-5{background-color:#f3e5f5 !important}.purple-text.text-lighten-5{color:#f3e5f5 !important}.purple.lighten-4{background-color:#e1bee7 !important}.purple-text.text-lighten-4{color:#e1bee7 !important}.purple.lighten-3{background-color:#ce93d8 !important}.purple-text.text-lighten-3{color:#ce93d8 !important}.purple.lighten-2{background-color:#ba68c8 !important}.purple-text.text-lighten-2{color:#ba68c8 !important}.purple.lighten-1{background-color:#ab47bc !important}.purple-text.text-lighten-1{color:#ab47bc !important}.purple.darken-1{background-color:#8e24aa !important}.purple-text.text-darken-1{color:#8e24aa !important}.purple.darken-2{background-color:#7b1fa2 !important}.purple-text.text-darken-2{color:#7b1fa2 !important}.purple.darken-3{background-color:#6a1b9a !important}.purple-text.text-darken-3{color:#6a1b9a !important}.purple.darken-4{background-color:#4a148c !important}.purple-text.text-darken-4{color:#4a148c !important}.purple.accent-1{background-color:#ea80fc !important}.purple-text.text-accent-1{color:#ea80fc !important}.purple.accent-2{background-color:#e040fb !important}.purple-text.text-accent-2{color:#e040fb !important}.purple.accent-3{background-color:#d500f9 !important}.purple-text.text-accent-3{color:#d500f9 !important}.purple.accent-4{background-color:#a0f !important}.purple-text.text-accent-4{color:#a0f !important}.deep-purple{background-color:#673ab7 !important}.deep-purple-text{color:#673ab7 !important}.deep-purple.lighten-5{background-color:#ede7f6 !important}.deep-purple-text.text-lighten-5{color:#ede7f6 !important}.deep-purple.lighten-4{background-color:#d1c4e9 !important}.deep-purple-text.text-lighten-4{color:#d1c4e9 !important}.deep-purple.lighten-3{background-color:#b39ddb !important}.deep-purple-text.text-lighten-3{color:#b39ddb !important}.deep-purple.lighten-2{background-color:#9575cd !important}.deep-purple-text.text-lighten-2{color:#9575cd !important}.deep-purple.lighten-1{background-color:#7e57c2 !important}.deep-purple-text.text-lighten-1{color:#7e57c2 !important}.deep-purple.darken-1{background-color:#5e35b1 !important}.deep-purple-text.text-darken-1{color:#5e35b1 !important}.deep-purple.darken-2{background-color:#512da8 !important}.deep-purple-text.text-darken-2{color:#512da8 !important}.deep-purple.darken-3{background-color:#4527a0 !important}.deep-purple-text.text-darken-3{color:#4527a0 !important}.deep-purple.darken-4{background-color:#311b92 !important}.deep-purple-text.text-darken-4{color:#311b92 !important}.deep-purple.accent-1{background-color:#b388ff !important}.deep-purple-text.text-accent-1{color:#b388ff !important}.deep-purple.accent-2{background-color:#7c4dff !important}.deep-purple-text.text-accent-2{color:#7c4dff !important}.deep-purple.accent-3{background-color:#651fff !important}.deep-purple-text.text-accent-3{color:#651fff !important}.deep-purple.accent-4{background-color:#6200ea !important}.deep-purple-text.text-accent-4{color:#6200ea !important}.indigo{background-color:#3f51b5 !important}.indigo-text{color:#3f51b5 !important}.indigo.lighten-5{background-color:#e8eaf6 !important}.indigo-text.text-lighten-5{color:#e8eaf6 !important}.indigo.lighten-4{background-color:#c5cae9 !important}.indigo-text.text-lighten-4{color:#c5cae9 !important}.indigo.lighten-3{background-color:#9fa8da !important}.indigo-text.text-lighten-3{color:#9fa8da !important}.indigo.lighten-2{background-color:#7986cb !important}.indigo-text.text-lighten-2{color:#7986cb !important}.indigo.lighten-1{background-color:#5c6bc0 !important}.indigo-text.text-lighten-1{color:#5c6bc0 !important}.indigo.darken-1{background-color:#3949ab !important}.indigo-text.text-darken-1{color:#3949ab !important}.indigo.darken-2{background-color:#303f9f !important}.indigo-text.text-darken-2{color:#303f9f !important}.indigo.darken-3{background-color:#283593 !important}.indigo-text.text-darken-3{color:#283593 !important}.indigo.darken-4{background-color:#1a237e !important}.indigo-text.text-darken-4{color:#1a237e !important}.indigo.accent-1{background-color:#8c9eff !important}.indigo-text.text-accent-1{color:#8c9eff !important}.indigo.accent-2{background-color:#536dfe !important}.indigo-text.text-accent-2{color:#536dfe !important}.indigo.accent-3{background-color:#3d5afe !important}.indigo-text.text-accent-3{color:#3d5afe !important}.indigo.accent-4{background-color:#304ffe !important}.indigo-text.text-accent-4{color:#304ffe !important}.blue{background-color:#2196F3 !important}.blue-text{color:#2196F3 !important}.blue.lighten-5{background-color:#E3F2FD !important}.blue-text.text-lighten-5{color:#E3F2FD !important}.blue.lighten-4{background-color:#BBDEFB !important}.blue-text.text-lighten-4{color:#BBDEFB !important}.blue.lighten-3{background-color:#90CAF9 !important}.blue-text.text-lighten-3{color:#90CAF9 !important}.blue.lighten-2{background-color:#64B5F6 !important}.blue-text.text-lighten-2{color:#64B5F6 !important}.blue.lighten-1{background-color:#42A5F5 !important}.blue-text.text-lighten-1{color:#42A5F5 !important}.blue.darken-1{background-color:#1E88E5 !important}.blue-text.text-darken-1{color:#1E88E5 !important}.blue.darken-2{background-color:#1976D2 !important}.blue-text.text-darken-2{color:#1976D2 !important}.blue.darken-3{background-color:#1565C0 !important}.blue-text.text-darken-3{color:#1565C0 !important}.blue.darken-4{background-color:#0D47A1 !important}.blue-text.text-darken-4{color:#0D47A1 !important}.blue.accent-1{background-color:#82B1FF !important}.blue-text.text-accent-1{color:#82B1FF !important}.blue.accent-2{background-color:#448AFF !important}.blue-text.text-accent-2{color:#448AFF !important}.blue.accent-3{background-color:#2979FF !important}.blue-text.text-accent-3{color:#2979FF !important}.blue.accent-4{background-color:#2962FF !important}.blue-text.text-accent-4{color:#2962FF !important}.light-blue{background-color:#03a9f4 !important}.light-blue-text{color:#03a9f4 !important}.light-blue.lighten-5{background-color:#e1f5fe !important}.light-blue-text.text-lighten-5{color:#e1f5fe !important}.light-blue.lighten-4{background-color:#b3e5fc !important}.light-blue-text.text-lighten-4{color:#b3e5fc !important}.light-blue.lighten-3{background-color:#81d4fa !important}.light-blue-text.text-lighten-3{color:#81d4fa !important}.light-blue.lighten-2{background-color:#4fc3f7 !important}.light-blue-text.text-lighten-2{color:#4fc3f7 !important}.light-blue.lighten-1{background-color:#29b6f6 !important}.light-blue-text.text-lighten-1{color:#29b6f6 !important}.light-blue.darken-1{background-color:#039be5 !important}.light-blue-text.text-darken-1{color:#039be5 !important}.light-blue.darken-2{background-color:#0288d1 !important}.light-blue-text.text-darken-2{color:#0288d1 !important}.light-blue.darken-3{background-color:#0277bd !important}.light-blue-text.text-darken-3{color:#0277bd !important}.light-blue.darken-4{background-color:#01579b !important}.light-blue-text.text-darken-4{color:#01579b !important}.light-blue.accent-1{background-color:#80d8ff !important}.light-blue-text.text-accent-1{color:#80d8ff !important}.light-blue.accent-2{background-color:#40c4ff !important}.light-blue-text.text-accent-2{color:#40c4ff !important}.light-blue.accent-3{background-color:#00b0ff !important}.light-blue-text.text-accent-3{color:#00b0ff !important}.light-blue.accent-4{background-color:#0091ea !important}.light-blue-text.text-accent-4{color:#0091ea !important}.cyan{background-color:#00bcd4 !important}.cyan-text{color:#00bcd4 !important}.cyan.lighten-5{background-color:#e0f7fa !important}.cyan-text.text-lighten-5{color:#e0f7fa !important}.cyan.lighten-4{background-color:#b2ebf2 !important}.cyan-text.text-lighten-4{color:#b2ebf2 !important}.cyan.lighten-3{background-color:#80deea !important}.cyan-text.text-lighten-3{color:#80deea !important}.cyan.lighten-2{background-color:#4dd0e1 !important}.cyan-text.text-lighten-2{color:#4dd0e1 !important}.cyan.lighten-1{background-color:#26c6da !important}.cyan-text.text-lighten-1{color:#26c6da !important}.cyan.darken-1{background-color:#00acc1 !important}.cyan-text.text-darken-1{color:#00acc1 !important}.cyan.darken-2{background-color:#0097a7 !important}.cyan-text.text-darken-2{color:#0097a7 !important}.cyan.darken-3{background-color:#00838f !important}.cyan-text.text-darken-3{color:#00838f !important}.cyan.darken-4{background-color:#006064 !important}.cyan-text.text-darken-4{color:#006064 !important}.cyan.accent-1{background-color:#84ffff !important}.cyan-text.text-accent-1{color:#84ffff !important}.cyan.accent-2{background-color:#18ffff !important}.cyan-text.text-accent-2{color:#18ffff !important}.cyan.accent-3{background-color:#00e5ff !important}.cyan-text.text-accent-3{color:#00e5ff !important}.cyan.accent-4{background-color:#00b8d4 !important}.cyan-text.text-accent-4{color:#00b8d4 !important}.teal{background-color:#009688 !important}.teal-text{color:#009688 !important}.teal.lighten-5{background-color:#e0f2f1 !important}.teal-text.text-lighten-5{color:#e0f2f1 !important}.teal.lighten-4{background-color:#b2dfdb !important}.teal-text.text-lighten-4{color:#b2dfdb !important}.teal.lighten-3{background-color:#80cbc4 !important}.teal-text.text-lighten-3{color:#80cbc4 !important}.teal.lighten-2{background-color:#4db6ac !important}.teal-text.text-lighten-2{color:#4db6ac !important}.teal.lighten-1{background-color:#26a69a !important}.teal-text.text-lighten-1{color:#26a69a !important}.teal.darken-1{background-color:#00897b !important}.teal-text.text-darken-1{color:#00897b !important}.teal.darken-2{background-color:#00796b !important}.teal-text.text-darken-2{color:#00796b !important}.teal.darken-3{background-color:#00695c !important}.teal-text.text-darken-3{color:#00695c !important}.teal.darken-4{background-color:#004d40 !important}.teal-text.text-darken-4{color:#004d40 !important}.teal.accent-1{background-color:#a7ffeb !important}.teal-text.text-accent-1{color:#a7ffeb !important}.teal.accent-2{background-color:#64ffda !important}.teal-text.text-accent-2{color:#64ffda !important}.teal.accent-3{background-color:#1de9b6 !important}.teal-text.text-accent-3{color:#1de9b6 !important}.teal.accent-4{background-color:#00bfa5 !important}.teal-text.text-accent-4{color:#00bfa5 !important}.green{background-color:#4CAF50 !important}.green-text{color:#4CAF50 !important}.green.lighten-5{background-color:#E8F5E9 !important}.green-text.text-lighten-5{color:#E8F5E9 !important}.green.lighten-4{background-color:#C8E6C9 !important}.green-text.text-lighten-4{color:#C8E6C9 !important}.green.lighten-3{background-color:#A5D6A7 !important}.green-text.text-lighten-3{color:#A5D6A7 !important}.green.lighten-2{background-color:#81C784 !important}.green-text.text-lighten-2{color:#81C784 !important}.green.lighten-1{background-color:#66BB6A !important}.green-text.text-lighten-1{color:#66BB6A !important}.green.darken-1{background-color:#43A047 !important}.green-text.text-darken-1{color:#43A047 !important}.green.darken-2{background-color:#388E3C !important}.green-text.text-darken-2{color:#388E3C !important}.green.darken-3{background-color:#2E7D32 !important}.green-text.text-darken-3{color:#2E7D32 !important}.green.darken-4{background-color:#1B5E20 !important}.green-text.text-darken-4{color:#1B5E20 !important}.green.accent-1{background-color:#B9F6CA !important}.green-text.text-accent-1{color:#B9F6CA !important}.green.accent-2{background-color:#69F0AE !important}.green-text.text-accent-2{color:#69F0AE !important}.green.accent-3{background-color:#00E676 !important}.green-text.text-accent-3{color:#00E676 !important}.green.accent-4{background-color:#00C853 !important}.green-text.text-accent-4{color:#00C853 !important}.light-green{background-color:#8bc34a !important}.light-green-text{color:#8bc34a !important}.light-green.lighten-5{background-color:#f1f8e9 !important}.light-green-text.text-lighten-5{color:#f1f8e9 !important}.light-green.lighten-4{background-color:#dcedc8 !important}.light-green-text.text-lighten-4{color:#dcedc8 !important}.light-green.lighten-3{background-color:#c5e1a5 !important}.light-green-text.text-lighten-3{color:#c5e1a5 !important}.light-green.lighten-2{background-color:#aed581 !important}.light-green-text.text-lighten-2{color:#aed581 !important}.light-green.lighten-1{background-color:#9ccc65 !important}.light-green-text.text-lighten-1{color:#9ccc65 !important}.light-green.darken-1{background-color:#7cb342 !important}.light-green-text.text-darken-1{color:#7cb342 !important}.light-green.darken-2{background-color:#689f38 !important}.light-green-text.text-darken-2{color:#689f38 !important}.light-green.darken-3{background-color:#558b2f !important}.light-green-text.text-darken-3{color:#558b2f !important}.light-green.darken-4{background-color:#33691e !important}.light-green-text.text-darken-4{color:#33691e !important}.light-green.accent-1{background-color:#ccff90 !important}.light-green-text.text-accent-1{color:#ccff90 !important}.light-green.accent-2{background-color:#b2ff59 !important}.light-green-text.text-accent-2{color:#b2ff59 !important}.light-green.accent-3{background-color:#76ff03 !important}.light-green-text.text-accent-3{color:#76ff03 !important}.light-green.accent-4{background-color:#64dd17 !important}.light-green-text.text-accent-4{color:#64dd17 !important}.lime{background-color:#cddc39 !important}.lime-text{color:#cddc39 !important}.lime.lighten-5{background-color:#f9fbe7 !important}.lime-text.text-lighten-5{color:#f9fbe7 !important}.lime.lighten-4{background-color:#f0f4c3 !important}.lime-text.text-lighten-4{color:#f0f4c3 !important}.lime.lighten-3{background-color:#e6ee9c !important}.lime-text.text-lighten-3{color:#e6ee9c !important}.lime.lighten-2{background-color:#dce775 !important}.lime-text.text-lighten-2{color:#dce775 !important}.lime.lighten-1{background-color:#d4e157 !important}.lime-text.text-lighten-1{color:#d4e157 !important}.lime.darken-1{background-color:#c0ca33 !important}.lime-text.text-darken-1{color:#c0ca33 !important}.lime.darken-2{background-color:#afb42b !important}.lime-text.text-darken-2{color:#afb42b !important}.lime.darken-3{background-color:#9e9d24 !important}.lime-text.text-darken-3{color:#9e9d24 !important}.lime.darken-4{background-color:#827717 !important}.lime-text.text-darken-4{color:#827717 !important}.lime.accent-1{background-color:#f4ff81 !important}.lime-text.text-accent-1{color:#f4ff81 !important}.lime.accent-2{background-color:#eeff41 !important}.lime-text.text-accent-2{color:#eeff41 !important}.lime.accent-3{background-color:#c6ff00 !important}.lime-text.text-accent-3{color:#c6ff00 !important}.lime.accent-4{background-color:#aeea00 !important}.lime-text.text-accent-4{color:#aeea00 !important}.yellow{background-color:#ffeb3b !important}.yellow-text{color:#ffeb3b !important}.yellow.lighten-5{background-color:#fffde7 !important}.yellow-text.text-lighten-5{color:#fffde7 !important}.yellow.lighten-4{background-color:#fff9c4 !important}.yellow-text.text-lighten-4{color:#fff9c4 !important}.yellow.lighten-3{background-color:#fff59d !important}.yellow-text.text-lighten-3{color:#fff59d !important}.yellow.lighten-2{background-color:#fff176 !important}.yellow-text.text-lighten-2{color:#fff176 !important}.yellow.lighten-1{background-color:#ffee58 !important}.yellow-text.text-lighten-1{color:#ffee58 !important}.yellow.darken-1{background-color:#fdd835 !important}.yellow-text.text-darken-1{color:#fdd835 !important}.yellow.darken-2{background-color:#fbc02d !important}.yellow-text.text-darken-2{color:#fbc02d !important}.yellow.darken-3{background-color:#f9a825 !important}.yellow-text.text-darken-3{color:#f9a825 !important}.yellow.darken-4{background-color:#f57f17 !important}.yellow-text.text-darken-4{color:#f57f17 !important}.yellow.accent-1{background-color:#ffff8d !important}.yellow-text.text-accent-1{color:#ffff8d !important}.yellow.accent-2{background-color:#ff0 !important}.yellow-text.text-accent-2{color:#ff0 !important}.yellow.accent-3{background-color:#ffea00 !important}.yellow-text.text-accent-3{color:#ffea00 !important}.yellow.accent-4{background-color:#ffd600 !important}.yellow-text.text-accent-4{color:#ffd600 !important}.amber{background-color:#ffc107 !important}.amber-text{color:#ffc107 !important}.amber.lighten-5{background-color:#fff8e1 !important}.amber-text.text-lighten-5{color:#fff8e1 !important}.amber.lighten-4{background-color:#ffecb3 !important}.amber-text.text-lighten-4{color:#ffecb3 !important}.amber.lighten-3{background-color:#ffe082 !important}.amber-text.text-lighten-3{color:#ffe082 !important}.amber.lighten-2{background-color:#ffd54f !important}.amber-text.text-lighten-2{color:#ffd54f !important}.amber.lighten-1{background-color:#ffca28 !important}.amber-text.text-lighten-1{color:#ffca28 !important}.amber.darken-1{background-color:#ffb300 !important}.amber-text.text-darken-1{color:#ffb300 !important}.amber.darken-2{background-color:#ffa000 !important}.amber-text.text-darken-2{color:#ffa000 !important}.amber.darken-3{background-color:#ff8f00 !important}.amber-text.text-darken-3{color:#ff8f00 !important}.amber.darken-4{background-color:#ff6f00 !important}.amber-text.text-darken-4{color:#ff6f00 !important}.amber.accent-1{background-color:#ffe57f !important}.amber-text.text-accent-1{color:#ffe57f !important}.amber.accent-2{background-color:#ffd740 !important}.amber-text.text-accent-2{color:#ffd740 !important}.amber.accent-3{background-color:#ffc400 !important}.amber-text.text-accent-3{color:#ffc400 !important}.amber.accent-4{background-color:#ffab00 !important}.amber-text.text-accent-4{color:#ffab00 !important}.orange{background-color:#ff9800 !important}.orange-text{color:#ff9800 !important}.orange.lighten-5{background-color:#fff3e0 !important}.orange-text.text-lighten-5{color:#fff3e0 !important}.orange.lighten-4{background-color:#ffe0b2 !important}.orange-text.text-lighten-4{color:#ffe0b2 !important}.orange.lighten-3{background-color:#ffcc80 !important}.orange-text.text-lighten-3{color:#ffcc80 !important}.orange.lighten-2{background-color:#ffb74d !important}.orange-text.text-lighten-2{color:#ffb74d !important}.orange.lighten-1{background-color:#ffa726 !important}.orange-text.text-lighten-1{color:#ffa726 !important}.orange.darken-1{background-color:#fb8c00 !important}.orange-text.text-darken-1{color:#fb8c00 !important}.orange.darken-2{background-color:#f57c00 !important}.orange-text.text-darken-2{color:#f57c00 !important}.orange.darken-3{background-color:#ef6c00 !important}.orange-text.text-darken-3{color:#ef6c00 !important}.orange.darken-4{background-color:#e65100 !important}.orange-text.text-darken-4{color:#e65100 !important}.orange.accent-1{background-color:#ffd180 !important}.orange-text.text-accent-1{color:#ffd180 !important}.orange.accent-2{background-color:#ffab40 !important}.orange-text.text-accent-2{color:#ffab40 !important}.orange.accent-3{background-color:#ff9100 !important}.orange-text.text-accent-3{color:#ff9100 !important}.orange.accent-4{background-color:#ff6d00 !important}.orange-text.text-accent-4{color:#ff6d00 !important}.deep-orange{background-color:#ff5722 !important}.deep-orange-text{color:#ff5722 !important}.deep-orange.lighten-5{background-color:#fbe9e7 !important}.deep-orange-text.text-lighten-5{color:#fbe9e7 !important}.deep-orange.lighten-4{background-color:#ffccbc !important}.deep-orange-text.text-lighten-4{color:#ffccbc !important}.deep-orange.lighten-3{background-color:#ffab91 !important}.deep-orange-text.text-lighten-3{color:#ffab91 !important}.deep-orange.lighten-2{background-color:#ff8a65 !important}.deep-orange-text.text-lighten-2{color:#ff8a65 !important}.deep-orange.lighten-1{background-color:#ff7043 !important}.deep-orange-text.text-lighten-1{color:#ff7043 !important}.deep-orange.darken-1{background-color:#f4511e !important}.deep-orange-text.text-darken-1{color:#f4511e !important}.deep-orange.darken-2{background-color:#e64a19 !important}.deep-orange-text.text-darken-2{color:#e64a19 !important}.deep-orange.darken-3{background-color:#d84315 !important}.deep-orange-text.text-darken-3{color:#d84315 !important}.deep-orange.darken-4{background-color:#bf360c !important}.deep-orange-text.text-darken-4{color:#bf360c !important}.deep-orange.accent-1{background-color:#ff9e80 !important}.deep-orange-text.text-accent-1{color:#ff9e80 !important}.deep-orange.accent-2{background-color:#ff6e40 !important}.deep-orange-text.text-accent-2{color:#ff6e40 !important}.deep-orange.accent-3{background-color:#ff3d00 !important}.deep-orange-text.text-accent-3{color:#ff3d00 !important}.deep-orange.accent-4{background-color:#dd2c00 !important}.deep-orange-text.text-accent-4{color:#dd2c00 !important}.brown{background-color:#795548 !important}.brown-text{color:#795548 !important}.brown.lighten-5{background-color:#efebe9 !important}.brown-text.text-lighten-5{color:#efebe9 !important}.brown.lighten-4{background-color:#d7ccc8 !important}.brown-text.text-lighten-4{color:#d7ccc8 !important}.brown.lighten-3{background-color:#bcaaa4 !important}.brown-text.text-lighten-3{color:#bcaaa4 !important}.brown.lighten-2{background-color:#a1887f !important}.brown-text.text-lighten-2{color:#a1887f !important}.brown.lighten-1{background-color:#8d6e63 !important}.brown-text.text-lighten-1{color:#8d6e63 !important}.brown.darken-1{background-color:#6d4c41 !important}.brown-text.text-darken-1{color:#6d4c41 !important}.brown.darken-2{background-color:#5d4037 !important}.brown-text.text-darken-2{color:#5d4037 !important}.brown.darken-3{background-color:#4e342e !important}.brown-text.text-darken-3{color:#4e342e !important}.brown.darken-4{background-color:#3e2723 !important}.brown-text.text-darken-4{color:#3e2723 !important}.blue-grey{background-color:#607d8b !important}.blue-grey-text{color:#607d8b !important}.blue-grey.lighten-5{background-color:#eceff1 !important}.blue-grey-text.text-lighten-5{color:#eceff1 !important}.blue-grey.lighten-4{background-color:#cfd8dc !important}.blue-grey-text.text-lighten-4{color:#cfd8dc !important}.blue-grey.lighten-3{background-color:#b0bec5 !important}.blue-grey-text.text-lighten-3{color:#b0bec5 !important}.blue-grey.lighten-2{background-color:#90a4ae !important}.blue-grey-text.text-lighten-2{color:#90a4ae !important}.blue-grey.lighten-1{background-color:#78909c !important}.blue-grey-text.text-lighten-1{color:#78909c !important}.blue-grey.darken-1{background-color:#546e7a !important}.blue-grey-text.text-darken-1{color:#546e7a !important}.blue-grey.darken-2{background-color:#455a64 !important}.blue-grey-text.text-darken-2{color:#455a64 !important}.blue-grey.darken-3{background-color:#37474f !important}.blue-grey-text.text-darken-3{color:#37474f !important}.blue-grey.darken-4{background-color:#263238 !important}.blue-grey-text.text-darken-4{color:#263238 !important}.grey{background-color:#9e9e9e !important}.grey-text{color:#9e9e9e !important}.grey.lighten-5{background-color:#fafafa !important}.grey-text.text-lighten-5{color:#fafafa !important}.grey.lighten-4{background-color:#f5f5f5 !important}.grey-text.text-lighten-4{color:#f5f5f5 !important}.grey.lighten-3{background-color:#eee !important}.grey-text.text-lighten-3{color:#eee !important}.grey.lighten-2{background-color:#e0e0e0 !important}.grey-text.text-lighten-2{color:#e0e0e0 !important}.grey.lighten-1{background-color:#bdbdbd !important}.grey-text.text-lighten-1{color:#bdbdbd !important}.grey.darken-1{background-color:#757575 !important}.grey-text.text-darken-1{color:#757575 !important}.grey.darken-2{background-color:#616161 !important}.grey-text.text-darken-2{color:#616161 !important}.grey.darken-3{background-color:#424242 !important}.grey-text.text-darken-3{color:#424242 !important}.grey.darken-4{background-color:#212121 !important}.grey-text.text-darken-4{color:#212121 !important}.black{background-color:#000 !important}.black-text{color:#000 !important}.white{background-color:#fff !important}.white-text{color:#fff !important}.transparent{background-color:transparent !important}.transparent-text{color:transparent !important}/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:0.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace, monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;-moz-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace, monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,html [type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:0.35em 0.75em 0.625em}legend{-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type="checkbox"],[type="radio"]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}template{display:none}[hidden]{display:none}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}button,input,optgroup,select,textarea{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}a{color:#039be5;text-decoration:none;-webkit-tap-highlight-color:transparent}.valign-wrapper{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center}.clearfix{clear:both}.z-depth-0{-webkit-box-shadow:none !important;box-shadow:none !important}.z-depth-1,nav,.card-panel,.card,.toast,.btn,.btn-large,.btn-small,.btn-floating,.dropdown-content,.collapsible,.sidenav{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.z-depth-1-half,.btn:hover,.btn-large:hover,.btn-small:hover,.btn-floating:hover{-webkit-box-shadow:0 3px 3px 0 rgba(0,0,0,0.14),0 1px 7px 0 rgba(0,0,0,0.12),0 3px 1px -1px rgba(0,0,0,0.2);box-shadow:0 3px 3px 0 rgba(0,0,0,0.14),0 1px 7px 0 rgba(0,0,0,0.12),0 3px 1px -1px rgba(0,0,0,0.2)}.z-depth-2{-webkit-box-shadow:0 4px 5px 0 rgba(0,0,0,0.14),0 1px 10px 0 rgba(0,0,0,0.12),0 2px 4px -1px rgba(0,0,0,0.3);box-shadow:0 4px 5px 0 rgba(0,0,0,0.14),0 1px 10px 0 rgba(0,0,0,0.12),0 2px 4px -1px rgba(0,0,0,0.3)}.z-depth-3{-webkit-box-shadow:0 8px 17px 2px rgba(0,0,0,0.14),0 3px 14px 2px rgba(0,0,0,0.12),0 5px 5px -3px rgba(0,0,0,0.2);box-shadow:0 8px 17px 2px rgba(0,0,0,0.14),0 3px 14px 2px rgba(0,0,0,0.12),0 5px 5px -3px rgba(0,0,0,0.2)}.z-depth-4{-webkit-box-shadow:0 16px 24px 2px rgba(0,0,0,0.14),0 6px 30px 5px rgba(0,0,0,0.12),0 8px 10px -7px rgba(0,0,0,0.2);box-shadow:0 16px 24px 2px rgba(0,0,0,0.14),0 6px 30px 5px rgba(0,0,0,0.12),0 8px 10px -7px rgba(0,0,0,0.2)}.z-depth-5,.modal{-webkit-box-shadow:0 24px 38px 3px rgba(0,0,0,0.14),0 9px 46px 8px rgba(0,0,0,0.12),0 11px 15px -7px rgba(0,0,0,0.2);box-shadow:0 24px 38px 3px rgba(0,0,0,0.14),0 9px 46px 8px rgba(0,0,0,0.12),0 11px 15px -7px rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s, -webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}.divider{height:1px;overflow:hidden;background-color:#e0e0e0}blockquote{margin:20px 0;padding-left:1.5rem;border-left:5px solid #ee6e73}i{line-height:inherit}i.left{float:left;margin-right:15px}i.right{float:right;margin-left:15px}i.tiny{font-size:1rem}i.small{font-size:2rem}i.medium{font-size:4rem}i.large{font-size:6rem}img.responsive-img,video.responsive-video{max-width:100%;height:auto}.pagination li{display:inline-block;border-radius:2px;text-align:center;vertical-align:top;height:30px}.pagination li a{color:#444;display:inline-block;font-size:1.2rem;padding:0 10px;line-height:30px}.pagination li.active a{color:#fff}.pagination li.active{background-color:#ee6e73}.pagination li.disabled a{cursor:default;color:#999}.pagination li i{font-size:2rem}.pagination li.pages ul li{display:inline-block;float:none}@media only screen and (max-width: 992px){.pagination{width:100%}.pagination li.prev,.pagination li.next{width:10%}.pagination li.pages{width:80%;overflow:hidden;white-space:nowrap}}.breadcrumb{font-size:18px;color:rgba(255,255,255,0.7)}.breadcrumb i,.breadcrumb [class^="mdi-"],.breadcrumb [class*="mdi-"],.breadcrumb i.material-icons{display:inline-block;float:left;font-size:24px}.breadcrumb:before{content:'\E5CC';color:rgba(255,255,255,0.7);vertical-align:top;display:inline-block;font-family:'Material Icons';font-weight:normal;font-style:normal;font-size:25px;margin:0 10px 0 8px;-webkit-font-smoothing:antialiased}.breadcrumb:first-child:before{display:none}.breadcrumb:last-child{color:#fff}.parallax-container{position:relative;overflow:hidden;height:500px}.parallax-container .parallax{position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1}.parallax-container .parallax img{opacity:0;position:absolute;left:50%;bottom:0;min-width:100%;min-height:100%;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);-webkit-transform:translateX(-50%);transform:translateX(-50%)}.pin-top,.pin-bottom{position:relative}.pinned{position:fixed !important}ul.staggered-list li{opacity:0}.fade-in{opacity:0;-webkit-transform-origin:0 50%;transform-origin:0 50%}@media only screen and (max-width: 600px){.hide-on-small-only,.hide-on-small-and-down{display:none !important}}@media only screen and (max-width: 992px){.hide-on-med-and-down{display:none !important}}@media only screen and (min-width: 601px){.hide-on-med-and-up{display:none !important}}@media only screen and (min-width: 600px) and (max-width: 992px){.hide-on-med-only{display:none !important}}@media only screen and (min-width: 993px){.hide-on-large-only{display:none !important}}@media only screen and (min-width: 1201px){.hide-on-extra-large-only{display:none !important}}@media only screen and (min-width: 1201px){.show-on-extra-large{display:block !important}}@media only screen and (min-width: 993px){.show-on-large{display:block !important}}@media only screen and (min-width: 600px) and (max-width: 992px){.show-on-medium{display:block !important}}@media only screen and (max-width: 600px){.show-on-small{display:block !important}}@media only screen and (min-width: 601px){.show-on-medium-and-up{display:block !important}}@media only screen and (max-width: 992px){.show-on-medium-and-down{display:block !important}}@media only screen and (max-width: 600px){.center-on-small-only{text-align:center}}.page-footer{padding-top:20px;color:#fff;background-color:#ee6e73}.page-footer .footer-copyright{overflow:hidden;min-height:50px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:10px 0px;color:rgba(255,255,255,0.8);background-color:rgba(51,51,51,0.08)}table,th,td{border:none}table{width:100%;display:table;border-collapse:collapse;border-spacing:0}table.striped tr{border-bottom:none}table.striped>tbody>tr:nth-child(odd){background-color:rgba(242,242,242,0.5)}table.striped>tbody>tr>td{border-radius:0}table.highlight>tbody>tr{-webkit-transition:background-color .25s ease;transition:background-color .25s ease}table.highlight>tbody>tr:hover{background-color:rgba(242,242,242,0.5)}table.centered thead tr th,table.centered tbody tr td{text-align:center}tr{border-bottom:1px solid rgba(0,0,0,0.12)}td,th{padding:15px 5px;display:table-cell;text-align:left;vertical-align:middle;border-radius:2px}@media only screen and (max-width: 992px){table.responsive-table{width:100%;border-collapse:collapse;border-spacing:0;display:block;position:relative}table.responsive-table td:empty:before{content:'\00a0'}table.responsive-table th,table.responsive-table td{margin:0;vertical-align:top}table.responsive-table th{text-align:left}table.responsive-table thead{display:block;float:left}table.responsive-table thead tr{display:block;padding:0 10px 0 0}table.responsive-table thead tr th::before{content:"\00a0"}table.responsive-table tbody{display:block;width:auto;position:relative;overflow-x:auto;white-space:nowrap}table.responsive-table tbody tr{display:inline-block;vertical-align:top}table.responsive-table th{display:block;text-align:right}table.responsive-table td{display:block;min-height:1.25em;text-align:left}table.responsive-table tr{border-bottom:none;padding:0 10px}table.responsive-table thead{border:0;border-right:1px solid rgba(0,0,0,0.12)}}.collection{margin:.5rem 0 1rem 0;border:1px solid #e0e0e0;border-radius:2px;overflow:hidden;position:relative}.collection .collection-item{background-color:#fff;line-height:1.5rem;padding:10px 20px;margin:0;border-bottom:1px solid #e0e0e0}.collection .collection-item.avatar{min-height:84px;padding-left:72px;position:relative}.collection .collection-item.avatar:not(.circle-clipper)>.circle,.collection .collection-item.avatar :not(.circle-clipper)>.circle{position:absolute;width:42px;height:42px;overflow:hidden;left:15px;display:inline-block;vertical-align:middle}.collection .collection-item.avatar i.circle{font-size:18px;line-height:42px;color:#fff;background-color:#999;text-align:center}.collection .collection-item.avatar .title{font-size:16px}.collection .collection-item.avatar p{margin:0}.collection .collection-item.avatar .secondary-content{position:absolute;top:16px;right:16px}.collection .collection-item:last-child{border-bottom:none}.collection .collection-item.active{background-color:#26a69a;color:#eafaf9}.collection .collection-item.active .secondary-content{color:#fff}.collection a.collection-item{display:block;-webkit-transition:.25s;transition:.25s;color:#26a69a}.collection a.collection-item:not(.active):hover{background-color:#ddd}.collection.with-header .collection-header{background-color:#fff;border-bottom:1px solid #e0e0e0;padding:10px 20px}.collection.with-header .collection-item{padding-left:30px}.collection.with-header .collection-item.avatar{padding-left:72px}.secondary-content{float:right;color:#26a69a}.collapsible .collection{margin:0;border:none}.video-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden}.video-container iframe,.video-container object,.video-container embed{position:absolute;top:0;left:0;width:100%;height:100%}.progress{position:relative;height:4px;display:block;width:100%;background-color:#acece6;border-radius:2px;margin:.5rem 0 1rem 0;overflow:hidden}.progress .determinate{position:absolute;top:0;left:0;bottom:0;background-color:#26a69a;-webkit-transition:width .3s linear;transition:width .3s linear}.progress .indeterminate{background-color:#26a69a}.progress .indeterminate:before{content:'';position:absolute;background-color:inherit;top:0;left:0;bottom:0;will-change:left, right;-webkit-animation:indeterminate 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;animation:indeterminate 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite}.progress .indeterminate:after{content:'';position:absolute;background-color:inherit;top:0;left:0;bottom:0;will-change:left, right;-webkit-animation:indeterminate-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;animation:indeterminate-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;-webkit-animation-delay:1.15s;animation-delay:1.15s}@-webkit-keyframes indeterminate{0%{left:-35%;right:100%}60%{left:100%;right:-90%}100%{left:100%;right:-90%}}@keyframes indeterminate{0%{left:-35%;right:100%}60%{left:100%;right:-90%}100%{left:100%;right:-90%}}@-webkit-keyframes indeterminate-short{0%{left:-200%;right:100%}60%{left:107%;right:-8%}100%{left:107%;right:-8%}}@keyframes indeterminate-short{0%{left:-200%;right:100%}60%{left:107%;right:-8%}100%{left:107%;right:-8%}}.hide{display:none !important}.left-align{text-align:left}.right-align{text-align:right}.center,.center-align{text-align:center}.left{float:left !important}.right{float:right !important}.no-select,input[type=range],input[type=range]+.thumb{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.circle{border-radius:50%}.center-block{display:block;margin-left:auto;margin-right:auto}.truncate{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.no-padding{padding:0 !important}span.badge{min-width:3rem;padding:0 6px;margin-left:14px;text-align:center;font-size:1rem;line-height:22px;height:22px;color:#757575;float:right;-webkit-box-sizing:border-box;box-sizing:border-box}span.badge.new{font-weight:300;font-size:0.8rem;color:#fff;background-color:#26a69a;border-radius:2px}span.badge.new:after{content:" new"}span.badge[data-badge-caption]::after{content:" " attr(data-badge-caption)}nav ul a span.badge{display:inline-block;float:none;margin-left:4px;line-height:22px;height:22px;-webkit-font-smoothing:auto}.collection-item span.badge{margin-top:calc(.75rem - 11px)}.collapsible span.badge{margin-left:auto}.sidenav span.badge{margin-top:calc(24px - 11px)}table span.badge{display:inline-block;float:none;margin-left:auto}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.container{margin:0 auto;max-width:1280px;width:90%}@media only screen and (min-width: 601px){.container{width:85%}}@media only screen and (min-width: 993px){.container{width:70%}}.col .row{margin-left:-.75rem;margin-right:-.75rem}.section{padding-top:1rem;padding-bottom:1rem}.section.no-pad{padding:0}.section.no-pad-bot{padding-bottom:0}.section.no-pad-top{padding-top:0}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:"";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col[class*="push-"],.row .col[class*="pull-"]{position:relative}.row .col.s1{width:8.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.s2{width:16.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.s3{width:25%;margin-left:auto;left:auto;right:auto}.row .col.s4{width:33.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.s5{width:41.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.s6{width:50%;margin-left:auto;left:auto;right:auto}.row .col.s7{width:58.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.s8{width:66.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.s9{width:75%;margin-left:auto;left:auto;right:auto}.row .col.s10{width:83.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.s11{width:91.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}.row .col.offset-s1{margin-left:8.3333333333%}.row .col.pull-s1{right:8.3333333333%}.row .col.push-s1{left:8.3333333333%}.row .col.offset-s2{margin-left:16.6666666667%}.row .col.pull-s2{right:16.6666666667%}.row .col.push-s2{left:16.6666666667%}.row .col.offset-s3{margin-left:25%}.row .col.pull-s3{right:25%}.row .col.push-s3{left:25%}.row .col.offset-s4{margin-left:33.3333333333%}.row .col.pull-s4{right:33.3333333333%}.row .col.push-s4{left:33.3333333333%}.row .col.offset-s5{margin-left:41.6666666667%}.row .col.pull-s5{right:41.6666666667%}.row .col.push-s5{left:41.6666666667%}.row .col.offset-s6{margin-left:50%}.row .col.pull-s6{right:50%}.row .col.push-s6{left:50%}.row .col.offset-s7{margin-left:58.3333333333%}.row .col.pull-s7{right:58.3333333333%}.row .col.push-s7{left:58.3333333333%}.row .col.offset-s8{margin-left:66.6666666667%}.row .col.pull-s8{right:66.6666666667%}.row .col.push-s8{left:66.6666666667%}.row .col.offset-s9{margin-left:75%}.row .col.pull-s9{right:75%}.row .col.push-s9{left:75%}.row .col.offset-s10{margin-left:83.3333333333%}.row .col.pull-s10{right:83.3333333333%}.row .col.push-s10{left:83.3333333333%}.row .col.offset-s11{margin-left:91.6666666667%}.row .col.pull-s11{right:91.6666666667%}.row .col.push-s11{left:91.6666666667%}.row .col.offset-s12{margin-left:100%}.row .col.pull-s12{right:100%}.row .col.push-s12{left:100%}@media only screen and (min-width: 601px){.row .col.m1{width:8.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.m2{width:16.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.m3{width:25%;margin-left:auto;left:auto;right:auto}.row .col.m4{width:33.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.m5{width:41.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}.row .col.m7{width:58.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.m8{width:66.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.m9{width:75%;margin-left:auto;left:auto;right:auto}.row .col.m10{width:83.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.m11{width:91.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.m12{width:100%;margin-left:auto;left:auto;right:auto}.row .col.offset-m1{margin-left:8.3333333333%}.row .col.pull-m1{right:8.3333333333%}.row .col.push-m1{left:8.3333333333%}.row .col.offset-m2{margin-left:16.6666666667%}.row .col.pull-m2{right:16.6666666667%}.row .col.push-m2{left:16.6666666667%}.row .col.offset-m3{margin-left:25%}.row .col.pull-m3{right:25%}.row .col.push-m3{left:25%}.row .col.offset-m4{margin-left:33.3333333333%}.row .col.pull-m4{right:33.3333333333%}.row .col.push-m4{left:33.3333333333%}.row .col.offset-m5{margin-left:41.6666666667%}.row .col.pull-m5{right:41.6666666667%}.row .col.push-m5{left:41.6666666667%}.row .col.offset-m6{margin-left:50%}.row .col.pull-m6{right:50%}.row .col.push-m6{left:50%}.row .col.offset-m7{margin-left:58.3333333333%}.row .col.pull-m7{right:58.3333333333%}.row .col.push-m7{left:58.3333333333%}.row .col.offset-m8{margin-left:66.6666666667%}.row .col.pull-m8{right:66.6666666667%}.row .col.push-m8{left:66.6666666667%}.row .col.offset-m9{margin-left:75%}.row .col.pull-m9{right:75%}.row .col.push-m9{left:75%}.row .col.offset-m10{margin-left:83.3333333333%}.row .col.pull-m10{right:83.3333333333%}.row .col.push-m10{left:83.3333333333%}.row .col.offset-m11{margin-left:91.6666666667%}.row .col.pull-m11{right:91.6666666667%}.row .col.push-m11{left:91.6666666667%}.row .col.offset-m12{margin-left:100%}.row .col.pull-m12{right:100%}.row .col.push-m12{left:100%}}@media only screen and (min-width: 993px){.row .col.l1{width:8.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.l2{width:16.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.l3{width:25%;margin-left:auto;left:auto;right:auto}.row .col.l4{width:33.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.l5{width:41.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.l6{width:50%;margin-left:auto;left:auto;right:auto}.row .col.l7{width:58.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.l8{width:66.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.l9{width:75%;margin-left:auto;left:auto;right:auto}.row .col.l10{width:83.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.l11{width:91.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.l12{width:100%;margin-left:auto;left:auto;right:auto}.row .col.offset-l1{margin-left:8.3333333333%}.row .col.pull-l1{right:8.3333333333%}.row .col.push-l1{left:8.3333333333%}.row .col.offset-l2{margin-left:16.6666666667%}.row .col.pull-l2{right:16.6666666667%}.row .col.push-l2{left:16.6666666667%}.row .col.offset-l3{margin-left:25%}.row .col.pull-l3{right:25%}.row .col.push-l3{left:25%}.row .col.offset-l4{margin-left:33.3333333333%}.row .col.pull-l4{right:33.3333333333%}.row .col.push-l4{left:33.3333333333%}.row .col.offset-l5{margin-left:41.6666666667%}.row .col.pull-l5{right:41.6666666667%}.row .col.push-l5{left:41.6666666667%}.row .col.offset-l6{margin-left:50%}.row .col.pull-l6{right:50%}.row .col.push-l6{left:50%}.row .col.offset-l7{margin-left:58.3333333333%}.row .col.pull-l7{right:58.3333333333%}.row .col.push-l7{left:58.3333333333%}.row .col.offset-l8{margin-left:66.6666666667%}.row .col.pull-l8{right:66.6666666667%}.row .col.push-l8{left:66.6666666667%}.row .col.offset-l9{margin-left:75%}.row .col.pull-l9{right:75%}.row .col.push-l9{left:75%}.row .col.offset-l10{margin-left:83.3333333333%}.row .col.pull-l10{right:83.3333333333%}.row .col.push-l10{left:83.3333333333%}.row .col.offset-l11{margin-left:91.6666666667%}.row .col.pull-l11{right:91.6666666667%}.row .col.push-l11{left:91.6666666667%}.row .col.offset-l12{margin-left:100%}.row .col.pull-l12{right:100%}.row .col.push-l12{left:100%}}@media only screen and (min-width: 1201px){.row .col.xl1{width:8.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.xl2{width:16.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.xl3{width:25%;margin-left:auto;left:auto;right:auto}.row .col.xl4{width:33.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.xl5{width:41.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.xl6{width:50%;margin-left:auto;left:auto;right:auto}.row .col.xl7{width:58.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.xl8{width:66.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.xl9{width:75%;margin-left:auto;left:auto;right:auto}.row .col.xl10{width:83.3333333333%;margin-left:auto;left:auto;right:auto}.row .col.xl11{width:91.6666666667%;margin-left:auto;left:auto;right:auto}.row .col.xl12{width:100%;margin-left:auto;left:auto;right:auto}.row .col.offset-xl1{margin-left:8.3333333333%}.row .col.pull-xl1{right:8.3333333333%}.row .col.push-xl1{left:8.3333333333%}.row .col.offset-xl2{margin-left:16.6666666667%}.row .col.pull-xl2{right:16.6666666667%}.row .col.push-xl2{left:16.6666666667%}.row .col.offset-xl3{margin-left:25%}.row .col.pull-xl3{right:25%}.row .col.push-xl3{left:25%}.row .col.offset-xl4{margin-left:33.3333333333%}.row .col.pull-xl4{right:33.3333333333%}.row .col.push-xl4{left:33.3333333333%}.row .col.offset-xl5{margin-left:41.6666666667%}.row .col.pull-xl5{right:41.6666666667%}.row .col.push-xl5{left:41.6666666667%}.row .col.offset-xl6{margin-left:50%}.row .col.pull-xl6{right:50%}.row .col.push-xl6{left:50%}.row .col.offset-xl7{margin-left:58.3333333333%}.row .col.pull-xl7{right:58.3333333333%}.row .col.push-xl7{left:58.3333333333%}.row .col.offset-xl8{margin-left:66.6666666667%}.row .col.pull-xl8{right:66.6666666667%}.row .col.push-xl8{left:66.6666666667%}.row .col.offset-xl9{margin-left:75%}.row .col.pull-xl9{right:75%}.row .col.push-xl9{left:75%}.row .col.offset-xl10{margin-left:83.3333333333%}.row .col.pull-xl10{right:83.3333333333%}.row .col.push-xl10{left:83.3333333333%}.row .col.offset-xl11{margin-left:91.6666666667%}.row .col.pull-xl11{right:91.6666666667%}.row .col.push-xl11{left:91.6666666667%}.row .col.offset-xl12{margin-left:100%}.row .col.pull-xl12{right:100%}.row .col.push-xl12{left:100%}}nav{color:#fff;background-color:#ee6e73;width:100%;height:56px;line-height:56px}nav.nav-extended{height:auto}nav.nav-extended .nav-wrapper{min-height:56px;height:auto}nav.nav-extended .nav-content{position:relative;line-height:normal}nav a{color:#fff}nav i,nav [class^="mdi-"],nav [class*="mdi-"],nav i.material-icons{display:block;font-size:24px;height:56px;line-height:56px}nav .nav-wrapper{position:relative;height:100%}@media only screen and (min-width: 993px){nav a.sidenav-trigger{display:none}}nav .sidenav-trigger{float:left;position:relative;z-index:1;height:56px;margin:0 18px}nav .sidenav-trigger i{height:56px;line-height:56px}nav .brand-logo{position:absolute;color:#fff;display:inline-block;font-size:2.1rem;padding:0}nav .brand-logo.center{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}@media only screen and (max-width: 992px){nav .brand-logo{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}nav .brand-logo.left,nav .brand-logo.right{padding:0;-webkit-transform:none;transform:none}nav .brand-logo.left{left:0.5rem}nav .brand-logo.right{right:0.5rem;left:auto}}nav .brand-logo.right{right:0.5rem;padding:0}nav .brand-logo i,nav .brand-logo [class^="mdi-"],nav .brand-logo [class*="mdi-"],nav .brand-logo i.material-icons{float:left;margin-right:15px}nav .nav-title{display:inline-block;font-size:32px;padding:28px 0}nav ul{margin:0}nav ul li{-webkit-transition:background-color .3s;transition:background-color .3s;float:left;padding:0}nav ul li.active{background-color:rgba(0,0,0,0.1)}nav ul a{-webkit-transition:background-color .3s;transition:background-color .3s;font-size:1rem;color:#fff;display:block;padding:0 15px;cursor:pointer}nav ul a.btn,nav ul a.btn-large,nav ul a.btn-small,nav ul a.btn-large,nav ul a.btn-flat,nav ul a.btn-floating{margin-top:-2px;margin-left:15px;margin-right:15px}nav ul a.btn>.material-icons,nav ul a.btn-large>.material-icons,nav ul a.btn-small>.material-icons,nav ul a.btn-large>.material-icons,nav ul a.btn-flat>.material-icons,nav ul a.btn-floating>.material-icons{height:inherit;line-height:inherit}nav ul a:hover{background-color:rgba(0,0,0,0.1)}nav ul.left{float:left}nav form{height:100%}nav .input-field{margin:0;height:100%}nav .input-field input{height:100%;font-size:1.2rem;border:none;padding-left:2rem}nav .input-field input:focus,nav .input-field input[type=text]:valid,nav .input-field input[type=password]:valid,nav .input-field input[type=email]:valid,nav .input-field input[type=url]:valid,nav .input-field input[type=date]:valid{border:none;-webkit-box-shadow:none;box-shadow:none}nav .input-field label{top:0;left:0}nav .input-field label i{color:rgba(255,255,255,0.7);-webkit-transition:color .3s;transition:color .3s}nav .input-field label.active i{color:#fff}.navbar-fixed{position:relative;height:56px;z-index:997}.navbar-fixed nav{position:fixed}@media only screen and (min-width: 601px){nav.nav-extended .nav-wrapper{min-height:64px}nav,nav .nav-wrapper i,nav a.sidenav-trigger,nav a.sidenav-trigger i{height:64px;line-height:64px}.navbar-fixed{height:64px}}a{text-decoration:none}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width: 0){html{font-size:14px}}@media only screen and (min-width: 992px){html{font-size:14.5px}}@media only screen and (min-width: 1200px){html{font-size:15px}}h1,h2,h3,h4,h5,h6{font-weight:400;line-height:1.3}h1 a,h2 a,h3 a,h4 a,h5 a,h6 a{font-weight:inherit}h1{font-size:4.2rem;line-height:110%;margin:2.8rem 0 1.68rem 0}h2{font-size:3.56rem;line-height:110%;margin:2.3733333333rem 0 1.424rem 0}h3{font-size:2.92rem;line-height:110%;margin:1.9466666667rem 0 1.168rem 0}h4{font-size:2.28rem;line-height:110%;margin:1.52rem 0 .912rem 0}h5{font-size:1.64rem;line-height:110%;margin:1.0933333333rem 0 .656rem 0}h6{font-size:1.15rem;line-height:110%;margin:.7666666667rem 0 .46rem 0}em{font-style:italic}strong{font-weight:500}small{font-size:75%}.light{font-weight:300}.thin{font-weight:200}@media only screen and (min-width: 360px){.flow-text{font-size:1.2rem}}@media only screen and (min-width: 390px){.flow-text{font-size:1.224rem}}@media only screen and (min-width: 420px){.flow-text{font-size:1.248rem}}@media only screen and (min-width: 450px){.flow-text{font-size:1.272rem}}@media only screen and (min-width: 480px){.flow-text{font-size:1.296rem}}@media only screen and (min-width: 510px){.flow-text{font-size:1.32rem}}@media only screen and (min-width: 540px){.flow-text{font-size:1.344rem}}@media only screen and (min-width: 570px){.flow-text{font-size:1.368rem}}@media only screen and (min-width: 600px){.flow-text{font-size:1.392rem}}@media only screen and (min-width: 630px){.flow-text{font-size:1.416rem}}@media only screen and (min-width: 660px){.flow-text{font-size:1.44rem}}@media only screen and (min-width: 690px){.flow-text{font-size:1.464rem}}@media only screen and (min-width: 720px){.flow-text{font-size:1.488rem}}@media only screen and (min-width: 750px){.flow-text{font-size:1.512rem}}@media only screen and (min-width: 780px){.flow-text{font-size:1.536rem}}@media only screen and (min-width: 810px){.flow-text{font-size:1.56rem}}@media only screen and (min-width: 840px){.flow-text{font-size:1.584rem}}@media only screen and (min-width: 870px){.flow-text{font-size:1.608rem}}@media only screen and (min-width: 900px){.flow-text{font-size:1.632rem}}@media only screen and (min-width: 930px){.flow-text{font-size:1.656rem}}@media only screen and (min-width: 960px){.flow-text{font-size:1.68rem}}@media only screen and (max-width: 360px){.flow-text{font-size:1.2rem}}.scale-transition{-webkit-transition:-webkit-transform 0.3s cubic-bezier(0.53, 0.01, 0.36, 1.63) !important;transition:-webkit-transform 0.3s cubic-bezier(0.53, 0.01, 0.36, 1.63) !important;transition:transform 0.3s cubic-bezier(0.53, 0.01, 0.36, 1.63) !important;transition:transform 0.3s cubic-bezier(0.53, 0.01, 0.36, 1.63), -webkit-transform 0.3s cubic-bezier(0.53, 0.01, 0.36, 1.63) !important}.scale-transition.scale-out{-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform .2s !important;transition:-webkit-transform .2s !important;transition:transform .2s !important;transition:transform .2s, -webkit-transform .2s !important}.scale-transition.scale-in{-webkit-transform:scale(1);transform:scale(1)}.card-panel{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s, -webkit-box-shadow .25s;padding:24px;margin:.5rem 0 1rem 0;border-radius:2px;background-color:#fff}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s, -webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card.small,.card.medium,.card.large{position:relative}.card.small .card-image,.card.medium .card-image,.card.large .card-image{max-height:60%;overflow:hidden}.card.small .card-image+.card-content,.card.medium .card-image+.card-content,.card.large .card-image+.card-content{max-height:40%}.card.small .card-content,.card.medium .card-content,.card.large .card-content{max-height:100%;overflow:hidden}.card.small .card-action,.card.medium .card-action,.card.large .card-action{position:absolute;bottom:0;left:0;right:0}.card.small{height:300px}.card.medium{height:400px}.card.large{height:500px}.card.horizontal{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.card.horizontal.small .card-image,.card.horizontal.medium .card-image,.card.horizontal.large .card-image{height:100%;max-height:none;overflow:visible}.card.horizontal.small .card-image img,.card.horizontal.medium .card-image img,.card.horizontal.large .card-image img{height:100%}.card.horizontal .card-image{max-width:50%}.card.horizontal .card-image img{border-radius:2px 0 0 2px;max-width:100%;width:auto}.card.horizontal .card-stacked{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;position:relative}.card.horizontal .card-stacked .card-content{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}.card.sticky-action .card-action{z-index:2}.card.sticky-action .card-reveal{z-index:1;padding-bottom:64px}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-image .card-title{color:#fff;position:absolute;bottom:0;left:0;max-width:100%;padding:24px}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-action{background-color:inherit;border-top:1px solid rgba(160,160,160,0.2);position:relative;padding:16px 24px}.card .card-action:last-child{border-radius:0 0 2px 2px}.card .card-action a:not(.btn):not(.btn-large):not(.btn-small):not(.btn-large):not(.btn-floating){color:#ffab40;margin-right:24px;-webkit-transition:color .3s ease;transition:color .3s ease;text-transform:uppercase}.card .card-action a:not(.btn):not(.btn-large):not(.btn-small):not(.btn-large):not(.btn-floating):hover{color:#ffd8a6}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}#toast-container{display:block;position:fixed;z-index:10000}@media only screen and (max-width: 600px){#toast-container{min-width:100%;bottom:0%}}@media only screen and (min-width: 601px) and (max-width: 992px){#toast-container{left:5%;bottom:7%;max-width:90%}}@media only screen and (min-width: 993px){#toast-container{top:10%;right:7%;max-width:86%}}.toast{border-radius:2px;top:35px;width:auto;margin-top:10px;position:relative;max-width:100%;height:auto;min-height:48px;line-height:1.5em;word-break:break-all;background-color:#323232;padding:10px 25px;font-size:1.1rem;font-weight:300;color:#fff;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;cursor:default}.toast .toast-action{color:#eeff41;font-weight:500;margin-right:-25px;margin-left:3rem}.toast.rounded{border-radius:24px}@media only screen and (max-width: 600px){.toast{width:100%;border-radius:0}}.tabs{position:relative;overflow-x:auto;overflow-y:hidden;height:48px;width:100%;background-color:#fff;margin:0 auto;white-space:nowrap}.tabs.tabs-transparent{background-color:transparent}.tabs.tabs-transparent .tab a,.tabs.tabs-transparent .tab.disabled a,.tabs.tabs-transparent .tab.disabled a:hover{color:rgba(255,255,255,0.7)}.tabs.tabs-transparent .tab a:hover,.tabs.tabs-transparent .tab a.active{color:#fff}.tabs.tabs-transparent .indicator{background-color:#fff}.tabs.tabs-fixed-width{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.tabs.tabs-fixed-width .tab{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}.tabs .tab{display:inline-block;text-align:center;line-height:48px;height:48px;padding:0;margin:0;text-transform:uppercase}.tabs .tab a{color:rgba(238,110,115,0.7);display:block;width:100%;height:100%;padding:0 24px;font-size:14px;text-overflow:ellipsis;overflow:hidden;-webkit-transition:color .28s ease, background-color .28s ease;transition:color .28s ease, background-color .28s ease}.tabs .tab a:focus,.tabs .tab a:focus.active{background-color:rgba(246,178,181,0.2);outline:none}.tabs .tab a:hover,.tabs .tab a.active{background-color:transparent;color:#ee6e73}.tabs .tab.disabled a,.tabs .tab.disabled a:hover{color:rgba(238,110,115,0.4);cursor:default}.tabs .indicator{position:absolute;bottom:0;height:2px;background-color:#f6b2b5;will-change:left, right}@media only screen and (max-width: 992px){.tabs{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.tabs .tab{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}.tabs .tab a{padding:0 12px}}.material-tooltip{padding:10px 8px;font-size:1rem;z-index:2000;background-color:transparent;border-radius:2px;color:#fff;min-height:36px;line-height:120%;opacity:0;position:absolute;text-align:center;max-width:calc(100% - 4px);overflow:hidden;left:0;top:0;pointer-events:none;visibility:hidden;background-color:#323232}.backdrop{position:absolute;opacity:0;height:7px;width:14px;border-radius:0 0 50% 50%;background-color:#323232;z-index:-1;-webkit-transform-origin:50% 0%;transform-origin:50% 0%;visibility:hidden}.btn,.btn-large,.btn-small,.btn-flat{border:none;border-radius:2px;display:inline-block;height:36px;line-height:36px;padding:0 16px;text-transform:uppercase;vertical-align:middle;-webkit-tap-highlight-color:transparent}.btn.disabled,.disabled.btn-large,.disabled.btn-small,.btn-floating.disabled,.btn-large.disabled,.btn-small.disabled,.btn-flat.disabled,.btn:disabled,.btn-large:disabled,.btn-small:disabled,.btn-floating:disabled,.btn-large:disabled,.btn-small:disabled,.btn-flat:disabled,.btn[disabled],[disabled].btn-large,[disabled].btn-small,.btn-floating[disabled],.btn-large[disabled],.btn-small[disabled],.btn-flat[disabled]{pointer-events:none;background-color:#DFDFDF !important;-webkit-box-shadow:none;box-shadow:none;color:#9F9F9F !important;cursor:default}.btn.disabled:hover,.disabled.btn-large:hover,.disabled.btn-small:hover,.btn-floating.disabled:hover,.btn-large.disabled:hover,.btn-small.disabled:hover,.btn-flat.disabled:hover,.btn:disabled:hover,.btn-large:disabled:hover,.btn-small:disabled:hover,.btn-floating:disabled:hover,.btn-large:disabled:hover,.btn-small:disabled:hover,.btn-flat:disabled:hover,.btn[disabled]:hover,[disabled].btn-large:hover,[disabled].btn-small:hover,.btn-floating[disabled]:hover,.btn-large[disabled]:hover,.btn-small[disabled]:hover,.btn-flat[disabled]:hover{background-color:#DFDFDF !important;color:#9F9F9F !important}.btn,.btn-large,.btn-small,.btn-floating,.btn-large,.btn-small,.btn-flat{font-size:14px;outline:0}.btn i,.btn-large i,.btn-small i,.btn-floating i,.btn-large i,.btn-small i,.btn-flat i{font-size:1.3rem;line-height:inherit}.btn:focus,.btn-large:focus,.btn-small:focus,.btn-floating:focus{background-color:#1d7d74}.btn,.btn-large,.btn-small{text-decoration:none;color:#fff;background-color:#26a69a;text-align:center;letter-spacing:.5px;-webkit-transition:background-color .2s ease-out;transition:background-color .2s ease-out;cursor:pointer}.btn:hover,.btn-large:hover,.btn-small:hover{background-color:#2bbbad}.btn-floating{display:inline-block;color:#fff;position:relative;overflow:hidden;z-index:1;width:40px;height:40px;line-height:40px;padding:0;background-color:#26a69a;border-radius:50%;-webkit-transition:background-color .3s;transition:background-color .3s;cursor:pointer;vertical-align:middle}.btn-floating:hover{background-color:#26a69a}.btn-floating:before{border-radius:0}.btn-floating.btn-large{width:56px;height:56px;padding:0}.btn-floating.btn-large.halfway-fab{bottom:-28px}.btn-floating.btn-large i{line-height:56px}.btn-floating.btn-small{width:32.4px;height:32.4px}.btn-floating.btn-small.halfway-fab{bottom:-16.2px}.btn-floating.btn-small i{line-height:32.4px}.btn-floating.halfway-fab{position:absolute;right:24px;bottom:-20px}.btn-floating.halfway-fab.left{right:auto;left:24px}.btn-floating i{width:inherit;display:inline-block;text-align:center;color:#fff;font-size:1.6rem;line-height:40px}button.btn-floating{border:none}.fixed-action-btn{position:fixed;right:23px;bottom:23px;padding-top:15px;margin-bottom:0;z-index:997}.fixed-action-btn.active ul{visibility:visible}.fixed-action-btn.direction-left,.fixed-action-btn.direction-right{padding:0 0 0 15px}.fixed-action-btn.direction-left ul,.fixed-action-btn.direction-right ul{text-align:right;right:64px;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);height:100%;left:auto;width:500px}.fixed-action-btn.direction-left ul li,.fixed-action-btn.direction-right ul li{display:inline-block;margin:7.5px 15px 0 0}.fixed-action-btn.direction-right{padding:0 15px 0 0}.fixed-action-btn.direction-right ul{text-align:left;direction:rtl;left:64px;right:auto}.fixed-action-btn.direction-right ul li{margin:7.5px 0 0 15px}.fixed-action-btn.direction-bottom{padding:0 0 15px 0}.fixed-action-btn.direction-bottom ul{top:64px;bottom:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:reverse;-webkit-flex-direction:column-reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.fixed-action-btn.direction-bottom ul li{margin:15px 0 0 0}.fixed-action-btn.toolbar{padding:0;height:56px}.fixed-action-btn.toolbar.active>a i{opacity:0}.fixed-action-btn.toolbar ul{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;top:0;bottom:0;z-index:1}.fixed-action-btn.toolbar ul li{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;display:inline-block;margin:0;height:100%;-webkit-transition:none;transition:none}.fixed-action-btn.toolbar ul li a{display:block;overflow:hidden;position:relative;width:100%;height:100%;background-color:transparent;-webkit-box-shadow:none;box-shadow:none;color:#fff;line-height:56px;z-index:1}.fixed-action-btn.toolbar ul li a i{line-height:inherit}.fixed-action-btn ul{left:0;right:0;text-align:center;position:absolute;bottom:64px;margin:0;visibility:hidden}.fixed-action-btn ul li{margin-bottom:15px}.fixed-action-btn ul a.btn-floating{opacity:0}.fixed-action-btn .fab-backdrop{position:absolute;top:0;left:0;z-index:-1;width:40px;height:40px;background-color:#26a69a;border-radius:50%;-webkit-transform:scale(0);transform:scale(0)}.btn-flat{-webkit-box-shadow:none;box-shadow:none;background-color:transparent;color:#343434;cursor:pointer;-webkit-transition:background-color .2s;transition:background-color .2s}.btn-flat:focus,.btn-flat:hover{-webkit-box-shadow:none;box-shadow:none}.btn-flat:focus{background-color:rgba(0,0,0,0.1)}.btn-flat.disabled{background-color:transparent !important;color:#b3b2b2 !important;cursor:default}.btn-large{height:54px;line-height:54px;font-size:15px;padding:0 28px}.btn-large i{font-size:1.6rem}.btn-small{height:32.4px;line-height:32.4px;font-size:13px}.btn-small i{font-size:1.2rem}.btn-block{display:block}.dropdown-content{background-color:#fff;margin:0;display:none;min-width:100px;overflow-y:auto;opacity:0;position:absolute;left:0;top:0;z-index:9999;-webkit-transform-origin:0 0;transform-origin:0 0}.dropdown-content:focus{outline:0}.dropdown-content li{clear:both;color:rgba(0,0,0,0.87);cursor:pointer;min-height:50px;line-height:1.5rem;width:100%;text-align:left}.dropdown-content li:hover,.dropdown-content li.active{background-color:#eee}.dropdown-content li:focus{outline:none;background-color:#dadada}.dropdown-content li.divider{min-height:0;height:1px}.dropdown-content li>a,.dropdown-content li>span{font-size:16px;color:#26a69a;display:block;line-height:22px;padding:14px 16px}.dropdown-content li>span>label{top:1px;left:0;height:18px}.dropdown-content li>a>i{height:inherit;line-height:inherit;float:left;margin:0 24px 0 0;width:24px}.input-field.col .dropdown-content [type="checkbox"]+label{top:1px;left:0;height:18px;-webkit-transform:none;transform:none}/*!
 * Waves v0.6.0
 * http://fian.my.id/Waves
 *
 * Copyright 2014 Alfiana E. Sibuea and other contributors
 * Released under the MIT license
 * https://github.com/fians/Waves/blob/master/LICENSE
 */.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect .waves-ripple{position:absolute;border-radius:50%;width:20px;height:20px;margin-top:-10px;margin-left:-10px;opacity:0;background:rgba(0,0,0,0.2);-webkit-transition:all 0.7s ease-out;transition:all 0.7s ease-out;-webkit-transition-property:opacity, -webkit-transform;transition-property:opacity, -webkit-transform;transition-property:transform, opacity;transition-property:transform, opacity, -webkit-transform;-webkit-transform:scale(0);transform:scale(0);pointer-events:none}.waves-effect.waves-light .waves-ripple{background-color:rgba(255,255,255,0.45)}.waves-effect.waves-red .waves-ripple{background-color:rgba(244,67,54,0.7)}.waves-effect.waves-yellow .waves-ripple{background-color:rgba(255,235,59,0.7)}.waves-effect.waves-orange .waves-ripple{background-color:rgba(255,152,0,0.7)}.waves-effect.waves-purple .waves-ripple{background-color:rgba(156,39,176,0.7)}.waves-effect.waves-green .waves-ripple{background-color:rgba(76,175,80,0.7)}.waves-effect.waves-teal .waves-ripple{background-color:rgba(0,150,136,0.7)}.waves-effect input[type="button"],.waves-effect input[type="reset"],.waves-effect input[type="submit"]{border:0;font-style:normal;font-size:inherit;text-transform:inherit;background:none}.waves-effect img{position:relative;z-index:-1}.waves-notransition{-webkit-transition:none !important;transition:none !important}.waves-circle{-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-mask-image:-webkit-radial-gradient(circle, white 100%, black 100%)}.waves-input-wrapper{border-radius:0.2em;vertical-align:bottom}.waves-input-wrapper .waves-button-input{position:relative;top:0;left:0;z-index:1}.waves-circle{text-align:center;width:2.5em;height:2.5em;line-height:2.5em;border-radius:50%;-webkit-mask-image:none}.waves-block{display:block}.waves-effect .waves-ripple{z-index:-1}.modal{display:none;position:fixed;left:0;right:0;background-color:#fafafa;padding:0;max-height:70%;width:55%;margin:auto;overflow-y:auto;border-radius:2px;will-change:top, opacity}@media only screen and (max-width: 992px){.modal{width:80%}}.modal h1,.modal h2,.modal h3,.modal h4{margin-top:0}.modal .modal-content{padding:24px}.modal .modal-close{cursor:pointer}.modal .modal-footer{border-radius:0 0 2px 2px;background-color:#fafafa;padding:4px 6px;height:56px;width:100%;text-align:right}.modal .modal-footer .btn,.modal .modal-footer .btn-large,.modal .modal-footer .btn-small,.modal .modal-footer .btn-flat{margin:6px 0}.modal-overlay{position:fixed;z-index:999;top:-25%;left:0;bottom:0;right:0;height:125%;width:100%;background:#000;display:none;will-change:opacity}.modal.modal-fixed-footer{padding:0;height:70%}.modal.modal-fixed-footer .modal-content{position:absolute;height:calc(100% - 56px);max-height:100%;width:100%;overflow-y:auto}.modal.modal-fixed-footer .modal-footer{border-top:1px solid rgba(0,0,0,0.1);position:absolute;bottom:0}.modal.bottom-sheet{top:auto;bottom:-100%;margin:0;width:100%;max-height:45%;border-radius:0;will-change:bottom, opacity}.collapsible{border-top:1px solid #ddd;border-right:1px solid #ddd;border-left:1px solid #ddd;margin:.5rem 0 1rem 0}.collapsible-header{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;-webkit-tap-highlight-color:transparent;line-height:1.5;padding:1rem;background-color:#fff;border-bottom:1px solid #ddd}.collapsible-header i{width:2rem;font-size:1.6rem;display:inline-block;text-align:center;margin-right:1rem}.collapsible-body{display:none;border-bottom:1px solid #ddd;-webkit-box-sizing:border-box;box-sizing:border-box;padding:2rem}.sidenav .collapsible,.sidenav.fixed .collapsible{border:none;-webkit-box-shadow:none;box-shadow:none}.sidenav .collapsible li,.sidenav.fixed .collapsible li{padding:0}.sidenav .collapsible-header,.sidenav.fixed .collapsible-header{background-color:transparent;border:none;line-height:inherit;height:inherit;padding:0 16px}.sidenav .collapsible-header:hover,.sidenav.fixed .collapsible-header:hover{background-color:rgba(0,0,0,0.05)}.sidenav .collapsible-header i,.sidenav.fixed .collapsible-header i{line-height:inherit}.sidenav .collapsible-body,.sidenav.fixed .collapsible-body{border:0;background-color:#fff}.sidenav .collapsible-body li a,.sidenav.fixed .collapsible-body li a{padding:0 23.5px 0 31px}.collapsible.popout{border:none;-webkit-box-shadow:none;box-shadow:none}.collapsible.popout>li{-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,0.16),0 2px 10px 0 rgba(0,0,0,0.12);box-shadow:0 2px 5px 0 rgba(0,0,0,0.16),0 2px 10px 0 rgba(0,0,0,0.12);margin:0 24px;-webkit-transition:margin 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);transition:margin 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94)}.collapsible.popout>li.active{-webkit-box-shadow:0 5px 11px 0 rgba(0,0,0,0.18),0 4px 15px 0 rgba(0,0,0,0.15);box-shadow:0 5px 11px 0 rgba(0,0,0,0.18),0 4px 15px 0 rgba(0,0,0,0.15);margin:16px 0}.chip{display:inline-block;height:32px;font-size:13px;font-weight:500;color:rgba(0,0,0,0.6);line-height:32px;padding:0 12px;border-radius:16px;background-color:#e4e4e4;margin-bottom:5px;margin-right:5px}.chip:focus{outline:none;background-color:#26a69a;color:#fff}.chip>img{float:left;margin:0 8px 0 -12px;height:32px;width:32px;border-radius:50%}.chip .close{cursor:pointer;float:right;font-size:16px;line-height:32px;padding-left:8px}.chips{border:none;border-bottom:1px solid #9e9e9e;-webkit-box-shadow:none;box-shadow:none;margin:0 0 8px 0;min-height:45px;outline:none;-webkit-transition:all .3s;transition:all .3s}.chips.focus{border-bottom:1px solid #26a69a;-webkit-box-shadow:0 1px 0 0 #26a69a;box-shadow:0 1px 0 0 #26a69a}.chips:hover{cursor:text}.chips .input{background:none;border:0;color:rgba(0,0,0,0.6);display:inline-block;font-size:16px;height:3rem;line-height:32px;outline:0;margin:0;padding:0 !important;width:120px !important}.chips .input:focus{border:0 !important;-webkit-box-shadow:none !important;box-shadow:none !important}.chips .autocomplete-content{margin-top:0;margin-bottom:0}.prefix ~ .chips{margin-left:3rem;width:92%;width:calc(100% - 3rem)}.chips:empty ~ label{font-size:0.8rem;-webkit-transform:translateY(-140%);transform:translateY(-140%)}.materialboxed{display:block;cursor:-webkit-zoom-in;cursor:zoom-in;position:relative;-webkit-transition:opacity .4s;transition:opacity .4s;-webkit-backface-visibility:hidden}.materialboxed:hover:not(.active){opacity:.8}.materialboxed.active{cursor:-webkit-zoom-out;cursor:zoom-out}#materialbox-overlay{position:fixed;top:0;right:0;bottom:0;left:0;background-color:#292929;z-index:1000;will-change:opacity}.materialbox-caption{position:fixed;display:none;color:#fff;line-height:50px;bottom:0;left:0;width:100%;text-align:center;padding:0% 15%;height:50px;z-index:1000;-webkit-font-smoothing:antialiased}select:focus{outline:1px solid #c9f3ef}button:focus{outline:none;background-color:#2ab7a9}label{font-size:.8rem;color:#9e9e9e}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::placeholder{color:#d1d1d1}input:not([type]),input[type=text]:not(.browser-default),input[type=password]:not(.browser-default),input[type=email]:not(.browser-default),input[type=url]:not(.browser-default),input[type=time]:not(.browser-default),input[type=date]:not(.browser-default),input[type=datetime]:not(.browser-default),input[type=datetime-local]:not(.browser-default),input[type=tel]:not(.browser-default),input[type=number]:not(.browser-default),input[type=search]:not(.browser-default),textarea.materialize-textarea{background-color:transparent;border:none;border-bottom:1px solid #9e9e9e;border-radius:0;outline:none;height:3rem;width:100%;font-size:16px;margin:0 0 8px 0;padding:0;-webkit-box-shadow:none;box-shadow:none;-webkit-box-sizing:content-box;box-sizing:content-box;-webkit-transition:border .3s, -webkit-box-shadow .3s;transition:border .3s, -webkit-box-shadow .3s;transition:box-shadow .3s, border .3s;transition:box-shadow .3s, border .3s, -webkit-box-shadow .3s}input:not([type]):disabled,input:not([type])[readonly="readonly"],input[type=text]:not(.browser-default):disabled,input[type=text]:not(.browser-default)[readonly="readonly"],input[type=password]:not(.browser-default):disabled,input[type=password]:not(.browser-default)[readonly="readonly"],input[type=email]:not(.browser-default):disabled,input[type=email]:not(.browser-default)[readonly="readonly"],input[type=url]:not(.browser-default):disabled,input[type=url]:not(.browser-default)[readonly="readonly"],input[type=time]:not(.browser-default):disabled,input[type=time]:not(.browser-default)[readonly="readonly"],input[type=date]:not(.browser-default):disabled,input[type=date]:not(.browser-default)[readonly="readonly"],input[type=datetime]:not(.browser-default):disabled,input[type=datetime]:not(.browser-default)[readonly="readonly"],input[type=datetime-local]:not(.browser-default):disabled,input[type=datetime-local]:not(.browser-default)[readonly="readonly"],input[type=tel]:not(.browser-default):disabled,input[type=tel]:not(.browser-default)[readonly="readonly"],input[type=number]:not(.browser-default):disabled,input[type=number]:not(.browser-default)[readonly="readonly"],input[type=search]:not(.browser-default):disabled,input[type=search]:not(.browser-default)[readonly="readonly"],textarea.materialize-textarea:disabled,textarea.materialize-textarea[readonly="readonly"]{color:rgba(0,0,0,0.42);border-bottom:1px dotted rgba(0,0,0,0.42)}input:not([type]):disabled+label,input:not([type])[readonly="readonly"]+label,input[type=text]:not(.browser-default):disabled+label,input[type=text]:not(.browser-default)[readonly="readonly"]+label,input[type=password]:not(.browser-default):disabled+label,input[type=password]:not(.browser-default)[readonly="readonly"]+label,input[type=email]:not(.browser-default):disabled+label,input[type=email]:not(.browser-default)[readonly="readonly"]+label,input[type=url]:not(.browser-default):disabled+label,input[type=url]:not(.browser-default)[readonly="readonly"]+label,input[type=time]:not(.browser-default):disabled+label,input[type=time]:not(.browser-default)[readonly="readonly"]+label,input[type=date]:not(.browser-default):disabled+label,input[type=date]:not(.browser-default)[readonly="readonly"]+label,input[type=datetime]:not(.browser-default):disabled+label,input[type=datetime]:not(.browser-default)[readonly="readonly"]+label,input[type=datetime-local]:not(.browser-default):disabled+label,input[type=datetime-local]:not(.browser-default)[readonly="readonly"]+label,input[type=tel]:not(.browser-default):disabled+label,input[type=tel]:not(.browser-default)[readonly="readonly"]+label,input[type=number]:not(.browser-default):disabled+label,input[type=number]:not(.browser-default)[readonly="readonly"]+label,input[type=search]:not(.browser-default):disabled+label,input[type=search]:not(.browser-default)[readonly="readonly"]+label,textarea.materialize-textarea:disabled+label,textarea.materialize-textarea[readonly="readonly"]+label{color:rgba(0,0,0,0.42)}input:not([type]):focus:not([readonly]),input[type=text]:not(.browser-default):focus:not([readonly]),input[type=password]:not(.browser-default):focus:not([readonly]),input[type=email]:not(.browser-default):focus:not([readonly]),input[type=url]:not(.browser-default):focus:not([readonly]),input[type=time]:not(.browser-default):focus:not([readonly]),input[type=date]:not(.browser-default):focus:not([readonly]),input[type=datetime]:not(.browser-default):focus:not([readonly]),input[type=datetime-local]:not(.browser-default):focus:not([readonly]),input[type=tel]:not(.browser-default):focus:not([readonly]),input[type=number]:not(.browser-default):focus:not([readonly]),input[type=search]:not(.browser-default):focus:not([readonly]),textarea.materialize-textarea:focus:not([readonly]){border-bottom:1px solid #26a69a;-webkit-box-shadow:0 1px 0 0 #26a69a;box-shadow:0 1px 0 0 #26a69a}input:not([type]):focus:not([readonly])+label,input[type=text]:not(.browser-default):focus:not([readonly])+label,input[type=password]:not(.browser-default):focus:not([readonly])+label,input[type=email]:not(.browser-default):focus:not([readonly])+label,input[type=url]:not(.browser-default):focus:not([readonly])+label,input[type=time]:not(.browser-default):focus:not([readonly])+label,input[type=date]:not(.browser-default):focus:not([readonly])+label,input[type=datetime]:not(.browser-default):focus:not([readonly])+label,input[type=datetime-local]:not(.browser-default):focus:not([readonly])+label,input[type=tel]:not(.browser-default):focus:not([readonly])+label,input[type=number]:not(.browser-default):focus:not([readonly])+label,input[type=search]:not(.browser-default):focus:not([readonly])+label,textarea.materialize-textarea:focus:not([readonly])+label{color:#26a69a}input:not([type]):focus.valid ~ label,input[type=text]:not(.browser-default):focus.valid ~ label,input[type=password]:not(.browser-default):focus.valid ~ label,input[type=email]:not(.browser-default):focus.valid ~ label,input[type=url]:not(.browser-default):focus.valid ~ label,input[type=time]:not(.browser-default):focus.valid ~ label,input[type=date]:not(.browser-default):focus.valid ~ label,input[type=datetime]:not(.browser-default):focus.valid ~ label,input[type=datetime-local]:not(.browser-default):focus.valid ~ label,input[type=tel]:not(.browser-default):focus.valid ~ label,input[type=number]:not(.browser-default):focus.valid ~ label,input[type=search]:not(.browser-default):focus.valid ~ label,textarea.materialize-textarea:focus.valid ~ label{color:#4CAF50}input:not([type]):focus.invalid ~ label,input[type=text]:not(.browser-default):focus.invalid ~ label,input[type=password]:not(.browser-default):focus.invalid ~ label,input[type=email]:not(.browser-default):focus.invalid ~ label,input[type=url]:not(.browser-default):focus.invalid ~ label,input[type=time]:not(.browser-default):focus.invalid ~ label,input[type=date]:not(.browser-default):focus.invalid ~ label,input[type=datetime]:not(.browser-default):focus.invalid ~ label,input[type=datetime-local]:not(.browser-default):focus.invalid ~ label,input[type=tel]:not(.browser-default):focus.invalid ~ label,input[type=number]:not(.browser-default):focus.invalid ~ label,input[type=search]:not(.browser-default):focus.invalid ~ label,textarea.materialize-textarea:focus.invalid ~ label{color:#F44336}input:not([type]).validate+label,input[type=text]:not(.browser-default).validate+label,input[type=password]:not(.browser-default).validate+label,input[type=email]:not(.browser-default).validate+label,input[type=url]:not(.browser-default).validate+label,input[type=time]:not(.browser-default).validate+label,input[type=date]:not(.browser-default).validate+label,input[type=datetime]:not(.browser-default).validate+label,input[type=datetime-local]:not(.browser-default).validate+label,input[type=tel]:not(.browser-default).validate+label,input[type=number]:not(.browser-default).validate+label,input[type=search]:not(.browser-default).validate+label,textarea.materialize-textarea.validate+label{width:100%}input.valid:not([type]),input.valid:not([type]):focus,input[type=text].valid:not(.browser-default),input[type=text].valid:not(.browser-default):focus,input[type=password].valid:not(.browser-default),input[type=password].valid:not(.browser-default):focus,input[type=email].valid:not(.browser-default),input[type=email].valid:not(.browser-default):focus,input[type=url].valid:not(.browser-default),input[type=url].valid:not(.browser-default):focus,input[type=time].valid:not(.browser-default),input[type=time].valid:not(.browser-default):focus,input[type=date].valid:not(.browser-default),input[type=date].valid:not(.browser-default):focus,input[type=datetime].valid:not(.browser-default),input[type=datetime].valid:not(.browser-default):focus,input[type=datetime-local].valid:not(.browser-default),input[type=datetime-local].valid:not(.browser-default):focus,input[type=tel].valid:not(.browser-default),input[type=tel].valid:not(.browser-default):focus,input[type=number].valid:not(.browser-default),input[type=number].valid:not(.browser-default):focus,input[type=search].valid:not(.browser-default),input[type=search].valid:not(.browser-default):focus,textarea.materialize-textarea.valid,textarea.materialize-textarea.valid:focus,.select-wrapper.valid>input.select-dropdown{border-bottom:1px solid #4CAF50;-webkit-box-shadow:0 1px 0 0 #4CAF50;box-shadow:0 1px 0 0 #4CAF50}input.invalid:not([type]),input.invalid:not([type]):focus,input[type=text].invalid:not(.browser-default),input[type=text].invalid:not(.browser-default):focus,input[type=password].invalid:not(.browser-default),input[type=password].invalid:not(.browser-default):focus,input[type=email].invalid:not(.browser-default),input[type=email].invalid:not(.browser-default):focus,input[type=url].invalid:not(.browser-default),input[type=url].invalid:not(.browser-default):focus,input[type=time].invalid:not(.browser-default),input[type=time].invalid:not(.browser-default):focus,input[type=date].invalid:not(.browser-default),input[type=date].invalid:not(.browser-default):focus,input[type=datetime].invalid:not(.browser-default),input[type=datetime].invalid:not(.browser-default):focus,input[type=datetime-local].invalid:not(.browser-default),input[type=datetime-local].invalid:not(.browser-default):focus,input[type=tel].invalid:not(.browser-default),input[type=tel].invalid:not(.browser-default):focus,input[type=number].invalid:not(.browser-default),input[type=number].invalid:not(.browser-default):focus,input[type=search].invalid:not(.browser-default),input[type=search].invalid:not(.browser-default):focus,textarea.materialize-textarea.invalid,textarea.materialize-textarea.invalid:focus,.select-wrapper.invalid>input.select-dropdown,.select-wrapper.invalid>input.select-dropdown:focus{border-bottom:1px solid #F44336;-webkit-box-shadow:0 1px 0 0 #F44336;box-shadow:0 1px 0 0 #F44336}input:not([type]).valid ~ .helper-text[data-success],input:not([type]):focus.valid ~ .helper-text[data-success],input:not([type]).invalid ~ .helper-text[data-error],input:not([type]):focus.invalid ~ .helper-text[data-error],input[type=text]:not(.browser-default).valid ~ .helper-text[data-success],input[type=text]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=text]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=text]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=password]:not(.browser-default).valid ~ .helper-text[data-success],input[type=password]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=password]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=password]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=email]:not(.browser-default).valid ~ .helper-text[data-success],input[type=email]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=email]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=email]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=url]:not(.browser-default).valid ~ .helper-text[data-success],input[type=url]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=url]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=url]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=time]:not(.browser-default).valid ~ .helper-text[data-success],input[type=time]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=time]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=time]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=date]:not(.browser-default).valid ~ .helper-text[data-success],input[type=date]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=date]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=date]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=datetime]:not(.browser-default).valid ~ .helper-text[data-success],input[type=datetime]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=datetime]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=datetime]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=datetime-local]:not(.browser-default).valid ~ .helper-text[data-success],input[type=datetime-local]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=datetime-local]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=datetime-local]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=tel]:not(.browser-default).valid ~ .helper-text[data-success],input[type=tel]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=tel]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=tel]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=number]:not(.browser-default).valid ~ .helper-text[data-success],input[type=number]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=number]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=number]:not(.browser-default):focus.invalid ~ .helper-text[data-error],input[type=search]:not(.browser-default).valid ~ .helper-text[data-success],input[type=search]:not(.browser-default):focus.valid ~ .helper-text[data-success],input[type=search]:not(.browser-default).invalid ~ .helper-text[data-error],input[type=search]:not(.browser-default):focus.invalid ~ .helper-text[data-error],textarea.materialize-textarea.valid ~ .helper-text[data-success],textarea.materialize-textarea:focus.valid ~ .helper-text[data-success],textarea.materialize-textarea.invalid ~ .helper-text[data-error],textarea.materialize-textarea:focus.invalid ~ .helper-text[data-error],.select-wrapper.valid .helper-text[data-success],.select-wrapper.invalid ~ .helper-text[data-error]{color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none}input:not([type]).valid ~ .helper-text:after,input:not([type]):focus.valid ~ .helper-text:after,input[type=text]:not(.browser-default).valid ~ .helper-text:after,input[type=text]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=password]:not(.browser-default).valid ~ .helper-text:after,input[type=password]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=email]:not(.browser-default).valid ~ .helper-text:after,input[type=email]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=url]:not(.browser-default).valid ~ .helper-text:after,input[type=url]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=time]:not(.browser-default).valid ~ .helper-text:after,input[type=time]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=date]:not(.browser-default).valid ~ .helper-text:after,input[type=date]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=datetime]:not(.browser-default).valid ~ .helper-text:after,input[type=datetime]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=datetime-local]:not(.browser-default).valid ~ .helper-text:after,input[type=datetime-local]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=tel]:not(.browser-default).valid ~ .helper-text:after,input[type=tel]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=number]:not(.browser-default).valid ~ .helper-text:after,input[type=number]:not(.browser-default):focus.valid ~ .helper-text:after,input[type=search]:not(.browser-default).valid ~ .helper-text:after,input[type=search]:not(.browser-default):focus.valid ~ .helper-text:after,textarea.materialize-textarea.valid ~ .helper-text:after,textarea.materialize-textarea:focus.valid ~ .helper-text:after,.select-wrapper.valid ~ .helper-text:after{content:attr(data-success);color:#4CAF50}input:not([type]).invalid ~ .helper-text:after,input:not([type]):focus.invalid ~ .helper-text:after,input[type=text]:not(.browser-default).invalid ~ .helper-text:after,input[type=text]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=password]:not(.browser-default).invalid ~ .helper-text:after,input[type=password]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=email]:not(.browser-default).invalid ~ .helper-text:after,input[type=email]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=url]:not(.browser-default).invalid ~ .helper-text:after,input[type=url]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=time]:not(.browser-default).invalid ~ .helper-text:after,input[type=time]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=date]:not(.browser-default).invalid ~ .helper-text:after,input[type=date]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=datetime]:not(.browser-default).invalid ~ .helper-text:after,input[type=datetime]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=datetime-local]:not(.browser-default).invalid ~ .helper-text:after,input[type=datetime-local]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=tel]:not(.browser-default).invalid ~ .helper-text:after,input[type=tel]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=number]:not(.browser-default).invalid ~ .helper-text:after,input[type=number]:not(.browser-default):focus.invalid ~ .helper-text:after,input[type=search]:not(.browser-default).invalid ~ .helper-text:after,input[type=search]:not(.browser-default):focus.invalid ~ .helper-text:after,textarea.materialize-textarea.invalid ~ .helper-text:after,textarea.materialize-textarea:focus.invalid ~ .helper-text:after,.select-wrapper.invalid ~ .helper-text:after{content:attr(data-error);color:#F44336}input:not([type])+label:after,input[type=text]:not(.browser-default)+label:after,input[type=password]:not(.browser-default)+label:after,input[type=email]:not(.browser-default)+label:after,input[type=url]:not(.browser-default)+label:after,input[type=time]:not(.browser-default)+label:after,input[type=date]:not(.browser-default)+label:after,input[type=datetime]:not(.browser-default)+label:after,input[type=datetime-local]:not(.browser-default)+label:after,input[type=tel]:not(.browser-default)+label:after,input[type=number]:not(.browser-default)+label:after,input[type=search]:not(.browser-default)+label:after,textarea.materialize-textarea+label:after,.select-wrapper+label:after{display:block;content:"";position:absolute;top:100%;left:0;opacity:0;-webkit-transition:.2s opacity ease-out, .2s color ease-out;transition:.2s opacity ease-out, .2s color ease-out}.input-field{position:relative;margin-top:1rem;margin-bottom:1rem}.input-field.inline{display:inline-block;vertical-align:middle;margin-left:5px}.input-field.inline input,.input-field.inline .select-dropdown{margin-bottom:1rem}.input-field.col label{left:.75rem}.input-field.col .prefix ~ label,.input-field.col .prefix ~ .validate ~ label{width:calc(100% - 3rem - 1.5rem)}.input-field>label{color:#9e9e9e;position:absolute;top:0;left:0;font-size:1rem;cursor:text;-webkit-transition:color .2s ease-out, -webkit-transform .2s ease-out;transition:color .2s ease-out, -webkit-transform .2s ease-out;transition:transform .2s ease-out, color .2s ease-out;transition:transform .2s ease-out, color .2s ease-out, -webkit-transform .2s ease-out;-webkit-transform-origin:0% 100%;transform-origin:0% 100%;text-align:initial;-webkit-transform:translateY(12px);transform:translateY(12px)}.input-field>label:not(.label-icon).active{-webkit-transform:translateY(-14px) scale(0.8);transform:translateY(-14px) scale(0.8);-webkit-transform-origin:0 0;transform-origin:0 0}.input-field>input[type=date]:not(.browser-default)+label,.input-field>input[type=time]:not(.browser-default)+label{-webkit-transform:translateY(-14px) scale(0.8);transform:translateY(-14px) scale(0.8);-webkit-transform-origin:0 0;transform-origin:0 0}.input-field .helper-text{position:relative;min-height:18px;display:block;font-size:12px;color:rgba(0,0,0,0.54)}.input-field .helper-text::after{opacity:1;position:absolute;top:0;left:0}.input-field .prefix{position:absolute;width:3rem;font-size:2rem;-webkit-transition:color .2s;transition:color .2s;top:.5rem}.input-field .prefix.active{color:#26a69a}.input-field .prefix ~ input,.input-field .prefix ~ textarea,.input-field .prefix ~ label,.input-field .prefix ~ .validate ~ label,.input-field .prefix ~ .helper-text,.input-field .prefix ~ .autocomplete-content{margin-left:3rem;width:92%;width:calc(100% - 3rem)}.input-field .prefix ~ label{margin-left:3rem}@media only screen and (max-width: 992px){.input-field .prefix ~ input{width:86%;width:calc(100% - 3rem)}}@media only screen and (max-width: 600px){.input-field .prefix ~ input{width:80%;width:calc(100% - 3rem)}}.input-field input[type=search]{display:block;line-height:inherit;-webkit-transition:.3s background-color;transition:.3s background-color}.nav-wrapper .input-field input[type=search]{height:inherit;padding-left:4rem;width:calc(100% - 4rem);border:0;-webkit-box-shadow:none;box-shadow:none}.input-field input[type=search]:focus:not(.browser-default){background-color:#fff;border:0;-webkit-box-shadow:none;box-shadow:none;color:#444}.input-field input[type=search]:focus:not(.browser-default)+label i,.input-field input[type=search]:focus:not(.browser-default) ~ .mdi-navigation-close,.input-field input[type=search]:focus:not(.browser-default) ~ .material-icons{color:#444}.input-field input[type=search]+.label-icon{-webkit-transform:none;transform:none;left:1rem}.input-field input[type=search] ~ .mdi-navigation-close,.input-field input[type=search] ~ .material-icons{position:absolute;top:0;right:1rem;color:transparent;cursor:pointer;font-size:2rem;-webkit-transition:.3s color;transition:.3s color}textarea{width:100%;height:3rem;background-color:transparent}textarea.materialize-textarea{line-height:normal;overflow-y:hidden;padding:.8rem 0 .8rem 0;resize:none;min-height:3rem;-webkit-box-sizing:border-box;box-sizing:border-box}.hiddendiv{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;overflow-wrap:break-word;padding-top:1.2rem;position:absolute;top:0;z-index:-1}.autocomplete-content li .highlight{color:#444}.autocomplete-content li img{height:40px;width:40px;margin:5px 15px}.character-counter{min-height:18px}[type="radio"]:not(:checked),[type="radio"]:checked{position:absolute;opacity:0;pointer-events:none}[type="radio"]:not(:checked)+span,[type="radio"]:checked+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type="radio"]+span:before,[type="radio"]+span:after{content:'';position:absolute;left:0;top:0;margin:4px;width:16px;height:16px;z-index:0;-webkit-transition:.28s ease;transition:.28s ease}[type="radio"]:not(:checked)+span:before,[type="radio"]:not(:checked)+span:after,[type="radio"]:checked+span:before,[type="radio"]:checked+span:after,[type="radio"].with-gap:checked+span:before,[type="radio"].with-gap:checked+span:after{border-radius:50%}[type="radio"]:not(:checked)+span:before,[type="radio"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type="radio"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type="radio"]:checked+span:before{border:2px solid transparent}[type="radio"]:checked+span:after,[type="radio"].with-gap:checked+span:before,[type="radio"].with-gap:checked+span:after{border:2px solid #26a69a}[type="radio"]:checked+span:after,[type="radio"].with-gap:checked+span:after{background-color:#26a69a}[type="radio"]:checked+span:after{-webkit-transform:scale(1.02);transform:scale(1.02)}[type="radio"].with-gap:checked+span:after{-webkit-transform:scale(0.5);transform:scale(0.5)}[type="radio"].tabbed:focus+span:before{-webkit-box-shadow:0 0 0 10px rgba(0,0,0,0.1);box-shadow:0 0 0 10px rgba(0,0,0,0.1)}[type="radio"].with-gap:disabled:checked+span:before{border:2px solid rgba(0,0,0,0.42)}[type="radio"].with-gap:disabled:checked+span:after{border:none;background-color:rgba(0,0,0,0.42)}[type="radio"]:disabled:not(:checked)+span:before,[type="radio"]:disabled:checked+span:before{background-color:transparent;border-color:rgba(0,0,0,0.42)}[type="radio"]:disabled+span{color:rgba(0,0,0,0.42)}[type="radio"]:disabled:not(:checked)+span:before{border-color:rgba(0,0,0,0.42)}[type="radio"]:disabled:checked+span:after{background-color:rgba(0,0,0,0.42);border-color:#949494}[type="checkbox"]:not(:checked),[type="checkbox"]:checked{position:absolute;opacity:0;pointer-events:none}[type="checkbox"]+span:not(.lever){position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type="checkbox"]+span:not(.lever):before,[type="checkbox"]:not(.filled-in)+span:not(.lever):after{content:'';position:absolute;top:0;left:0;width:18px;height:18px;z-index:0;border:2px solid #5a5a5a;border-radius:1px;margin-top:3px;-webkit-transition:.2s;transition:.2s}[type="checkbox"]:not(.filled-in)+span:not(.lever):after{border:0;-webkit-transform:scale(0);transform:scale(0)}[type="checkbox"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type="checkbox"].tabbed:focus+span:not(.lever):after{-webkit-transform:scale(1);transform:scale(1);border:0;border-radius:50%;-webkit-box-shadow:0 0 0 10px rgba(0,0,0,0.1);box-shadow:0 0 0 10px rgba(0,0,0,0.1);background-color:rgba(0,0,0,0.1)}[type="checkbox"]:checked+span:not(.lever):before{top:-4px;left:-5px;width:12px;height:22px;border-top:2px solid transparent;border-left:2px solid transparent;border-right:2px solid #26a69a;border-bottom:2px solid #26a69a;-webkit-transform:rotate(40deg);transform:rotate(40deg);-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type="checkbox"]:checked:disabled+span:before{border-right:2px solid rgba(0,0,0,0.42);border-bottom:2px solid rgba(0,0,0,0.42)}[type="checkbox"]:indeterminate+span:not(.lever):before{top:-11px;left:-12px;width:10px;height:22px;border-top:none;border-left:none;border-right:2px solid #26a69a;border-bottom:none;-webkit-transform:rotate(90deg);transform:rotate(90deg);-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type="checkbox"]:indeterminate:disabled+span:not(.lever):before{border-right:2px solid rgba(0,0,0,0.42);background-color:transparent}[type="checkbox"].filled-in+span:not(.lever):after{border-radius:2px}[type="checkbox"].filled-in+span:not(.lever):before,[type="checkbox"].filled-in+span:not(.lever):after{content:'';left:0;position:absolute;-webkit-transition:border .25s, background-color .25s, width .20s .1s, height .20s .1s, top .20s .1s, left .20s .1s;transition:border .25s, background-color .25s, width .20s .1s, height .20s .1s, top .20s .1s, left .20s .1s;z-index:1}[type="checkbox"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type="checkbox"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}[type="checkbox"].filled-in:checked+span:not(.lever):before{top:0;left:1px;width:8px;height:13px;border-top:2px solid transparent;border-left:2px solid transparent;border-right:2px solid #fff;border-bottom:2px solid #fff;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type="checkbox"].filled-in:checked+span:not(.lever):after{top:0;width:20px;height:20px;border:2px solid #26a69a;background-color:#26a69a;z-index:0}[type="checkbox"].filled-in.tabbed:focus+span:not(.lever):after{border-radius:2px;border-color:#5a5a5a;background-color:rgba(0,0,0,0.1)}[type="checkbox"].filled-in.tabbed:checked:focus+span:not(.lever):after{border-radius:2px;background-color:#26a69a;border-color:#26a69a}[type="checkbox"].filled-in:disabled:not(:checked)+span:not(.lever):before{background-color:transparent;border:2px solid transparent}[type="checkbox"].filled-in:disabled:not(:checked)+span:not(.lever):after{border-color:transparent;background-color:#949494}[type="checkbox"].filled-in:disabled:checked+span:not(.lever):before{background-color:transparent}[type="checkbox"].filled-in:disabled:checked+span:not(.lever):after{background-color:#949494;border-color:#949494}.switch,.switch *{-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.switch label{cursor:pointer}.switch label input[type=checkbox]{opacity:0;width:0;height:0}.switch label input[type=checkbox]:checked+.lever{background-color:#84c7c1}.switch label input[type=checkbox]:checked+.lever:before,.switch label input[type=checkbox]:checked+.lever:after{left:18px}.switch label input[type=checkbox]:checked+.lever:after{background-color:#26a69a}.switch label .lever{content:"";display:inline-block;position:relative;width:36px;height:14px;background-color:rgba(0,0,0,0.38);border-radius:15px;margin-right:10px;-webkit-transition:background 0.3s ease;transition:background 0.3s ease;vertical-align:middle;margin:0 16px}.switch label .lever:before,.switch label .lever:after{content:"";position:absolute;display:inline-block;width:20px;height:20px;border-radius:50%;left:0;top:-3px;-webkit-transition:left 0.3s ease, background .3s ease, -webkit-box-shadow 0.1s ease, -webkit-transform .1s ease;transition:left 0.3s ease, background .3s ease, -webkit-box-shadow 0.1s ease, -webkit-transform .1s ease;transition:left 0.3s ease, background .3s ease, box-shadow 0.1s ease, transform .1s ease;transition:left 0.3s ease, background .3s ease, box-shadow 0.1s ease, transform .1s ease, -webkit-box-shadow 0.1s ease, -webkit-transform .1s ease}.switch label .lever:before{background-color:rgba(38,166,154,0.15)}.switch label .lever:after{background-color:#F1F1F1;-webkit-box-shadow:0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12);box-shadow:0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12)}input[type=checkbox]:checked:not(:disabled) ~ .lever:active::before,input[type=checkbox]:checked:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(38,166,154,0.15)}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}.switch input[type=checkbox][disabled]+.lever{cursor:default;background-color:rgba(0,0,0,0.12)}.switch label input[type=checkbox][disabled]+.lever:after,.switch label input[type=checkbox][disabled]:checked+.lever:after{background-color:#949494}select{display:none}select.browser-default{display:block}select{background-color:rgba(255,255,255,0.9);width:100%;padding:5px;border:1px solid #f2f2f2;border-radius:2px;height:3rem}.select-label{position:absolute}.select-wrapper{position:relative}.select-wrapper.valid+label,.select-wrapper.invalid+label{width:100%;pointer-events:none}.select-wrapper input.select-dropdown{position:relative;cursor:pointer;background-color:transparent;border:none;border-bottom:1px solid #9e9e9e;outline:none;height:3rem;line-height:3rem;width:100%;font-size:16px;margin:0 0 8px 0;padding:0;display:block;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1}.select-wrapper input.select-dropdown:focus{border-bottom:1px solid #26a69a}.select-wrapper .caret{position:absolute;right:0;top:0;bottom:0;margin:auto 0;z-index:0;fill:rgba(0,0,0,0.87)}.select-wrapper+label{position:absolute;top:-26px;font-size:.8rem}select:disabled{color:rgba(0,0,0,0.42)}.select-wrapper.disabled+label{color:rgba(0,0,0,0.42)}.select-wrapper.disabled .caret{fill:rgba(0,0,0,0.42)}.select-wrapper input.select-dropdown:disabled{color:rgba(0,0,0,0.42);cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.select-wrapper i{color:rgba(0,0,0,0.3)}.select-dropdown li.disabled,.select-dropdown li.disabled>span,.select-dropdown li.optgroup{color:rgba(0,0,0,0.3);background-color:transparent}.select-dropdown.dropdown-content li:hover{background-color:rgba(0,0,0,0.08)}.select-dropdown.dropdown-content li.selected{background-color:rgba(0,0,0,0.03)}.select-dropdown.dropdown-content li:focus{background-color:rgba(0,0,0,0.08)}.prefix ~ .select-wrapper{margin-left:3rem;width:92%;width:calc(100% - 3rem)}.prefix ~ label{margin-left:3rem}.select-dropdown li img{height:40px;width:40px;margin:5px 15px;float:right}.select-dropdown li.optgroup{border-top:1px solid #eee}.select-dropdown li.optgroup.selected>span{color:rgba(0,0,0,0.7)}.select-dropdown li.optgroup>span{color:rgba(0,0,0,0.4)}.select-dropdown li.optgroup ~ li.optgroup-option{padding-left:1rem}.file-field{position:relative}.file-field .file-path-wrapper{overflow:hidden;padding-left:10px}.file-field input.file-path{width:100%}.file-field .btn,.file-field .btn-large,.file-field .btn-small{float:left;height:3rem;line-height:3rem}.file-field span{cursor:pointer}.file-field input[type=file]{position:absolute;top:0;right:0;left:0;bottom:0;width:100%;margin:0;padding:0;font-size:20px;cursor:pointer;opacity:0;filter:alpha(opacity=0)}.file-field input[type=file]::-webkit-file-upload-button{display:none}.range-field{position:relative}input[type=range],input[type=range]+.thumb{cursor:pointer}input[type=range]{position:relative;background-color:transparent;border:none;outline:none;width:100%;margin:15px 0;padding:0}input[type=range]:focus{outline:none}input[type=range]+.thumb{position:absolute;top:10px;left:0;border:none;height:0;width:0;border-radius:50%;background-color:#26a69a;margin-left:7px;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}input[type=range]+.thumb .value{display:block;width:30px;text-align:center;color:#26a69a;font-size:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}input[type=range]+.thumb.active{border-radius:50% 50% 50% 0}input[type=range]+.thumb.active .value{color:#fff;margin-left:-1px;margin-top:8px;font-size:10px}input[type=range]{-webkit-appearance:none}input[type=range]::-webkit-slider-runnable-track{height:3px;background:#c2c0c2;border:none}input[type=range]::-webkit-slider-thumb{border:none;height:14px;width:14px;border-radius:50%;background:#26a69a;-webkit-transition:-webkit-box-shadow .3s;transition:-webkit-box-shadow .3s;transition:box-shadow .3s;transition:box-shadow .3s, -webkit-box-shadow .3s;-webkit-appearance:none;background-color:#26a69a;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;margin:-5px 0 0 0}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range]{border:1px solid white}input[type=range]::-moz-range-track{height:3px;background:#c2c0c2;border:none}input[type=range]::-moz-focus-inner{border:0}input[type=range]::-moz-range-thumb{border:none;height:14px;width:14px;border-radius:50%;background:#26a69a;-webkit-transition:-webkit-box-shadow .3s;transition:-webkit-box-shadow .3s;transition:box-shadow .3s;transition:box-shadow .3s, -webkit-box-shadow .3s;margin-top:-5px}input[type=range]:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range]::-ms-track{height:3px;background:transparent;border-color:transparent;border-width:6px 0;color:transparent}input[type=range]::-ms-fill-lower{background:#777}input[type=range]::-ms-fill-upper{background:#ddd}input[type=range]::-ms-thumb{border:none;height:14px;width:14px;border-radius:50%;background:#26a69a;-webkit-transition:-webkit-box-shadow .3s;transition:-webkit-box-shadow .3s;transition:box-shadow .3s;transition:box-shadow .3s, -webkit-box-shadow .3s}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}.table-of-contents.fixed{position:fixed}.table-of-contents li{padding:2px 0}.table-of-contents a{display:inline-block;font-weight:300;color:#757575;padding-left:16px;height:1.5rem;line-height:1.5rem;letter-spacing:.4;display:inline-block}.table-of-contents a:hover{color:#a8a8a8;padding-left:15px;border-left:1px solid #ee6e73}.table-of-contents a.active{font-weight:500;padding-left:14px;border-left:2px solid #ee6e73}.sidenav{position:fixed;width:300px;left:0;top:0;margin:0;-webkit-transform:translateX(-100%);transform:translateX(-100%);height:100%;height:calc(100% + 60px);height:-moz-calc(100%);padding-bottom:60px;background-color:#fff;z-index:999;overflow-y:auto;will-change:transform;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform:translateX(-105%);transform:translateX(-105%)}.sidenav.right-aligned{right:0;-webkit-transform:translateX(105%);transform:translateX(105%);left:auto;-webkit-transform:translateX(100%);transform:translateX(100%)}.sidenav .collapsible{margin:0}.sidenav li{float:none;line-height:48px}.sidenav li.active{background-color:rgba(0,0,0,0.05)}.sidenav li>a{color:rgba(0,0,0,0.87);display:block;font-size:14px;font-weight:500;height:48px;line-height:48px;padding:0 32px}.sidenav li>a:hover{background-color:rgba(0,0,0,0.05)}.sidenav li>a.btn,.sidenav li>a.btn-large,.sidenav li>a.btn-small,.sidenav li>a.btn-large,.sidenav li>a.btn-flat,.sidenav li>a.btn-floating{margin:10px 15px}.sidenav li>a.btn,.sidenav li>a.btn-large,.sidenav li>a.btn-small,.sidenav li>a.btn-large,.sidenav li>a.btn-floating{color:#fff}.sidenav li>a.btn-flat{color:#343434}.sidenav li>a.btn:hover,.sidenav li>a.btn-large:hover,.sidenav li>a.btn-small:hover,.sidenav li>a.btn-large:hover{background-color:#2bbbad}.sidenav li>a.btn-floating:hover{background-color:#26a69a}.sidenav li>a>i,.sidenav li>a>[class^="mdi-"],.sidenav li>a li>a>[class*="mdi-"],.sidenav li>a>i.material-icons{float:left;height:48px;line-height:48px;margin:0 32px 0 0;width:24px;color:rgba(0,0,0,0.54)}.sidenav .divider{margin:8px 0 0 0}.sidenav .subheader{cursor:initial;pointer-events:none;color:rgba(0,0,0,0.54);font-size:14px;font-weight:500;line-height:48px}.sidenav .subheader:hover{background-color:transparent}.sidenav .user-view{position:relative;padding:32px 32px 0;margin-bottom:8px}.sidenav .user-view>a{height:auto;padding:0}.sidenav .user-view>a:hover{background-color:transparent}.sidenav .user-view .background{overflow:hidden;position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1}.sidenav .user-view .circle,.sidenav .user-view .name,.sidenav .user-view .email{display:block}.sidenav .user-view .circle{height:64px;width:64px}.sidenav .user-view .name,.sidenav .user-view .email{font-size:14px;line-height:24px}.sidenav .user-view .name{margin-top:16px;font-weight:500}.sidenav .user-view .email{padding-bottom:16px;font-weight:400}.drag-target{height:100%;width:10px;position:fixed;top:0;z-index:998}.drag-target.right-aligned{right:0}.sidenav.sidenav-fixed{left:0;-webkit-transform:translateX(0);transform:translateX(0);position:fixed}.sidenav.sidenav-fixed.right-aligned{right:0;left:auto}@media only screen and (max-width: 992px){.sidenav.sidenav-fixed{-webkit-transform:translateX(-105%);transform:translateX(-105%)}.sidenav.sidenav-fixed.right-aligned{-webkit-transform:translateX(105%);transform:translateX(105%)}.sidenav>a{padding:0 16px}.sidenav .user-view{padding:16px 16px 0}}.sidenav .collapsible-body>ul:not(.collapsible)>li.active,.sidenav.sidenav-fixed .collapsible-body>ul:not(.collapsible)>li.active{background-color:#ee6e73}.sidenav .collapsible-body>ul:not(.collapsible)>li.active a,.sidenav.sidenav-fixed .collapsible-body>ul:not(.collapsible)>li.active a{color:#fff}.sidenav .collapsible-body{padding:0}.sidenav-overlay{position:fixed;top:0;left:0;right:0;opacity:0;height:120vh;background-color:rgba(0,0,0,0.5);z-index:997;display:none}.preloader-wrapper{display:inline-block;position:relative;width:50px;height:50px}.preloader-wrapper.small{width:36px;height:36px}.preloader-wrapper.big{width:64px;height:64px}.preloader-wrapper.active{-webkit-animation:container-rotate 1568ms linear infinite;animation:container-rotate 1568ms linear infinite}@-webkit-keyframes container-rotate{to{-webkit-transform:rotate(360deg)}}@keyframes container-rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.spinner-layer{position:absolute;width:100%;height:100%;opacity:0;border-color:#26a69a}.spinner-blue,.spinner-blue-only{border-color:#4285f4}.spinner-red,.spinner-red-only{border-color:#db4437}.spinner-yellow,.spinner-yellow-only{border-color:#f4b400}.spinner-green,.spinner-green-only{border-color:#0f9d58}.active .spinner-layer.spinner-blue{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,blue-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,blue-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.active .spinner-layer.spinner-red{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,red-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,red-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.active .spinner-layer.spinner-yellow{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,yellow-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,yellow-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.active .spinner-layer.spinner-green{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,green-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,green-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.active .spinner-layer,.active .spinner-layer.spinner-blue-only,.active .spinner-layer.spinner-red-only,.active .spinner-layer.spinner-yellow-only,.active .spinner-layer.spinner-green-only{opacity:1;-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}@-webkit-keyframes fill-unfill-rotate{12.5%{-webkit-transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg)}to{-webkit-transform:rotate(1080deg)}}@keyframes fill-unfill-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}to{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}@-webkit-keyframes blue-fade-in-out{from{opacity:1}25%{opacity:1}26%{opacity:0}89%{opacity:0}90%{opacity:1}100%{opacity:1}}@keyframes blue-fade-in-out{from{opacity:1}25%{opacity:1}26%{opacity:0}89%{opacity:0}90%{opacity:1}100%{opacity:1}}@-webkit-keyframes red-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:1}50%{opacity:1}51%{opacity:0}}@keyframes red-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:1}50%{opacity:1}51%{opacity:0}}@-webkit-keyframes yellow-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:1}75%{opacity:1}76%{opacity:0}}@keyframes yellow-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:1}75%{opacity:1}76%{opacity:0}}@-webkit-keyframes green-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:1}90%{opacity:1}100%{opacity:0}}@keyframes green-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:1}90%{opacity:1}100%{opacity:0}}.gap-patch{position:absolute;top:0;left:45%;width:10%;height:100%;overflow:hidden;border-color:inherit}.gap-patch .circle{width:1000%;left:-450%}.circle-clipper{display:inline-block;position:relative;width:50%;height:100%;overflow:hidden;border-color:inherit}.circle-clipper .circle{width:200%;height:100%;border-width:3px;border-style:solid;border-color:inherit;border-bottom-color:transparent !important;border-radius:50%;-webkit-animation:none;animation:none;position:absolute;top:0;right:0;bottom:0}.circle-clipper.left .circle{left:0;border-right-color:transparent !important;-webkit-transform:rotate(129deg);transform:rotate(129deg)}.circle-clipper.right .circle{left:-100%;border-left-color:transparent !important;-webkit-transform:rotate(-129deg);transform:rotate(-129deg)}.active .circle-clipper.left .circle{-webkit-animation:left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.active .circle-clipper.right .circle{-webkit-animation:right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;animation:right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}@-webkit-keyframes left-spin{from{-webkit-transform:rotate(130deg)}50%{-webkit-transform:rotate(-5deg)}to{-webkit-transform:rotate(130deg)}}@keyframes left-spin{from{-webkit-transform:rotate(130deg);transform:rotate(130deg)}50%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}to{-webkit-transform:rotate(130deg);transform:rotate(130deg)}}@-webkit-keyframes right-spin{from{-webkit-transform:rotate(-130deg)}50%{-webkit-transform:rotate(5deg)}to{-webkit-transform:rotate(-130deg)}}@keyframes right-spin{from{-webkit-transform:rotate(-130deg);transform:rotate(-130deg)}50%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}to{-webkit-transform:rotate(-130deg);transform:rotate(-130deg)}}#spinnerContainer.cooldown{-webkit-animation:container-rotate 1568ms linear infinite,fade-out 400ms cubic-bezier(0.4, 0, 0.2, 1);animation:container-rotate 1568ms linear infinite,fade-out 400ms cubic-bezier(0.4, 0, 0.2, 1)}@-webkit-keyframes fade-out{from{opacity:1}to{opacity:0}}@keyframes fade-out{from{opacity:1}to{opacity:0}}.slider{position:relative;height:400px;width:100%}.slider.fullscreen{height:100%;width:100%;position:absolute;top:0;left:0;right:0;bottom:0}.slider.fullscreen ul.slides{height:100%}.slider.fullscreen ul.indicators{z-index:2;bottom:30px}.slider .slides{background-color:#9e9e9e;margin:0;height:400px}.slider .slides li{opacity:0;position:absolute;top:0;left:0;z-index:1;width:100%;height:inherit;overflow:hidden}.slider .slides li img{height:100%;width:100%;background-size:cover;background-position:center}.slider .slides li .caption{color:#fff;position:absolute;top:15%;left:15%;width:70%;opacity:0}.slider .slides li .caption p{color:#e0e0e0}.slider .slides li.active{z-index:2}.slider .indicators{position:absolute;text-align:center;left:0;right:0;bottom:0;margin:0}.slider .indicators .indicator-item{display:inline-block;position:relative;cursor:pointer;height:16px;width:16px;margin:0 12px;background-color:#e0e0e0;-webkit-transition:background-color .3s;transition:background-color .3s;border-radius:50%}.slider .indicators .indicator-item.active{background-color:#4CAF50}.carousel{overflow:hidden;position:relative;width:100%;height:400px;-webkit-perspective:500px;perspective:500px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transform-origin:0% 50%;transform-origin:0% 50%}.carousel.carousel-slider{top:0;left:0}.carousel.carousel-slider .carousel-fixed-item{position:absolute;left:0;right:0;bottom:20px;z-index:1}.carousel.carousel-slider .carousel-fixed-item.with-indicators{bottom:68px}.carousel.carousel-slider .carousel-item{width:100%;height:100%;min-height:400px;position:absolute;top:0;left:0}.carousel.carousel-slider .carousel-item h2{font-size:24px;font-weight:500;line-height:32px}.carousel.carousel-slider .carousel-item p{font-size:15px}.carousel .carousel-item{visibility:hidden;width:200px;height:200px;position:absolute;top:0;left:0}.carousel .carousel-item>img{width:100%}.carousel .indicators{position:absolute;text-align:center;left:0;right:0;bottom:0;margin:0}.carousel .indicators .indicator-item{display:inline-block;position:relative;cursor:pointer;height:8px;width:8px;margin:24px 4px;background-color:rgba(255,255,255,0.5);-webkit-transition:background-color .3s;transition:background-color .3s;border-radius:50%}.carousel .indicators .indicator-item.active{background-color:#fff}.carousel.scrolling .carousel-item .materialboxed,.carousel .carousel-item:not(.active) .materialboxed{pointer-events:none}.tap-target-wrapper{width:800px;height:800px;position:fixed;z-index:1000;visibility:hidden;-webkit-transition:visibility 0s .3s;transition:visibility 0s .3s}.tap-target-wrapper.open{visibility:visible;-webkit-transition:visibility 0s;transition:visibility 0s}.tap-target-wrapper.open .tap-target{-webkit-transform:scale(1);transform:scale(1);opacity:.95;-webkit-transition:opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1),-webkit-transform 0.3s cubic-bezier(0.42, 0, 0.58, 1);transition:opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1),-webkit-transform 0.3s cubic-bezier(0.42, 0, 0.58, 1);transition:transform 0.3s cubic-bezier(0.42, 0, 0.58, 1),opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1);transition:transform 0.3s cubic-bezier(0.42, 0, 0.58, 1),opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1),-webkit-transform 0.3s cubic-bezier(0.42, 0, 0.58, 1)}.tap-target-wrapper.open .tap-target-wave::before{-webkit-transform:scale(1);transform:scale(1)}.tap-target-wrapper.open .tap-target-wave::after{visibility:visible;-webkit-animation:pulse-animation 1s cubic-bezier(0.24, 0, 0.38, 1) infinite;animation:pulse-animation 1s cubic-bezier(0.24, 0, 0.38, 1) infinite;-webkit-transition:opacity .3s, visibility 0s 1s, -webkit-transform .3s;transition:opacity .3s, visibility 0s 1s, -webkit-transform .3s;transition:opacity .3s, transform .3s, visibility 0s 1s;transition:opacity .3s, transform .3s, visibility 0s 1s, -webkit-transform .3s}.tap-target{position:absolute;font-size:1rem;border-radius:50%;background-color:#ee6e73;-webkit-box-shadow:0 20px 20px 0 rgba(0,0,0,0.14),0 10px 50px 0 rgba(0,0,0,0.12),0 30px 10px -20px rgba(0,0,0,0.2);box-shadow:0 20px 20px 0 rgba(0,0,0,0.14),0 10px 50px 0 rgba(0,0,0,0.12),0 30px 10px -20px rgba(0,0,0,0.2);width:100%;height:100%;opacity:0;-webkit-transform:scale(0);transform:scale(0);-webkit-transition:opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1),-webkit-transform 0.3s cubic-bezier(0.42, 0, 0.58, 1);transition:opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1),-webkit-transform 0.3s cubic-bezier(0.42, 0, 0.58, 1);transition:transform 0.3s cubic-bezier(0.42, 0, 0.58, 1),opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1);transition:transform 0.3s cubic-bezier(0.42, 0, 0.58, 1),opacity 0.3s cubic-bezier(0.42, 0, 0.58, 1),-webkit-transform 0.3s cubic-bezier(0.42, 0, 0.58, 1)}.tap-target-content{position:relative;display:table-cell}.tap-target-wave{position:absolute;border-radius:50%;z-index:10001}.tap-target-wave::before,.tap-target-wave::after{content:'';display:block;position:absolute;width:100%;height:100%;border-radius:50%;background-color:#ffffff}.tap-target-wave::before{-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s, -webkit-transform .3s}.tap-target-wave::after{visibility:hidden;-webkit-transition:opacity .3s, visibility 0s, -webkit-transform .3s;transition:opacity .3s, visibility 0s, -webkit-transform .3s;transition:opacity .3s, transform .3s, visibility 0s;transition:opacity .3s, transform .3s, visibility 0s, -webkit-transform .3s;z-index:-1}.tap-target-origin{top:50%;left:50%;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);z-index:10002;position:absolute !important}.tap-target-origin:not(.btn):not(.btn-large):not(.btn-small),.tap-target-origin:not(.btn):not(.btn-large):not(.btn-small):hover{background:none}@media only screen and (max-width: 600px){.tap-target,.tap-target-wrapper{width:600px;height:600px}}.pulse{overflow:visible;position:relative}.pulse::before{content:'';display:block;position:absolute;width:100%;height:100%;top:0;left:0;background-color:inherit;border-radius:inherit;-webkit-transition:opacity .3s, -webkit-transform .3s;transition:opacity .3s, -webkit-transform .3s;transition:opacity .3s, transform .3s;transition:opacity .3s, transform .3s, -webkit-transform .3s;-webkit-animation:pulse-animation 1s cubic-bezier(0.24, 0, 0.38, 1) infinite;animation:pulse-animation 1s cubic-bezier(0.24, 0, 0.38, 1) infinite;z-index:-1}@-webkit-keyframes pulse-animation{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:0;-webkit-transform:scale(1.5);transform:scale(1.5)}100%{opacity:0;-webkit-transform:scale(1.5);transform:scale(1.5)}}@keyframes pulse-animation{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:0;-webkit-transform:scale(1.5);transform:scale(1.5)}100%{opacity:0;-webkit-transform:scale(1.5);transform:scale(1.5)}}.datepicker-modal{max-width:325px;min-width:300px;max-height:none}.datepicker-container.modal-content{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:0}.datepicker-controls{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;width:280px;margin:0 auto}.datepicker-controls .selects-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.datepicker-controls .select-wrapper input{border-bottom:none;text-align:center;margin:0}.datepicker-controls .select-wrapper input:focus{border-bottom:none}.datepicker-controls .select-wrapper .caret{display:none}.datepicker-controls .select-year input{width:50px}.datepicker-controls .select-month input{width:70px}.month-prev,.month-next{margin-top:4px;cursor:pointer;background-color:transparent;border:none}.datepicker-date-display{-webkit-box-flex:1;-webkit-flex:1 auto;-ms-flex:1 auto;flex:1 auto;background-color:#26a69a;color:#fff;padding:20px 22px;font-weight:500}.datepicker-date-display .year-text{display:block;font-size:1.5rem;line-height:25px;color:rgba(255,255,255,0.7)}.datepicker-date-display .date-text{display:block;font-size:2.8rem;line-height:47px;font-weight:500}.datepicker-calendar-container{-webkit-box-flex:2.5;-webkit-flex:2.5 auto;-ms-flex:2.5 auto;flex:2.5 auto}.datepicker-table{width:280px;font-size:1rem;margin:0 auto}.datepicker-table thead{border-bottom:none}.datepicker-table th{padding:10px 5px;text-align:center}.datepicker-table tr{border:none}.datepicker-table abbr{text-decoration:none;color:#999}.datepicker-table td{border-radius:50%;padding:0}.datepicker-table td.is-today{color:#26a69a}.datepicker-table td.is-selected{background-color:#26a69a;color:#fff}.datepicker-table td.is-outside-current-month,.datepicker-table td.is-disabled{color:rgba(0,0,0,0.3);pointer-events:none}.datepicker-day-button{background-color:transparent;border:none;line-height:38px;display:block;width:100%;border-radius:50%;padding:0 5px;cursor:pointer;color:inherit}.datepicker-day-button:focus{background-color:rgba(43,161,150,0.25)}.datepicker-footer{width:280px;margin:0 auto;padding-bottom:5px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.datepicker-cancel,.datepicker-clear,.datepicker-today,.datepicker-done{color:#26a69a;padding:0 1rem}.datepicker-clear{color:#F44336}@media only screen and (min-width: 601px){.datepicker-modal{max-width:625px}.datepicker-container.modal-content{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.datepicker-controls,.datepicker-table,.datepicker-footer{width:320px}.datepicker-day-button{line-height:44px}}.timepicker-modal{max-width:325px;max-height:none}.timepicker-container.modal-content{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:0}.text-primary{color:#fff}.timepicker-digital-display{-webkit-box-flex:1;-webkit-flex:1 auto;-ms-flex:1 auto;flex:1 auto;background-color:#26a69a;padding:10px;font-weight:300}.timepicker-text-container{font-size:4rem;font-weight:bold;text-align:center;color:rgba(255,255,255,0.6);font-weight:400;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-span-hours,.timepicker-span-minutes,.timepicker-span-am-pm div{cursor:pointer}.timepicker-span-hours{margin-right:3px}.timepicker-span-minutes{margin-left:3px}.timepicker-display-am-pm{font-size:1.3rem;position:absolute;right:1rem;bottom:1rem;font-weight:400}.timepicker-analog-display{-webkit-box-flex:2.5;-webkit-flex:2.5 auto;-ms-flex:2.5 auto;flex:2.5 auto}.timepicker-plate{background-color:#eee;border-radius:50%;width:270px;height:270px;overflow:visible;position:relative;margin:auto;margin-top:25px;margin-bottom:5px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-canvas,.timepicker-dial{position:absolute;left:0;right:0;top:0;bottom:0}.timepicker-minutes{visibility:hidden}.timepicker-tick{border-radius:50%;color:rgba(0,0,0,0.87);line-height:40px;text-align:center;width:40px;height:40px;position:absolute;cursor:pointer;font-size:15px}.timepicker-tick.active,.timepicker-tick:hover{background-color:rgba(38,166,154,0.25)}.timepicker-dial{-webkit-transition:opacity 350ms, -webkit-transform 350ms;transition:opacity 350ms, -webkit-transform 350ms;transition:transform 350ms, opacity 350ms;transition:transform 350ms, opacity 350ms, -webkit-transform 350ms}.timepicker-dial-out{opacity:0}.timepicker-dial-out.timepicker-hours{-webkit-transform:scale(1.1, 1.1);transform:scale(1.1, 1.1)}.timepicker-dial-out.timepicker-minutes{-webkit-transform:scale(0.8, 0.8);transform:scale(0.8, 0.8)}.timepicker-canvas{-webkit-transition:opacity 175ms;transition:opacity 175ms}.timepicker-canvas line{stroke:#26a69a;stroke-width:4;stroke-linecap:round}.timepicker-canvas-out{opacity:0.25}.timepicker-canvas-bearing{stroke:none;fill:#26a69a}.timepicker-canvas-bg{stroke:none;fill:#26a69a}.timepicker-footer{margin:0 auto;padding:5px 1rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.timepicker-clear{color:#F44336}.timepicker-close{color:#26a69a}.timepicker-clear,.timepicker-close{padding:0 20px}@media only screen and (min-width: 601px){.timepicker-modal{max-width:600px}.timepicker-container.modal-content{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.timepicker-text-container{top:32%}.timepicker-display-am-pm{position:relative;right:auto;bottom:auto;text-align:center;margin-top:1.2rem}}

--- END FILE: .\styles\lib\materialize.min.css ---
